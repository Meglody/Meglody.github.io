(function (factory) {
	typeof define === 'function' && define.amd ? define(factory) :
	factory();
})((function () { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getAugmentedNamespace(n) {
		if (n.__esModule) return n;
		var a = Object.defineProperty({}, '__esModule', {value: true});
		Object.keys(n).forEach(function (k) {
			var d = Object.getOwnPropertyDescriptor(n, k);
			Object.defineProperty(a, k, d.get ? d : {
				enumerable: true,
				get: function () {
					return n[k];
				}
			});
		});
		return a;
	}

	var OpenSansRegular_ttf = {"size":32,"resolution":72,"underline_thickness":102,"underline_position":-205,"max_advance_width":2476,"height":2789,"descender":-600,"ascender":2189,"units_per_EM":2048,"style_name":"Regular","family_name":"Open Sans","kerning":[["\"","A",-128],["\"","T",64],["\"","V",64],["\"","W",64],["\"","a",-64],["\"","c",-128],["\"","d",-128],["\"","e",-128],["\"","g",-64],["\"","m",-64],["\"","n",-64],["\"","o",-128],["\"","p",-64],["\"","q",-128],["\"","r",-64],["\"","s",-64],["\"","u",-64],["'","A",-128],["'","T",64],["'","V",64],["'","W",64],["'","a",-64],["'","c",-128],["'","d",-128],["'","e",-128],["'","g",-64],["'","m",-64],["'","n",-64],["'","o",-128],["'","p",-64],["'","q",-128],["'","r",-64],["'","s",-64],["'","u",-64],["(","J",192],[",","C",-128],[",","G",-128],[",","O",-128],[",","Q",-128],[",","T",-128],[",","U",-64],[",","V",-128],[",","W",-128],[",","Y",-128],["-","T",-64],[".","C",-128],[".","G",-128],[".","O",-128],[".","Q",-128],[".","T",-128],[".","U",-64],[".","V",-128],[".","W",-128],[".","Y",-128],["A","\"",-128],["A","'",-128],["A","C",-64],["A","G",-64],["A","J",256],["A","O",-64],["A","Q",-64],["A","T",-128],["A","V",-64],["A","W",-64],["A","Y",-128],["B",",",-64],["B",".",-64],["B","A",-64],["B","T",-64],["B","X",-64],["C","C",-64],["C","G",-64],["C","O",-64],["C","Q",-64],["D",",",-64],["D",".",-64],["D","A",-64],["D","T",-64],["D","X",-64],["E","J",128],["F",",",-128],["F",".",-128],["F","?",64],["F","A",-64],["K","C",-64],["K","G",-64],["K","O",-64],["K","Q",-64],["L","\"",-192],["L","'",-192],["L","C",-64],["L","G",-64],["L","O",-64],["L","Q",-64],["L","T",-64],["L","V",-64],["L","W",-64],["L","Y",-64],["O",",",-64],["O",".",-64],["O","A",-64],["O","T",-64],["O","X",-64],["P",",",-256],["P",".",-256],["P","A",-128],["P","X",-64],["Q",",",-64],["Q",".",-64],["Q","A",-64],["Q","T",-64],["Q","X",-64],["T",",",-128],["T","-",-64],["T",".",-128],["T","?",64],["T","A",-128],["T","C",-64],["T","G",-64],["T","O",-64],["T","Q",-64],["T","T",64],["T","a",-192],["T","c",-128],["T","d",-128],["T","e",-128],["T","g",-128],["T","m",-128],["T","n",-128],["T","o",-128],["T","p",-128],["T","q",-128],["T","r",-128],["T","s",-128],["T","u",-128],["T","v",-64],["T","w",-64],["T","x",-64],["T","y",-64],["T","z",-64],["U",",",-64],["U",".",-64],["V",",",-128],["V",".",-128],["V","?",64],["V","A",-64],["V","a",-64],["V","c",-64],["V","d",-64],["V","e",-64],["V","o",-64],["V","q",-64],["W",",",-128],["W",".",-128],["W","?",64],["W","A",-64],["W","a",-64],["W","c",-64],["W","d",-64],["W","e",-64],["W","o",-64],["W","q",-64],["X","C",-64],["X","G",-64],["X","O",-64],["X","Q",-64],["Y",",",-128],["Y",".",-128],["Y","?",64],["Y","A",-128],["Y","C",-64],["Y","G",-64],["Y","O",-64],["Y","Q",-64],["Y","a",-128],["Y","c",-128],["Y","d",-128],["Y","e",-128],["Y","g",-64],["Y","m",-64],["Y","n",-64],["Y","o",-128],["Y","p",-64],["Y","q",-128],["Y","r",-64],["Y","s",-64],["Y","u",-64],["Y","z",-64],["[","J",192],["b","v",-64],["b","w",-64],["b","x",-64],["b","y",-64],["c","\"",64],["c","'",64],["e","v",-64],["e","w",-64],["e","x",-64],["e","y",-64],["f","\"",128],["f","'",128],["k","c",-64],["k","d",-64],["k","e",-64],["k","o",-64],["k","q",-64],["o","v",-64],["o","w",-64],["o","x",-64],["o","y",-64],["p","v",-64],["p","w",-64],["p","x",-64],["p","y",-64],["r","\"",64],["r","'",64],["r","a",-64],["r","c",-64],["r","d",-64],["r","e",-64],["r","o",-64],["r","q",-64],["t","\"",64],["t","'",64],["v","\"",64],["v","'",64],["v",",",-64],["v",".",-64],["v","?",64],["w","\"",64],["w","'",64],["w",",",-64],["w",".",-64],["w","?",64],["x","c",-64],["x","d",-64],["x","e",-64],["x","o",-64],["x","q",-64],["y","\"",64],["y","'",64],["y",",",-64],["y",".",-64],["y","?",64],["{","J",192]],"glyphs":{"0":{"xoff":1152,"width":1024,"height":1472,"hbx":64,"hby":1472,"path":[["m",1052,736],["q",1052,366,934,183],["q",817,0,575,0],["q",342,0,221,187],["q",100,375,100,736],["q",100,1110,217,1291],["q",334,1472,575,1472],["q",809,1472,930,1283],["q",1052,1094,1052,736],["m",268,736],["q",268,426,341,284],["q",414,143,575,143],["q",737,143,809,286],["q",882,430,882,736],["q",882,1043,809,1185],["q",737,1328,575,1328],["q",414,1328,341,1187],["q",268,1047,268,736]]},"1":{"xoff":1152,"width":640,"height":1472,"hbx":128,"hby":1472,"path":[["m",706,0],["l",544,0],["l",544,1060],["q",544,1192,552,1310],["q",531,1290,505,1269],["q",480,1248,272,1088],["l",185,1194],["l",566,1472],["l",706,1472],["l",706,0]]},"2":{"xoff":1152,"width":1024,"height":1472,"hbx":64,"hby":1472,"path":[["m",1044,0],["l",98,0],["l",98,142],["l",476,526],["q",648,702,703,777],["q",758,853,785,924],["q",813,996,813,1078],["q",813,1194,743,1262],["q",674,1330,550,1330],["q",461,1330,381,1300],["q",301,1270,203,1191],["l",117,1304],["q",316,1472,550,1472],["q",753,1472,868,1367],["q",983,1263,983,1086],["q",983,948,906,813],["q",830,679,621,472],["l",307,162],["l",307,154],["l",1044,154],["l",1044,0]]},"3":{"xoff":1152,"width":1024,"height":1472,"hbx":64,"hby":1472,"path":[["m",990,1115],["q",990,978,913,891],["q",836,804,694,775],["l",694,767],["q",867,746,950,657],["q",1034,569,1034,426],["q",1034,221,891,110],["q",749,0,486,0],["q",372,0,277,17],["q",182,35,92,79],["l",92,237],["q",185,190,290,165],["q",396,141,490,141],["q",862,141,862,430],["q",862,689,453,689],["l",312,689],["l",312,832],["l",455,832],["q",622,832,720,905],["q",818,978,818,1108],["q",818,1212,746,1271],["q",674,1330,550,1330],["q",456,1330,372,1304],["q",289,1278,182,1208],["l",100,1320],["q",189,1391,304,1431],["q",420,1472,548,1472],["q",758,1472,874,1376],["q",990,1281,990,1115]]},"4":{"xoff":1152,"width":1152,"height":1472,"hbx":0,"hby":1472,"path":[["m",1112,361],["l",901,361],["l",901,0],["l",742,0],["l",742,361],["l",42,361],["l",42,503],["l",725,1472],["l",901,1472],["l",901,512],["l",1112,512],["l",1112,361],["m",742,512],["l",742,987],["q",742,1126,752,1302],["l",744,1302],["q",697,1208,656,1147],["l",208,512],["l",742,512]]},"5":{"xoff":1152,"width":960,"height":1472,"hbx":128,"hby":1472,"path":[["m",550,896],["q",776,896,906,783],["q",1036,671,1036,476],["q",1036,253,894,126],["q",752,0,502,0],["q",259,0,131,79],["l",131,239],["q",200,194,301,168],["q",403,143,502,143],["q",675,143,770,224],["q",866,305,866,457],["q",866,755,498,755],["q",405,755,249,726],["l",165,781],["l",219,1472],["l",935,1472],["l",935,1319],["l",361,1319],["l",325,873],["q",438,896,550,896]]},"6":{"xoff":1152,"width":1024,"height":1472,"hbx":64,"hby":1472,"path":[["m",115,632],["q",115,1054,279,1263],["q",444,1472,767,1472],["q",878,1472,942,1453],["l",942,1310],["q",867,1335,770,1335],["q",540,1335,418,1189],["q",297,1043,285,730],["l",297,730],["q",405,896,638,896],["q",831,896,942,781],["q",1054,667,1054,471],["q",1054,251,931,125],["q",809,0,600,0],["q",377,0,246,167],["q",115,334,115,632],["m",598,141],["q",737,141,813,225],["q",890,310,890,471],["q",890,608,819,686],["q",748,765,606,765],["q",518,765,445,730],["q",372,695,328,633],["q",285,572,285,506],["q",285,408,324,323],["q",363,239,435,190],["q",507,141,598,141]]},"7":{"xoff":1152,"width":1024,"height":1472,"hbx":64,"hby":1472,"path":[["m",280,0],["l",874,1319],["l",92,1319],["l",92,1472],["l",1050,1472],["l",1050,1338],["l",461,0],["l",280,0]]},"8":{"xoff":1152,"width":1024,"height":1472,"hbx":64,"hby":1472,"path":[["m",575,1472],["q",771,1472,886,1379],["q",1001,1287,1001,1124],["q",1001,1017,935,928],["q",869,840,725,768],["q",900,686,974,595],["q",1048,505,1048,386],["q",1048,210,923,105],["q",798,0,580,0],["q",350,0,226,99],["q",102,198,102,380],["q",102,623,403,758],["q",268,835,209,925],["q",150,1015,150,1126],["q",150,1284,265,1378],["q",381,1472,575,1472],["m",266,378],["q",266,263,347,199],["q",429,135,576,135],["q",722,135,803,202],["q",884,269,884,385],["q",884,478,808,550],["q",732,622,542,690],["q",397,629,331,555],["q",266,481,266,378],["m",573,1337],["q",451,1337,382,1277],["q",313,1218,313,1119],["q",313,1028,370,962],["q",428,897,582,832],["q",721,891,779,959],["q",837,1028,837,1119],["q",837,1219,766,1278],["q",696,1337,573,1337]]},"9":{"xoff":1152,"width":1024,"height":1472,"hbx":64,"hby":1472,"path":[["m",1044,840],["q",1044,0,391,0],["q",277,0,210,20],["l",210,163],["q",288,137,388,137],["q",623,137,743,285],["q",863,433,874,739],["l",862,739],["q",808,659,719,617],["q",630,576,518,576],["q",328,576,216,687],["q",104,799,104,999],["q",104,1218,229,1345],["q",355,1472,560,1472],["q",706,1472,816,1397],["q",926,1322,985,1178],["q",1044,1035,1044,840],["m",560,1330],["q",420,1330,344,1243],["q",268,1156,268,1001],["q",268,865,338,787],["q",409,709,552,709],["q",641,709,715,744],["q",790,779,833,839],["q",876,900,876,966],["q",876,1065,836,1149],["q",796,1234,724,1282],["q",653,1330,560,1330]]}," ":{"xoff":512,"width":0,"height":0,"hbx":0,"hby":0,"path":[]},"!":{"xoff":576,"width":320,"height":1472,"hbx":128,"hby":1472,"path":[["m",334,448],["l",229,448],["l",178,1472],["l",385,1472],["l",334,448],["m",160,135],["q",160,271,280,271],["q",338,271,369,236],["q",401,201,401,135],["q",401,71,369,35],["q",337,0,280,0],["q",228,0,194,31],["q",160,63,160,135]]},"\"":{"xoff":832,"width":576,"height":512,"hbx":128,"hby":1472,"path":[["m",321,1472],["l",281,960],["l",176,960],["l",135,1472],["l",321,1472],["m",697,1472],["l",656,960],["l",552,960],["l",511,1472],["l",697,1472]]},"#":{"xoff":1344,"width":1344,"height":1472,"hbx":0,"hby":1472,"path":[["m",996,897],["l",928,576],["l",1215,576],["l",1215,447],["l",904,447],["l",818,0],["l",681,0],["l",767,447],["l",457,447],["l",373,0],["l",237,0],["l",319,447],["l",55,447],["l",55,576],["l",344,576],["l",414,897],["l",133,897],["l",133,1024],["l",436,1024],["l",520,1472],["l",659,1472],["l",575,1024],["l",887,1024],["l",973,1472],["l",1107,1472],["l",1021,1024],["l",1287,1024],["l",1287,897],["l",996,897],["m",481,576],["l",791,576],["l",859,897],["l",549,897],["l",481,576]]},"$":{"xoff":1152,"width":896,"height":1664,"hbx":128,"hby":1536,"path":[["m",1019,412],["q",1019,275,919,185],["q",820,96,641,73],["l",641,-128],["l",512,-128],["l",512,64],["q",402,64,298,81],["q",195,99,129,130],["l",129,286],["q",211,249,317,225],["q",424,202,512,202],["l",512,649],["q",310,714,229,801],["q",148,888,148,1025],["q",148,1157,248,1241],["q",348,1326,512,1344],["l",512,1536],["l",641,1536],["l",641,1346],["q",821,1341,988,1272],["l",937,1141],["q",792,1200,641,1211],["l",641,772],["q",794,721,870,673],["q",947,626,983,563],["q",1019,501,1019,412],["m",849,399],["q",849,473,806,518],["q",764,563,641,608],["l",641,212],["q",849,243,849,399],["m",317,1027],["q",317,950,360,903],["q",404,857,512,815],["l",512,1207],["q",416,1191,366,1144],["q",317,1097,317,1027]]},"%":{"xoff":1664,"width":1536,"height":1472,"hbx":64,"hby":1472,"path":[["m",241,1026],["q",241,861,277,779],["q",313,697,394,697],["q",554,697,554,1026],["q",554,1353,394,1353],["q",313,1353,277,1271],["q",241,1190,241,1026],["m",691,1026],["q",691,803,615,689],["q",540,576,394,576],["q",256,576,179,692],["q",103,808,103,1026],["q",103,1248,176,1360],["q",250,1472,394,1472],["q",537,1472,614,1356],["q",691,1240,691,1026],["m",1109,449],["q",1109,284,1145,202],["q",1181,120,1263,120],["q",1345,120,1384,201],["q",1423,282,1423,449],["q",1423,615,1384,695],["q",1345,775,1263,775],["q",1181,775,1145,695],["q",1109,615,1109,449],["m",1560,449],["q",1560,228,1484,114],["q",1409,0,1263,0],["q",1123,0,1047,116],["q",972,233,972,449],["q",972,671,1045,783],["q",1119,896,1263,896],["q",1403,896,1481,781],["q",1560,666,1560,449],["m",1306,1472],["l",505,0],["l",360,0],["l",1161,1472],["l",1306,1472]]},"&":{"xoff":1472,"width":1408,"height":1472,"hbx":64,"hby":1472,"path":[["m",410,1156],["q",410,1086,445,1022],["q",480,959,565,870],["q",690,946,739,1010],["q",788,1075,788,1159],["q",788,1237,738,1286],["q",688,1335,604,1335],["q",518,1335,464,1286],["q",410,1238,410,1156],["m",562,149],["q",798,149,954,275],["l",525,687],["q",416,624,371,582],["q",326,541,304,493],["q",283,446,283,385],["q",283,277,359,213],["q",435,149,562,149],["m",111,380],["q",111,504,179,599],["q",248,694,425,791],["q",341,887,311,936],["q",281,986,263,1039],["q",246,1093,246,1151],["q",246,1302,342,1387],["q",439,1472,611,1472],["q",771,1472,862,1387],["q",954,1303,954,1153],["q",954,1045,887,953],["q",820,862,666,768],["l",1065,386],["q",1120,446,1152,527],["q",1185,608,1208,704],["l",1376,704],["q",1309,427,1174,283],["l",1468,0],["l",1242,0],["l",1060,173],["q",944,80,824,40],["q",704,0,556,0],["q",344,0,227,101],["q",111,202,111,380]]},"'":{"xoff":448,"width":192,"height":512,"hbx":128,"hby":1472,"path":[["m",318,1472],["l",278,960],["l",173,960],["l",132,1472],["l",318,1472]]},"(":{"xoff":576,"width":512,"height":1792,"hbx":64,"hby":1472,"path":[["m",78,568],["q",78,834,151,1065],["q",225,1297,364,1472],["l",518,1472],["q",385,1278,318,1046],["q",252,815,252,570],["q",252,329,320,99],["q",388,-130,516,-320],["l",364,-320],["q",224,-149,151,78],["q",78,306,78,568]]},")":{"xoff":576,"width":512,"height":1792,"hbx":0,"hby":1472,"path":[["m",498,568],["q",498,304,424,76],["q",351,-151,212,-320],["l",60,-320],["q",188,-131,256,99],["q",324,329,324,570],["q",324,815,257,1046],["q",191,1278,58,1472],["l",212,1472],["q",352,1296,425,1064],["q",498,832,498,568]]},"*":{"xoff":1152,"width":1024,"height":896,"hbx":64,"hby":1536,"path":[["m",669,1536],["l",626,1150],["l",1032,1259],["l",1058,1080],["l",670,1050],["l",923,732],["l",748,640],["l",568,994],["l",405,640],["l",225,732],["l",472,1050],["l",88,1080],["l",118,1259],["l",516,1150],["l",473,1536],["l",669,1536]]},"+":{"xoff":1152,"width":1024,"height":1024,"hbx":64,"hby":1216,"path":[["m",645,768],["l",1057,768],["l",1057,630],["l",645,630],["l",645,204],["l",506,204],["l",506,630],["l",96,630],["l",96,768],["l",506,768],["l",506,1196],["l",645,1196],["l",645,768]]},",":{"xoff":512,"width":320,"height":512,"hbx":64,"hby":256,"path":[["m",357,256],["l",372,233],["q",346,131,296,-4],["q",246,-140,192,-256],["l",64,-256],["q",92,-150,125,6],["q",158,162,171,256],["l",357,256]]},"-":{"xoff":640,"width":512,"height":192,"hbx":64,"hby":640,"path":[["m",82,488],["l",82,640],["l",558,640],["l",558,488],["l",82,488]]},".":{"xoff":576,"width":320,"height":320,"hbx":128,"hby":320,"path":[["m",161,135],["q",161,202,191,236],["q",222,271,279,271],["q",337,271,369,236],["q",402,202,402,135],["q",402,70,369,35],["q",336,0,279,0],["q",228,0,194,31],["q",161,63,161,135]]},"/":{"xoff":768,"width":768,"height":1472,"hbx":0,"hby":1472,"path":[["m",747,1472],["l",190,0],["l",20,0],["l",577,1472],["l",747,1472]]},":":{"xoff":576,"width":320,"height":1088,"hbx":128,"hby":1088,"path":[["m",161,135],["q",161,202,191,236],["q",222,271,279,271],["q",337,271,369,236],["q",402,202,402,135],["q",402,70,369,35],["q",336,0,279,0],["q",228,0,194,31],["q",161,63,161,135],["m",161,953],["q",161,1088,279,1088],["q",402,1088,402,953],["q",402,888,369,853],["q",336,818,279,818],["q",228,818,194,849],["q",161,881,161,953]]},";":{"xoff":576,"width":384,"height":1344,"hbx":64,"hby":1088,"path":[["m",358,256],["l",373,233],["q",347,131,298,-4],["q",249,-140,196,-256],["l",71,-256],["q",98,-150,130,6],["q",163,162,176,256],["l",358,256],["m",155,953],["q",155,1088,274,1088],["q",397,1088,397,953],["q",397,888,364,853],["q",331,818,274,818],["q",216,818,185,853],["q",155,888,155,953]]},"<":{"xoff":1152,"width":1024,"height":960,"hbx":64,"hby":1216,"path":[["m",1048,256],["l",102,662],["l",102,756],["l",1048,1216],["l",1048,1073],["l",278,716],["l",1048,401],["l",1048,256]]},"=":{"xoff":1152,"width":1024,"height":576,"hbx":64,"hby":1024,"path":[["m",117,887],["l",117,1024],["l",1032,1024],["l",1032,887],["l",117,887],["m",117,448],["l",117,585],["l",1032,585],["l",1032,448],["l",117,448]]},">":{"xoff":1152,"width":1024,"height":960,"hbx":64,"hby":1216,"path":[["m",102,401],["l",873,714],["l",102,1073],["l",102,1216],["l",1048,756],["l",1048,662],["l",102,256],["l",102,401]]},"?":{"xoff":896,"width":896,"height":1472,"hbx":0,"hby":1472,"path":[["m",295,448],["l",295,499],["q",295,609,332,680],["q",369,751,470,830],["q",609,938,645,992],["q",682,1047,682,1124],["q",682,1220,615,1272],["q",548,1324,422,1324],["q",341,1324,264,1305],["q",188,1287,88,1238],["l",28,1373],["q",221,1472,430,1472],["q",625,1472,733,1383],["q",841,1294,841,1132],["q",841,1062,821,1009],["q",801,957,762,910],["q",723,863,594,759],["q",491,677,457,623],["q",424,569,424,479],["l",424,448],["l",295,448],["m",245,135],["q",245,271,365,271],["q",423,271,454,236],["q",486,201,486,135],["q",486,71,454,35],["q",422,0,365,0],["q",313,0,279,31],["q",245,63,245,135]]},"@":{"xoff":1856,"width":1728,"height":1664,"hbx":64,"hby":1472,"path":[["m",1734,717],["q",1734,570,1689,448],["q",1645,326,1564,259],["q",1484,192,1380,192],["q",1293,192,1233,247],["q",1174,303,1163,389],["l",1155,389],["q",1115,296,1039,244],["q",964,192,861,192],["q",710,192,624,301],["q",539,411,539,598],["q",539,816,658,952],["q",777,1088,970,1088],["q",1039,1088,1125,1074],["q",1212,1061,1282,1037],["l",1257,531],["l",1257,507],["q",1257,315,1391,315],["q",1484,315,1541,427],["q",1599,539,1599,718],["q",1599,907,1524,1048],["q",1450,1190,1312,1266],["q",1174,1343,995,1343],["q",770,1343,603,1249],["q",437,1156,349,982],["q",261,808,261,580],["q",261,271,423,105],["q",586,-61,892,-61],["q",1104,-61,1332,25],["l",1332,-108],["q",1138,-192,892,-192],["q",526,-192,324,9],["q",122,211,122,573],["q",122,836,230,1041],["q",338,1247,537,1359],["q",737,1472,995,1472],["q",1212,1472,1381,1378],["q",1550,1285,1642,1113],["q",1734,941,1734,717],["m",690,593],["q",690,315,888,315],["q",1098,315,1116,658],["l",1130,943],["q",1057,965,971,965],["q",839,965,764,866],["q",690,768,690,593]]},"A":{"xoff":1280,"width":1280,"height":1472,"hbx":0,"hby":1472,"path":[["m",1104,0],["l",925,487],["l",349,487],["l",172,0],["l",0,0],["l",571,1472],["l",712,1472],["l",1280,0],["l",1104,0],["m",873,640],["l",706,1083],["q",673,1168,639,1290],["q",617,1196,577,1083],["l",408,640],["l",873,640]]},"B":{"xoff":1344,"width":1088,"height":1472,"hbx":192,"hby":1472,"path":[["m",204,1472],["l",622,1472],["q",917,1472,1048,1383],["q",1180,1294,1180,1103],["q",1180,970,1106,884],["q",1033,798,892,772],["l",892,762],["q",1230,705,1230,414],["q",1230,219,1096,109],["q",962,0,721,0],["l",204,0],["l",204,1472],["m",374,832],["l",659,832],["q",843,832,923,890],["q",1004,948,1004,1086],["q",1004,1213,914,1269],["q",825,1325,629,1325],["l",374,1325],["l",374,832],["m",374,688],["l",374,145],["l",685,145],["q",865,145,956,213],["q",1048,281,1048,426],["q",1048,561,954,624],["q",861,688,671,688],["l",374,688]]},"C":{"xoff":1280,"width":1216,"height":1472,"hbx":64,"hby":1472,"path":[["m",820,1320],["q",582,1320,444,1163],["q",306,1007,306,736],["q",306,456,439,303],["q",572,151,818,151],["q",969,151,1163,206],["l",1163,57],["q",1012,0,792,0],["q",472,0,298,192],["q",124,384,124,737],["q",124,959,207,1125],["q",291,1292,449,1382],["q",608,1472,822,1472],["q",1050,1472,1220,1388],["l",1149,1242],["q",985,1320,820,1320]]},"D":{"xoff":1472,"width":1216,"height":1472,"hbx":192,"hby":1472,"path":[["m",1349,750],["q",1349,386,1155,193],["q",961,0,597,0],["l",198,0],["l",198,1472],["l",640,1472],["q",976,1472,1162,1281],["q",1349,1091,1349,750],["m",1169,744],["q",1169,1033,1028,1179],["q",888,1325,610,1325],["l",368,1325],["l",368,147],["l",571,147],["q",869,147,1019,298],["q",1169,449,1169,744]]},"E":{"xoff":1152,"width":896,"height":1472,"hbx":192,"hby":1472,"path":[["m",1028,0],["l",203,0],["l",203,1472],["l",1028,1472],["l",1028,1321],["l",373,1321],["l",373,832],["l",988,832],["l",988,682],["l",373,682],["l",373,152],["l",1028,152],["l",1028,0]]},"F":{"xoff":1088,"width":896,"height":1472,"hbx":192,"hby":1472,"path":[["m",377,0],["l",207,0],["l",207,1472],["l",1046,1472],["l",1046,1321],["l",377,1321],["l",377,768],["l",1006,768],["l",1006,617],["l",377,617],["l",377,0]]},"G":{"xoff":1472,"width":1280,"height":1472,"hbx":64,"hby":1472,"path":[["m",833,768],["l",1324,768],["l",1324,73],["q",1209,37,1090,18],["q",972,0,816,0],["q",488,0,305,193],["q",123,387,123,736],["q",123,959,213,1127],["q",304,1295,473,1383],["q",643,1472,871,1472],["q",1103,1472,1302,1386],["l",1237,1236],["q",1042,1320,862,1320],["q",599,1320,451,1165],["q",303,1010,303,735],["q",303,447,445,298],["q",587,149,862,149],["q",1012,149,1154,183],["l",1154,616],["l",833,616],["l",833,768]]},"H":{"xoff":1536,"width":1152,"height":1472,"hbx":192,"hby":1472,"path":[["m",1333,0],["l",1163,0],["l",1163,680],["l",374,680],["l",374,0],["l",204,0],["l",204,1472],["l",374,1472],["l",374,832],["l",1163,832],["l",1163,1472],["l",1333,1472],["l",1333,0]]},"I":{"xoff":576,"width":192,"height":1472,"hbx":192,"hby":1472,"path":[["m",203,0],["l",203,1472],["l",373,1472],["l",373,0],["l",203,0]]},"J":{"xoff":576,"width":576,"height":1856,"hbx":-192,"hby":1472,"path":[["m",-2,-384],["q",-96,-384,-150,-357],["l",-150,-212],["q",-79,-232,-2,-232],["q",97,-232,148,-171],["q",200,-111,200,2],["l",200,1472],["l",370,1472],["l",370,17],["q",370,-174,274,-279],["q",178,-384,-2,-384]]},"K":{"xoff":1280,"width":1088,"height":1472,"hbx":192,"hby":1472,"path":[["m",1280,0],["l",1076,0],["l",534,714],["l",375,577],["l",375,0],["l",205,0],["l",205,1472],["l",375,1472],["l",375,742],["l",1053,1472],["l",1258,1472],["l",659,833],["l",1280,0]]},"L":{"xoff":1088,"width":896,"height":1472,"hbx":192,"hby":1472,"path":[["m",206,0],["l",206,1472],["l",376,1472],["l",376,154],["l",1040,154],["l",1040,0],["l",206,0]]},"M":{"xoff":1856,"width":1472,"height":1472,"hbx":192,"hby":1472,"path":[["m",851,0],["l",353,1305],["l",345,1305],["q",359,1150,359,936],["l",359,0],["l",202,0],["l",202,1472],["l",458,1472],["l",923,258],["l",932,258],["l",1401,1472],["l",1655,1472],["l",1655,0],["l",1485,0],["l",1485,949],["q",1485,1112,1499,1303],["l",1491,1303],["l",989,0],["l",851,0]]},"N":{"xoff":1536,"width":1152,"height":1472,"hbx":192,"hby":1472,"path":[["m",1336,0],["l",1142,0],["l",349,1235],["l",341,1235],["q",357,1018,357,836],["l",357,0],["l",200,0],["l",200,1472],["l",392,1472],["l",1183,242],["l",1191,242],["q",1189,269,1182,416],["q",1175,564,1177,628],["l",1177,1472],["l",1336,1472],["l",1336,0]]},"O":{"xoff":1600,"width":1472,"height":1472,"hbx":64,"hby":1472,"path":[["m",1475,736],["q",1475,393,1297,196],["q",1119,0,802,0],["q",477,0,301,193],["q",125,386,125,738],["q",125,1088,301,1280],["q",478,1472,804,1472],["q",1120,1472,1297,1276],["q",1475,1081,1475,736],["m",305,736],["q",305,448,432,298],["q",559,149,802,149],["q",1046,149,1170,298],["q",1295,447,1295,736],["q",1295,1023,1171,1171],["q",1047,1320,804,1320],["q",559,1320,432,1170],["q",305,1021,305,736]]},"P":{"xoff":1216,"width":960,"height":1472,"hbx":192,"hby":1472,"path":[["m",1112,1033],["q",1112,804,963,681],["q",814,558,537,558],["l",368,558],["l",368,0],["l",198,0],["l",198,1472],["l",572,1472],["q",1112,1472,1112,1033],["m",368,704],["l",518,704],["q",739,704,837,780],["q",936,857,936,1025],["q",936,1177,843,1251],["q",750,1325,554,1325],["l",368,1325],["l",368,704]]},"Q":{"xoff":1600,"width":1472,"height":1792,"hbx":64,"hby":1472,"path":[["m",1475,736],["q",1475,461,1361,279],["q",1248,98,1041,33],["l",1390,-320],["l",1142,-320],["l",856,2],["l",801,0],["q",477,0,301,193],["q",125,386,125,738],["q",125,1088,301,1280],["q",478,1472,804,1472],["q",1120,1472,1297,1276],["q",1475,1081,1475,736],["m",305,736],["q",305,448,432,298],["q",559,149,802,149],["q",1046,149,1170,298],["q",1295,447,1295,736],["q",1295,1023,1171,1171],["q",1047,1320,804,1320],["q",559,1320,432,1170],["q",305,1021,305,736]]},"R":{"xoff":1280,"width":1088,"height":1472,"hbx":192,"hby":1472,"path":[["m",373,622],["l",373,0],["l",203,0],["l",203,1472],["l",608,1472],["q",880,1472,1010,1369],["q",1140,1267,1140,1061],["q",1140,772,843,671],["l",1245,0],["l",1044,0],["l",685,622],["l",373,622],["m",373,768],["l",610,768],["q",793,768,878,839],["q",964,910,964,1052],["q",964,1196,877,1259],["q",790,1323,598,1323],["l",373,1323],["l",373,768]]},"S":{"xoff":1152,"width":1024,"height":1472,"hbx":64,"hby":1472,"path":[["m",1052,401],["q",1052,212,908,106],["q",765,0,519,0],["q",252,0,109,67],["l",109,231],["q",202,193,311,171],["q",420,149,527,149],["q",703,149,791,211],["q",880,274,880,385],["q",880,459,848,506],["q",817,554,743,594],["q",670,635,519,686],["q",309,757,218,855],["q",128,953,128,1111],["q",128,1276,258,1374],["q",388,1472,603,1472],["q",826,1472,1014,1392],["l",959,1244],["q",773,1320,596,1320],["q",457,1320,378,1264],["q",300,1208,300,1109],["q",300,1035,329,987],["q",358,940,426,900],["q",495,860,636,812],["q",874,732,963,640],["q",1052,548,1052,401]]},"T":{"xoff":1152,"width":1152,"height":1472,"hbx":0,"hby":1472,"path":[["m",659,0],["l",489,0],["l",489,1321],["l",18,1321],["l",18,1472],["l",1133,1472],["l",1133,1321],["l",659,1321],["l",659,0]]},"U":{"xoff":1472,"width":1216,"height":1472,"hbx":128,"hby":1472,"path":[["m",1288,1472],["l",1288,532],["q",1288,284,1139,142],["q",990,0,730,0],["q",469,0,326,143],["q",184,286,184,536],["l",184,1472],["l",354,1472],["l",354,525],["q",354,344,452,246],["q",550,149,740,149],["q",922,149,1020,247],["q",1118,345,1118,527],["l",1118,1472],["l",1288,1472]]},"V":{"xoff":1216,"width":1216,"height":1472,"hbx":0,"hby":1472,"path":[["m",1033,1472],["l",1216,1472],["l",690,0],["l",523,0],["l",0,1472],["l",180,1472],["l",515,519],["q",573,355,607,200],["q",642,363,700,525],["l",1033,1472]]},"W":{"xoff":1920,"width":1920,"height":1472,"hbx":0,"hby":1472,"path":[["m",1496,0],["l",1326,0],["l",1027,986],["q",1006,1051,979,1151],["q",953,1251,952,1271],["q",930,1138,881,980],["l",591,0],["l",421,0],["l",27,1472],["l",209,1472],["l",443,562],["q",492,371,514,216],["q",542,400,595,577],["l",861,1472],["l",1043,1472],["l",1322,569],["q",1370,412,1404,216],["q",1423,359,1477,564],["l",1710,1472],["l",1892,1472],["l",1496,0]]},"X":{"xoff":1152,"width":1152,"height":1472,"hbx":0,"hby":1472,"path":[["m",1144,0],["l",956,0],["l",573,647],["l",183,0],["l",8,0],["l",481,769],["l",40,1472],["l",223,1472],["l",577,889],["l",934,1472],["l",1110,1472],["l",669,775],["l",1144,0]]},"Y":{"xoff":1152,"width":1152,"height":1472,"hbx":0,"hby":1472,"path":[["m",576,736],["l",967,1472],["l",1152,1472],["l",661,571],["l",661,0],["l",489,0],["l",489,563],["l",0,1472],["l",187,1472],["l",576,736]]},"Z":{"xoff":1152,"width":1024,"height":1472,"hbx":64,"hby":1472,"path":[["m",1071,0],["l",81,0],["l",81,134],["l",843,1319],["l",104,1319],["l",104,1472],["l",1050,1472],["l",1050,1338],["l",288,154],["l",1071,154],["l",1071,0]]},"[":{"xoff":704,"width":576,"height":1792,"hbx":128,"hby":1472,"path":[["m",651,-320],["l",173,-320],["l",173,1472],["l",651,1472],["l",651,1331],["l",341,1331],["l",341,-178],["l",651,-178],["l",651,-320]]},"\\":{"xoff":768,"width":768,"height":1472,"hbx":0,"hby":1472,"path":[["m",190,1472],["l",749,0],["l",579,0],["l",23,1472],["l",190,1472]]},"]":{"xoff":704,"width":576,"height":1792,"hbx":0,"hby":1472,"path":[["m",53,-178],["l",363,-178],["l",363,1331],["l",53,1331],["l",53,1472],["l",531,1472],["l",531,-320],["l",53,-320],["l",53,-178]]},"^":{"xoff":1088,"width":1088,"height":896,"hbx":0,"hby":1472,"path":[["m",48,576],["l",473,1472],["l",570,1472],["l",1038,576],["l",889,576],["l",524,1300],["l",197,576],["l",48,576]]},"_":{"xoff":896,"width":1024,"height":192,"hbx":-64,"hby":-192,"path":[["m",900,-323],["l",-4,-323],["l",-4,-192],["l",900,-192],["l",900,-323]]},"`":{"xoff":1152,"width":448,"height":320,"hbx":320,"hby":1536,"path":[["m",766,1216],["l",659,1216],["q",595,1267,508,1360],["q",422,1454,383,1516],["l",383,1536],["l",581,1536],["q",612,1469,667,1380],["q",723,1292,766,1240],["l",766,1216]]},"a":{"xoff":1152,"width":960,"height":1088,"hbx":64,"hby":1088,"path":[["m",860,0],["l",826,152],["l",818,152],["q",735,63,652,31],["q",570,0,447,0],["q",282,0,188,79],["q",95,159,95,305],["q",95,619,633,634],["l",822,640],["l",822,706],["q",822,831,765,891],["q",709,951,585,951],["q",446,951,271,867],["l",219,994],["q",301,1038,398,1063],["q",496,1088,594,1088],["q",793,1088,888,1003],["q",984,918,984,731],["l",984,0],["l",860,0],["m",480,137],["q",638,137,728,214],["q",818,292,818,432],["l",818,522],["l",649,516],["q",447,509,358,459],["q",269,410,269,305],["q",269,223,324,180],["q",380,137,480,137]]},"b":{"xoff":1280,"width":1088,"height":1536,"hbx":128,"hby":1536,"path":[["m",698,1088],["q",919,1088,1041,946],["q",1164,805,1164,546],["q",1164,287,1040,143],["q",917,0,698,0],["q",589,0,498,38],["q",408,76,346,154],["l",334,154],["l",299,0],["l",180,0],["l",180,1536],["l",346,1536],["l",346,1159],["q",346,1032,338,931],["l",346,931],["q",465,1088,698,1088],["m",676,949],["q",501,949,423,856],["q",346,764,346,546],["q",346,327,425,233],["q",505,139,680,139],["q",837,139,914,244],["q",992,350,992,548],["q",992,750,914,849],["q",837,949,676,949]]},"c":{"xoff":960,"width":832,"height":1088,"hbx":64,"hby":1088,"path":[["m",604,0],["q",370,0,241,140],["q",113,281,113,537],["q",113,801,243,944],["q",374,1088,615,1088],["q",693,1088,771,1071],["q",849,1054,893,1031],["l",843,890],["q",789,912,725,926],["q",662,941,613,941],["q",285,941,285,539],["q",285,349,365,247],["q",445,145,602,145],["q",736,145,877,204],["l",877,57],["q",769,0,604,0]]},"d":{"xoff":1280,"width":1088,"height":1536,"hbx":64,"hby":1536,"path":[["m",943,160],["l",934,160],["q",816,0,582,0],["q",362,0,239,141],["q",117,282,117,541],["q",117,801,240,944],["q",363,1088,582,1088],["q",810,1088,932,933],["l",945,933],["l",938,1012],["l",934,1089],["l",934,1536],["l",1100,1536],["l",1100,0],["l",965,0],["l",943,160],["m",601,139],["q",776,139,855,226],["q",934,314,934,508],["l",934,541],["q",934,761,854,855],["q",774,949,599,949],["q",449,949,369,842],["q",289,735,289,539],["q",289,341,368,240],["q",448,139,601,139]]},"e":{"xoff":1152,"width":1024,"height":1088,"hbx":64,"hby":1088,"path":[["m",641,0],["q",397,0,256,141],["q",115,283,115,535],["q",115,789,246,938],["q",377,1088,598,1088],["q",804,1088,924,956],["q",1045,824,1045,607],["l",1045,505],["l",287,505],["q",292,328,385,236],["q",478,145,647,145],["q",824,145,998,219],["l",998,71],["q",910,33,831,16],["q",752,0,641,0],["m",596,949],["q",463,949,384,867],["q",305,785,291,640],["l",867,640],["q",867,790,796,869],["q",726,949,596,949]]},"f":{"xoff":704,"width":832,"height":1536,"hbx":0,"hby":1536,"path":[["m",673,953],["l",394,953],["l",394,0],["l",228,0],["l",228,953],["l",29,953],["l",29,1028],["l",228,1088],["l",228,1147],["q",228,1536,581,1536],["q",668,1536,785,1501],["l",742,1368],["q",646,1399,578,1399],["q",484,1399,439,1339],["q",394,1280,394,1149],["l",394,1082],["l",673,1082],["l",673,953]]},"g":{"xoff":1152,"width":1152,"height":1600,"hbx":0,"hby":1088,"path":[["m",1102,1088],["l",1102,983],["l",893,959],["q",922,924,944,867],["q",967,810,967,739],["q",967,577,853,480],["q",740,384,541,384],["q",491,384,446,392],["q",337,327,337,229],["q",337,178,375,153],["q",413,128,506,128],["l",706,128],["q",890,128,988,56],["q",1087,-16,1087,-154],["q",1087,-328,937,-420],["q",787,-512,500,-512],["q",279,-512,159,-435],["q",40,-359,40,-220],["q",40,-124,106,-54],["q",172,15,291,40],["q",248,61,218,105],["q",189,149,189,207],["q",189,274,221,323],["q",254,373,325,419],["q",238,453,183,535],["q",128,617,128,722],["q",128,898,239,993],["q",350,1088,554,1088],["q",642,1088,713,1088],["l",1102,1088],["m",200,-216],["q",200,-299,278,-342],["q",356,-385,501,-385],["q",718,-385,822,-326],["q",927,-268,927,-168],["q",927,-85,870,-53],["q",813,-21,655,-21],["l",448,-21],["q",331,-21,265,-71],["q",200,-122,200,-216],["m",292,726],["q",292,615,360,558],["q",428,501,549,501],["q",803,501,803,729],["q",803,967,546,967],["q",424,967,358,906],["q",292,845,292,726]]},"h":{"xoff":1280,"width":1024,"height":1536,"hbx":128,"hby":1536,"path":[["m",946,0],["l",946,690],["q",946,821,883,885],["q",820,949,687,949],["q",509,949,427,857],["q",345,766,345,558],["l",345,0],["l",179,0],["l",179,1536],["l",345,1536],["l",345,1063],["q",345,978,337,922],["l",347,922],["q",397,999,489,1043],["q",582,1088,701,1088],["q",906,1088,1009,994],["q",1112,901,1112,698],["l",1112,0],["l",946,0]]},"i":{"xoff":512,"width":256,"height":1536,"hbx":128,"hby":1536,"path":[["m",340,0],["l",174,0],["l",174,1088],["l",340,1088],["l",340,0],["m",160,1391],["q",160,1448,188,1474],["q",216,1501,258,1501],["q",298,1501,327,1474],["q",356,1447,356,1391],["q",356,1335,327,1307],["q",298,1280,258,1280],["q",216,1280,188,1307],["q",160,1335,160,1391]]},"j":{"xoff":512,"width":512,"height":2048,"hbx":-128,"hby":1536,"path":[["m",41,-512],["q",-54,-512,-113,-487],["l",-113,-352],["q",-44,-372,23,-372],["q",101,-372,137,-329],["q",174,-286,174,-199],["l",174,1088],["l",340,1088],["l",340,-186],["q",340,-512,41,-512],["m",160,1391],["q",160,1448,188,1474],["q",216,1501,258,1501],["q",298,1501,327,1474],["q",356,1447,356,1391],["q",356,1335,327,1307],["q",298,1280,258,1280],["q",216,1280,188,1307],["q",160,1335,160,1391]]},"k":{"xoff":1088,"width":960,"height":1536,"hbx":128,"hby":1536,"path":[["m",342,555],["q",386,616,475,714],["l",834,1088],["l",1034,1088],["l",585,624],["l",1066,0],["l",863,0],["l",471,512],["l",342,405],["l",342,0],["l",178,0],["l",178,1536],["l",342,1536],["l",342,723],["q",342,668,334,555],["l",342,555]]},"l":{"xoff":512,"width":256,"height":1536,"hbx":128,"hby":1536,"path":[["m",340,0],["l",174,0],["l",174,1536],["l",340,1536],["l",340,0]]},"m":{"xoff":1920,"width":1664,"height":1088,"hbx":128,"hby":1088,"path":[["m",1587,0],["l",1587,693],["q",1587,820,1530,883],["q",1474,947,1354,947],["q",1197,947,1122,860],["q",1047,774,1047,594],["l",1047,0],["l",881,0],["l",881,693],["q",881,820,824,883],["q",768,947,647,947],["q",490,947,416,856],["q",343,765,343,558],["l",343,0],["l",177,0],["l",177,1088],["l",312,1088],["l",339,896],["l",347,896],["q",395,986,481,1037],["q",567,1088,674,1088],["q",933,1088,1013,880],["l",1021,880],["q",1071,976,1164,1032],["q",1258,1088,1379,1088],["q",1566,1088,1659,995],["q",1753,902,1753,697],["l",1753,0],["l",1587,0]]},"n":{"xoff":1280,"width":1024,"height":1088,"hbx":128,"hby":1088,"path":[["m",946,0],["l",946,689],["q",946,819,883,883],["q",820,947,687,947],["q",510,947,427,856],["q",345,766,345,558],["l",345,0],["l",179,0],["l",179,1088],["l",314,1088],["l",341,922],["l",349,922],["q",401,1001,495,1044],["q",589,1088,705,1088],["q",907,1088,1009,995],["q",1112,902,1112,697],["l",1112,0],["l",946,0]]},"o":{"xoff":1216,"width":1088,"height":1088,"hbx":64,"hby":1088,"path":[["m",1103,545],["q",1103,288,970,144],["q",838,0,604,0],["q",459,0,347,66],["q",235,132,174,255],["q",113,379,113,545],["q",113,802,244,945],["q",376,1088,610,1088],["q",837,1088,970,941],["q",1103,795,1103,545],["m",285,545],["q",285,347,367,243],["q",449,139,608,139],["q",766,139,848,242],["q",931,346,931,545],["q",931,742,848,844],["q",766,947,606,947],["q",447,947,366,846],["q",285,745,285,545]]},"p":{"xoff":1280,"width":1088,"height":1600,"hbx":128,"hby":1088,"path":[["m",698,0],["q",589,0,498,38],["q",408,76,346,154],["l",334,154],["q",346,53,346,-37],["l",346,-512],["l",180,-512],["l",180,1088],["l",315,1088],["l",338,925],["l",346,925],["q",412,1011,499,1049],["q",586,1088,698,1088],["q",921,1088,1042,945],["q",1164,803,1164,545],["q",1164,286,1040,143],["q",917,0,698,0],["m",676,947],["q",503,947,425,859],["q",348,771,346,580],["l",346,545],["q",346,327,425,233],["q",505,139,680,139],["q",826,139,909,247],["q",992,356,992,547],["q",992,740,909,843],["q",826,947,676,947]]},"q":{"xoff":1280,"width":1088,"height":1600,"hbx":64,"hby":1088,"path":[["m",601,139],["q",772,139,850,223],["q",929,307,934,506],["l",934,541],["q",934,758,853,853],["q",773,949,599,949],["q",449,949,369,842],["q",289,735,289,539],["q",289,344,368,241],["q",447,139,601,139],["m",578,0],["q",361,0,239,142],["q",117,285,117,541],["q",117,799,240,943],["q",363,1088,582,1088],["q",812,1088,936,925],["l",945,925],["l",969,1088],["l",1100,1088],["l",1100,-512],["l",934,-512],["l",934,-19],["q",934,86,945,160],["l",932,160],["q",814,0,578,0]]},"r":{"xoff":832,"width":704,"height":1088,"hbx":128,"hby":1088,"path":[["m",673,1088],["q",745,1088,803,1076],["l",780,922],["q",713,937,661,937],["q",529,937,435,832],["q",341,727,341,571],["l",341,0],["l",175,0],["l",175,1088],["l",312,1088],["l",331,871],["l",339,871],["q",400,975,485,1031],["q",570,1088,673,1088]]},"s":{"xoff":960,"width":832,"height":1088,"hbx":64,"hby":1088,"path":[["m",868,306],["q",868,159,756,79],["q",644,0,441,0],["q",227,0,107,59],["l",107,192],["q",184,166,272,151],["q",361,137,444,137],["q",571,137,639,175],["q",708,214,708,292],["q",708,353,653,396],["q",599,440,442,500],["q",292,554,229,595],["q",166,636,135,687],["q",104,739,104,811],["q",104,940,211,1014],["q",318,1088,505,1088],["q",679,1088,845,1016],["l",787,881],["q",626,949,495,949],["q",379,949,320,915],["q",262,881,262,822],["q",262,780,284,750],["q",306,720,355,693],["q",404,667,543,616],["q",734,548,801,479],["q",868,410,868,306]]},"t":{"xoff":704,"width":704,"height":1344,"hbx":0,"hby":1344,"path":[["m",518,137],["q",560,137,599,143],["q",639,150,662,157],["l",662,30],["q",636,17,584,8],["q",533,0,493,0],["q",183,0,183,325],["l",183,959],["l",30,959],["l",30,1039],["l",185,1109],["l",254,1344],["l",349,1344],["l",349,1088],["l",654,1088],["l",654,959],["l",349,959],["l",349,335],["q",349,240,394,188],["q",439,137,518,137]]},"u":{"xoff":1280,"width":1024,"height":1088,"hbx":128,"hby":1088,"path":[["m",335,1088],["l",335,397],["q",335,267,398,203],["q",461,139,594,139],["q",771,139,853,230],["q",935,322,935,529],["l",935,1088],["l",1101,1088],["l",1101,0],["l",964,0],["l",940,163],["l",931,163],["q",879,84,786,42],["q",694,0,575,0],["q",370,0,268,92],["q",167,185,167,389],["l",167,1088],["l",335,1088]]},"v":{"xoff":1024,"width":1024,"height":1088,"hbx":0,"hby":1088,"path":[["m",415,0],["l",0,1088],["l",178,1088],["l",413,443],["q",493,216,507,149],["l",515,149],["q",526,202,584,367],["q",643,532,846,1088],["l",1024,1088],["l",609,0],["l",415,0]]},"w":{"xoff":1600,"width":1600,"height":1088,"hbx":0,"hby":1088,"path":[["m",1076,0],["l",874,638],["q",855,697,803,904],["l",794,904],["q",754,730,724,636],["l",516,0],["l",323,0],["l",23,1088],["l",198,1088],["q",304,678,360,463],["q",416,249,424,175],["l",432,175],["q",443,232,467,321],["q",492,411,510,464],["l",712,1088],["l",893,1088],["l",1090,464],["q",1146,293,1166,177],["l",1174,177],["q",1178,213,1195,287],["q",1213,362,1405,1088],["l",1578,1088],["l",1274,0],["l",1076,0]]},"x":{"xoff":1088,"width":1088,"height":1088,"hbx":0,"hby":1088,"path":[["m",446,557],["l",60,1088],["l",252,1088],["l",545,671],["l",836,1088],["l",1026,1088],["l",640,557],["l",1046,0],["l",855,0],["l",544,441],["l",233,0],["l",45,0],["l",446,557]]},"y":{"xoff":1024,"width":1024,"height":1600,"hbx":0,"hby":1088,"path":[["m",2,1088],["l",179,1088],["l",417,458],["q",495,243,514,147],["l",522,147],["q",535,198,576,322],["q",617,447,845,1088],["l",1022,1088],["l",555,-169],["q",485,-356,392,-434],["q",300,-512,165,-512],["q",89,-512,16,-495],["l",16,-362],["q",71,-374,139,-374],["q",310,-374,383,-180],["l",444,-23],["l",2,1088]]},"z":{"xoff":960,"width":832,"height":1088,"hbx":64,"hby":1088,"path":[["m",879,0],["l",82,0],["l",82,112],["l",682,959],["l",119,959],["l",119,1088],["l",864,1088],["l",864,960],["l",272,129],["l",879,129],["l",879,0]]},"{":{"xoff":768,"width":704,"height":1792,"hbx":0,"hby":1472,"path":[["m",472,17],["q",472,-85,529,-131],["q",587,-178,698,-180],["l",698,-320],["q",510,-318,407,-232],["q",304,-147,304,7],["l",304,311],["q",304,415,241,460],["q",179,505,60,505],["l",60,646],["q",189,648,246,694],["q",304,741,304,837],["l",304,1144],["q",304,1299,411,1385],["q",518,1472,698,1472],["l",698,1333],["q",472,1327,472,1133],["l",472,837],["q",472,621,251,582],["l",251,570],["q",472,531,472,315],["l",472,17]]},"|":{"xoff":1152,"width":256,"height":2048,"hbx":448,"hby":1536,"path":[["m",505,1536],["l",646,1536],["l",646,-512],["l",505,-512],["l",505,1536]]},"}":{"xoff":768,"width":704,"height":1792,"hbx":64,"hby":1472,"path":[["m",515,582],["q",296,621,296,837],["l",296,1133],["q",296,1327,71,1333],["l",71,1472],["q",254,1472,359,1384],["q",464,1297,464,1144],["l",464,837],["q",464,740,522,694],["q",580,648,708,646],["l",708,505],["q",588,505,526,460],["q",464,415,464,311],["l",464,7],["q",464,-146,362,-232],["q",260,-318,71,-320],["l",71,-180],["q",181,-178,238,-131],["q",296,-85,296,17],["l",296,315],["q",296,430,350,490],["q",404,550,515,570],["l",515,582]]},"~":{"xoff":1152,"width":1024,"height":256,"hbx":64,"hby":832,"path":[["m",332,693],["q",280,693,217,660],["q",155,628,102,576],["l",102,725],["q",200,832,342,832],["q",409,832,464,818],["q",520,805,608,768],["q",673,741,721,728],["q",769,715,816,715],["q",869,715,932,746],["q",995,777,1048,832],["l",1048,684],["q",948,576,808,576],["q",737,576,675,592],["q",613,608,542,639],["q",468,670,424,681],["q",380,693,332,693]]}},"exporter":"SimpleJson","version":"0.0.3"};

	var fontpathUtil = {};

	// module.exports.pointsToPixels = function(pointSize, resolution) {
	// 	resolution = typeof resolution === "number" ? resolution : 72;
	// 	return pointSize * resolution / 72;
	// };

	// module.exports.coordToPixel = function(coord, pixelSize, emSize) {
	// 	emSize = typeof emSize === "number" ? emSize : 2048;
	// 	return coord * pixelSize / emSize;
	// };

	/**
	 * Converts a pt size to px size, namely useful for matching
	 * size with CSS styles. If no DPI is specified, 96 is assumed
	 * (as it leads to correct rendering in all browsers).
	 * 
	 * @param  {Number} fontSize the desired font size in points
	 * @param  {Number} dpi      the expected DPI, generally 96 for browsers
	 * @return {Number}          the rounded pixel font size
	 */
	fontpathUtil.pointToPixel = function(fontSize, dpi) {
	    dpi = dpi||dpi===0 ? dpi : 96;
	    fontSize = fontSize * dpi / 72;
	    return Math.round(fontSize);
	};

	/**
	 * For the given font and (pixel) font size, this method returns the
	 * scale that will need to be applied to EM units (i.e. font paths) 
	 * to have the font render at the expected size (i.e. to match the browser).
	 *
	 * If no font size is specified, we will use the default font size (which is in points)
	 * and convert it to pixels. 
	 * 
	 * @param  {Font} font     a font object from the fontpath tool
	 * @param  {Number} fontSize the desired font size, defaults to the font's default size
	 * @return {Number} returns the scale for this font size         
	 */
	fontpathUtil.getPxScale = function(font, fontSize) {
	    if (font.bitmap)
	        return 1.0;

	    //If no fontSize is specified, it will just fall back to using the font's own size with 96 DPI.
	    fontSize = typeof fontSize === "number" ? fontSize : this.pointToPixel(font.size);

	    //Takes in a font size in PIXELS and gives us the expected scaling factor
	    var sz = font.units_per_EM/64;
	    sz = (sz/font.size * fontSize);

	    return ((font.resolution * 1/72 * sz) / font.units_per_EM);
	};

	/**
	 * For the given font and (point) font size, this method returns the
	 * scale that will need to be applied to EM units (i.e. font paths) 
	 * to have the font render at the expected size (i.e. to match the browser).
	 * 
	 * If no font size is specified, we will use the default font size.
	 * 
	 * @param  {Font} font       a font object from the fontpath tool
	 * @param  {Number} fontSize the desired font size, defaults to the font's default size
	 * @return {Number}          the scale for this font size
	 */
	fontpathUtil.getPtScale = function(font, fontSize) {
	    fontSize = typeof fontSize === "number" ? fontSize : font.size;
	    fontSize = this.pointToPixel(fontSize);
	    return this.getPxScale(font, fontSize);
	};

	var util$1 = fontpathUtil;

	var DEFAULT_TAB_WIDTH = 4;

	function GlyphIterator$1(font, fontSize) {
	    this._fontSize = undefined;
	    this._fontScale = undefined;
	    this._font = undefined;
	    this.fontScale = 1.0;
	    this.kerning = true;
	    this.letterSpacing = 0;
	    this.lineHeight = undefined;
	    
	    this.fontSize = typeof fontSize === 'number'
	            ? fontSize
	            : (font ? font.size : undefined);
	    this.font = font;

	    //Number of spaces for a tab character
	    this.tabWidth = DEFAULT_TAB_WIDTH;
	    this._tabGlyph = null;

	    this.origin = { x: 0, y: 0 };
	    this.pen = { x: 0, y: 0 };
	}

	Object.defineProperty(GlyphIterator$1.prototype, "font", {
	    get: function() {
	        return this._font;
	    },

	    set: function(font) {
	        this._font = font;

	        //Determine the new scaling factor...
	        if (font) {
	            this.fontScale = util$1.getPxScale(font, this.fontSize);

	            //Updates the tab glyph
	            this.tabWidth = this._tabWidth;
	        }
	    },
	});

	//There might be a better way of handling tab width using FreeType ? 
	Object.defineProperty(GlyphIterator$1.prototype, "tabWidth", {

	    get: function() {
	        return this._tabWidth;
	    },

	    set: function(val) {
	        this._tabWidth = val===0 || val ? val : DEFAULT_TAB_WIDTH;
	        this._tabGlyph = {};

	        var spaceGlyph = this.font ? this.font.glyphs[" "] : null;
	        if (spaceGlyph) {
	            this._tabGlyph = {};
	            for (var k in spaceGlyph) {
	                this._tabGlyph[k] = spaceGlyph[k];
	            }
	            if (this._tabGlyph.xoff)
	                this._tabGlyph.xoff *= this._tabWidth;
	        }
	    },
	});

	Object.defineProperty(GlyphIterator$1.prototype, "fontSize", {
	    get: function() {
	        if (typeof this._fontSize !== 'number')
	            return this.font.bitmap 
	                ? this.font.size 
	                : util$1.pointToPixel(this.font.size)
	        return this._fontSize;
	    },

	    set: function(val) {
	        this._fontSize = val;

	        //If the font is already set, determine the new scaling factor
	        if (this._font) {
	            this.fontScale = util$1.getPxScale(this._font, this._fontSize);
	        }
	    },
	});

	GlyphIterator$1.prototype.getKerning = function(left, right) {
	    var font = this.font;

	    if (!font || !font.kerning)
	        return 0;

	    this.kerningTable;

	    for (var i=0; i<font.kerning.length; i++) {
	        var k = font.kerning[i];
	        if (k[0] === left && k[1] === right) 
	            return k[2];
	    }
	    return 0;
	};

	GlyphIterator$1.prototype.begin = function(x, y) {
	    this.origin.x = x||0;
	    this.origin.y = y||0;

	    this.pen.x = this.origin.x;
	    this.pen.y = this.origin.y;
	};

	GlyphIterator$1.prototype.end = function() {
	    //.. mainly for consistency with begin()
	    //Might be useful later on
	};

	GlyphIterator$1.prototype.getLineGap = function() {
	    //Line height handling is a mess in browsers.
	    //Maybe the best solution is to encourage users to 
	    //specify pixel line heights if they want to match browser standards,
	    //otherwise it's unreasonable to expect the line gaps to line up exactly
	    //across all browsers. Example of the disaster:
	    //http://lists.w3.org/Archives/Public/www-style/2008Jan/0413.html

	    //For reference, some baseline-to-baseline calculations:
	    //http://www.microsoft.com/typography/otspec/recom.htm
	    //freetype.org/freetype2/docs/reference/ft2-base_interface.html
	    //http://www.freetype.org/freetype2/docs/glyphs/glyphs-3.html

	    //Unfortunately none of these are producing line-heights that avoid overlapping
	    //or resemble browser rendering in any way. 

	    // If CSS uses 1em or 1, the browser offsets the line by the 
	    // font's pixel size. If an exact pixel line-height is specified,
	    // the browser will use that + a computed "linegap." 
	    // If 'auto' is specified for line-height, the calculations seem
	    // much more complex and browser/platform dependent (not included here).
	    
	    var font = this.font,
	        scale = this.fontScale;
	    var gap = (font.height - font.ascender + Math.abs(font.descender)) * scale;    
	    var lineHeight = this.lineHeight;
	    
	    lineHeight = (lineHeight===0||lineHeight) 
	            ? (lineHeight + gap)
	            : this.fontSize;
	    return lineHeight;
	};

	GlyphIterator$1.prototype.translate = function(x, y) {
	    this.origin.x += x||0;
	    this.origin.y += y||0;

	    this.pen.x += x||0;
	    this.pen.y += y||0;
	};

	GlyphIterator$1.prototype.step = function(text, index) {
	    var scale = this.fontScale,
	        font = this._font;

	    var chr = text.charAt(index); 

	    if (chr === '\t' && this._tabGlyph) {
	        return this._tabGlyph;
	    }

	    //Skip missing characters...
	    if (!(chr in font.glyphs))
	        return;
	    
	    var glyph = font.glyphs[chr];

	    //If we have a char to the left, determine its kerning
	    if (index > 0 && this.kerning) {
	        var kern = this.getKerning(text.charAt(index-1), chr);
	        this.pen.x += (kern*scale);
	    }

	    return glyph;
	};

	GlyphIterator$1.prototype.advanceLine = function() {
	    this.pen.y += this.getLineGap();
	    this.pen.x = this.origin.x;
	};

	/**
	 * Called after step. 
	 */
	GlyphIterator$1.prototype.advance = function(glyph) {
	    var advance = (glyph.xoff * this.fontScale);
	    // Advance to next pen position
	    this.pen.x += advance + this.letterSpacing;
	    return advance;
	};

	/**
	 * This is a utility function that provides the bounds of the given
	 * text (from start and end positions) as if they were laid out horizontally,
	 * left to right.
	 *
	 * For convenience, this will not alter the current pen and origin positions.
	 * This way it can be utilized inside a glyph iteration (i.e. for rendering).
	 *
	 * If `availableWidth` is specified, this will break before reaching the specified
	 * pixel width, to ensure that all glyphs will fit inside the bounds. 
	 *
	 * The return object also includes a `glyphs` property, which is the number of glyphs
	 * that are visible within the returned bounds. 
	 *
	 * If `out` is specified (an object with x, y, width, height, and glyph properties),
	 * it will be re-used. Otherwise a new object is created.
	 * 
	 * @param {String} text the text to check
	 * @param {Number} start the start position, defaults to 0
	 * @param {Number} end the end position, exclusive, defaults to text length
	 * @param {Number} availableWidth the width before stopping the bound check
	 * @param {Object} out an object to re-use for the return value
	 * @return {Object} the bounds and glyph count {x,y,width,height,glyphs}
	 */
	GlyphIterator$1.prototype.getBounds = function(text, start, end, availableWidth, out) {
	    if (!out)
	        out = { x:0, y:0, width: 0, height: 0, glyphs: 0 };

	    var checkWidth = availableWidth===0||availableWidth;

	    start = start||0;
	    end = end===0||end ? end : text.length;

	    var maxHeight = 0;

	    out.x = 0;
	    out.y = 0;
	    out.glyphs = 0;

	    var oldPenX = this.pen.x,
	        oldPenY = this.pen.y,
	        oldOriginX = this.origin.x,
	        oldOriginY = this.origin.y;


	    this.font;
	    this.begin();
	    for (var i=start; i<end; i++) {
	        text.charAt(i);

	        //step the iterator
	        var glyph = this.step(text, i);

	        //if the glyph is valid, we can advance past it and calculate new height
	        if (glyph) {
	            var height = (glyph.height)*this.fontScale;

	            out.y = Math.max(out.y, this.fontScale*(glyph.height-glyph.hby));

	            maxHeight = Math.max(maxHeight, height);
	            var lastAdvance = this.advance(glyph);

	            //if we're past the available width
	            var newWidth = this.pen.x - this.origin.x;
	            if (checkWidth && (newWidth - availableWidth > 0.001)) {
	                this.pen.x -= lastAdvance;
	                break;
	            }

	            out.glyphs++;
	        }
	    }
	    this.end();

	    out.width = this.pen.x - this.origin.x;
	    out.height = maxHeight;

	    this.pen.x = oldPenX;
	    this.pen.y = oldPenY;
	    this.origin.x = oldOriginX;
	    this.origin.y = oldOriginY;

	    return out;
	};

	var fontpathGlyphIterator = GlyphIterator$1;

	var wordWrapper = {exports: {}};

	(function (module) {
	var newline = /\n/;
	var newlineChar = '\n';
	var whitespace = /\s/;

	module.exports = function(text, opt) {
	    var lines = module.exports.lines(text, opt);
	    return lines.map(function(line) {
	        return text.substring(line.start, line.end)
	    }).join('\n')
	};

	module.exports.lines = function wordwrap(text, opt) {
	    opt = opt||{};

	    //zero width results in nothing visible
	    if (opt.width === 0 && opt.mode !== 'nowrap') 
	        return []

	    text = text||'';
	    var width = typeof opt.width === 'number' ? opt.width : Number.MAX_VALUE;
	    var start = Math.max(0, opt.start||0);
	    var end = typeof opt.end === 'number' ? opt.end : text.length;
	    var mode = opt.mode;

	    var measure = opt.measure || monospace;
	    if (mode === 'pre')
	        return pre(measure, text, start, end, width)
	    else
	        return greedy(measure, text, start, end, width, mode)
	};

	function idxOf(text, chr, start, end) {
	    var idx = text.indexOf(chr, start);
	    if (idx === -1 || idx > end)
	        return end
	    return idx
	}

	function isWhitespace(chr) {
	    return whitespace.test(chr)
	}

	function pre(measure, text, start, end, width) {
	    var lines = [];
	    var lineStart = start;
	    for (var i=start; i<end && i<text.length; i++) {
	        var chr = text.charAt(i);
	        var isNewline = newline.test(chr);

	        //If we've reached a newline, then step down a line
	        //Or if we've reached the EOF
	        if (isNewline || i===end-1) {
	            var lineEnd = isNewline ? i : i+1;
	            var measured = measure(text, lineStart, lineEnd, width);
	            lines.push(measured);
	            
	            lineStart = i+1;
	        }
	    }
	    return lines
	}

	function greedy(measure, text, start, end, width, mode) {
	    //A greedy word wrapper based on LibGDX algorithm
	    //https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFontCache.java
	    var lines = [];

	    var testWidth = width;
	    //if 'nowrap' is specified, we only wrap on newline chars
	    if (mode === 'nowrap')
	        testWidth = Number.MAX_VALUE;

	    while (start < end && start < text.length) {
	        //get next newline position
	        var newLine = idxOf(text, newlineChar, start, end);

	        //eat whitespace at start of line
	        while (start < newLine) {
	            if (!isWhitespace( text.charAt(start) ))
	                break
	            start++;
	        }

	        //determine visible # of glyphs for the available width
	        var measured = measure(text, start, newLine, testWidth);

	        var lineEnd = start + (measured.end-measured.start);
	        var nextStart = lineEnd + newlineChar.length;

	        //if we had to cut the line before the next newline...
	        if (lineEnd < newLine) {
	            //find char to break on
	            while (lineEnd > start) {
	                if (isWhitespace(text.charAt(lineEnd)))
	                    break
	                lineEnd--;
	            }
	            if (lineEnd === start) {
	                if (nextStart > start + newlineChar.length) nextStart--;
	                lineEnd = nextStart; // If no characters to break, show all.
	            } else {
	                nextStart = lineEnd;
	                //eat whitespace at end of line
	                while (lineEnd > start) {
	                    if (!isWhitespace(text.charAt(lineEnd - newlineChar.length)))
	                        break
	                    lineEnd--;
	                }
	            }
	        }
	        if (lineEnd >= start) {
	            var result = measure(text, start, lineEnd, testWidth);
	            lines.push(result);
	        }
	        start = nextStart;
	    }
	    return lines
	}

	//determines the visible number of glyphs within a given width
	function monospace(text, start, end, width) {
	    var glyphs = Math.min(width, end-start);
	    return {
	        start: start,
	        end: start+glyphs
	    }
	}
	}(wordWrapper));

	var tmpBounds$1 = { x: 0, y: 0, width: 0, height: 0, glyphs: 0 };
	var wordWrap = wordWrapper.exports.lines;

	function WordWrap$1(text) {
		/**
		 * The text being operated on.
		 * @param {String} text
		 */
		this.text = text||"";

		/**
		 * An array of lines representing the state of this word wrapper.
		 * @param {Array} lines
		 */
		this.lines = [];

		/** 
		 * The newline character to break on, default '\n'
		 * @param {String} newline
		 */
		this.newline = '\n';

		/**
		 * The mode for wordwrapping: 'pre', 'normal', or 'nowrap'.
		 *
		 * You can also use the `PRE`, `NORMAL`, and `NOWRAP` constants
		 * in `WordWrap.Mode`.
		 * 
		 * @param {String} mode
		 */
		this.mode = WordWrap$1.Mode.NORMAL;
	}

	WordWrap$1.Mode = {
		PRE: 'pre',       //whitespace isn't collapsed
		NORMAL: 'normal', //whitespace is collapsed
		NOWRAP: 'nowrap'  //only break on '\n'
	};

	/**
	 * Clears any multi-line layout by placing all the text in a single Line object.
	 * 
	 * @param {GlyphIterator} iterator the iterator to use 
	 * @method  clearLayout
	 */
	WordWrap$1.prototype.clearLayout = function(iterator) {
		this.lines.length = 0;
		
		if (this.text.length > 0) {
			iterator.getBounds(this.text, 0, this.text.length, undefined, tmpBounds$1);
			
			var line = new WordWrap$1.Line(0, this.text.length, tmpBounds$1.width);
			this.lines.push(line);
		}
	};

	/**
	 * Resets the word wrapper by emptying all current lines.
	 * @method  empty
	 */
	WordWrap$1.prototype.empty = function() {
		this.lines.length = 0;
	};

	/**
	 * Word-wraps the given text into multiple lines.
	 * @param  {[type]} iterator [description]
	 * @param  {[type]} width    [description]
	 * @param  {[type]} start    [description]
	 * @param  {[type]} end      [description]
	 * @return {[type]}          [description]
	 */
	WordWrap$1.prototype.layout = function(iterator, wrapWidth, start, end) {
		var text = this.text;
		var measure = createMetrics(iterator);
		var lines = wordWrap(text, {
			start: start,
			end: end,
			width: wrapWidth,
			measure: measure,
			mode: this.mode
		});
		//append new lines
		this.lines = this.lines.concat(lines);
	};

	/**
	 * A convenience method to return the maximum width of all current lines.
	 * This is useful for aligning blocks of text.
	 *
	 * @method  getMaxLineWidth
	 * @return {Number} the maximum width of all lines
	 */
	WordWrap$1.prototype.getMaxLineWidth = function() {
		var maxWidth = 0;
		for (var i=0; i<this.lines.length; i++) {
			var line = this.lines[i];
			maxWidth = Math.max(line.width, maxWidth);
		}
		return maxWidth;
	};

	/**
	 * The Line object holds the start and end indices into the string,
	 * and the width as computed by GlyphIterator.
	 * 
	 * @class  WordWrap.Line
	 * @param {Number} start the start index, inclusive
	 * @param {Number} end   the end index, exclusive
	 * @param {Number} width the computed width of this line
	 */
	WordWrap$1.Line = function(start, end, width) {
		this.start = start;
		this.end = end;
		this.width = width;
	};

	var fontpathWordwrap = WordWrap$1;

	function createMetrics(iterator) {
		return function(text, start, end, width) {
			iterator.getBounds(text, start, end, width, tmpBounds$1);
			return new WordWrap$1.Line(start, start + tmpBounds$1.glyphs, tmpBounds$1.width);
		}
	}

	var GlyphIterator = fontpathGlyphIterator;
	var WordWrap = fontpathWordwrap;

	var tmpBounds = { x: 0, y: 0, width: 0, height: 0, glyphs: 0 };

	function TextRenderer$1(options) {
	    if (!(this instanceof TextRenderer$1))
	        return new TextRenderer$1(options);
	    options = options||{};

	    this.iterator = new GlyphIterator(options.font, options.fontSize);
	    this.wordwrap = new WordWrap();

	    this.align = 'left';
	    this.underline = false;

	    this.underlineThickness = undefined;
	    this.underlinePosition = undefined;
	    this._text = "";

	    if (typeof options.align === 'string')
	        this.align = options.align;
	    if (typeof options.underline === 'boolean')
	        this.underline = options.underline;
	    if (typeof options.underlineThickness === 'number')
	        this.underlineThickness = options.underlineThickness;
	    if (typeof options.underlinePosition === 'number')
	        this.underlinePosition = options.underlinePosition;
	    if (typeof options.text === 'string')
	        this.text = options.text;
	    if (typeof options.lineHeight === 'number')
	        this.lineHeight = options.lineHeight;
	    if (typeof options.letterSpacing === 'number')
	        this.letterSpacing = options.letterSpacing;
	    if (typeof options.wrapMode === 'string')
	        this.wordwrap.mode = options.wrapMode;
	    if (typeof options.wrapWidth === 'number')
	        this.layout(options.wrapWidth);
	}

	//Internally we will use integers to avoid string comparison for each glyph
	var LEFT_ALIGN = 0, CENTER_ALIGN = 1, RIGHT_ALIGN = 2;
	var ALIGN_ARRAY = [
	    'left', 
	    'center', 
	    'right'
	];
	    
	Object.defineProperties(TextRenderer$1.prototype, {
	    /**
	     * If the new font differs from the last, the text layout is cleared
	     * and placed onto a single line. Users must manually re-layout the text 
	     * for word wrapping.
	     */
	    "font": {
	        get: function() {
	            return this.iterator.font;
	        },
	        set: function(val) {
	            var oldFont = this.iterator.font;
	            this.iterator.font = val;
	            if (oldFont !== this.iterator.font)
	                this.clearLayout();
	        },
	    },

	    /**
	     * If the new font size differs from the last, the text layout is cleared
	     * and placed onto a single line. Users must manually re-layout the text 
	     * for word wrapping.
	     */
	    "fontSize": {
	        get: function() {
	            return this.iterator.fontSize;
	        },
	        set: function(val) {
	            var oldSize = this.iterator.fontSize;

	            this.iterator.fontSize = val;

	            if (oldSize !== this.iterator.fontSize)
	                this.clearLayout();
	        },
	    },
	    "lineHeight": {
	        get: function() {
	            return this.iterator.lineHeight;
	        },
	        set: function(val) {
	            this.iterator.lineHeight = val;
	        },
	    },
	    "letterSpacing": {
	         get: function() {
	            return this.iterator.letterSpacing;
	        },
	        set: function(val) {
	            this.iterator.letterSpacing = val;
	        },
	    },

	    /**
	     * If the new text is different from the last, the layout (i.e. word-wrapping)
	     * is cleared and the result is a single line of text (similar to HTML5 canvas text
	     * rendering).
	     * 
	     * The text then needs to be re-wordwrapped with a call to `layout()`.
	     */
	    "text": {
	        get: function() {
	            return this._text;
	        },

	        set: function(text) {
	            text = text||"";

	            var old = this._text;
	            this._text = text;
	            this.wordwrap.text = this.text;

	            if (this._text !== old) 
	                this.clearLayout();
	        }
	    }
	});

	/**
	 * Clears the text layout and word-wrapping, placing all of it on a single line.
	 */
	TextRenderer$1.prototype.clearLayout = function() {
	    this.wordwrap.text = this.text;
	    this.wordwrap.empty();

	    if (this.iterator.font) //font might not have been passed at constructor
	        this.wordwrap.clearLayout(this.iterator);
	};

	/**
	 * Calls the word wrapper to layout the current text string,
	 * based on the wrap width and any current wordwrapping options.
	 *
	 * This is called when the text is changed. 
	 * 
	 * @return {[type]} [description]
	 */
	TextRenderer$1.prototype.layout = function(wrapWidth) {
	    this.wordwrap.text = this.text;
	    this.wordwrap.empty();
	    this.wordwrap.layout(this.iterator, wrapWidth);
	};

	/**
	 * "Renders" this glyph at the given location. This may involve filling
	 * a VBO with vertex data, or it may be a direct call to draw a bitmap glyph
	 * or shape outline.
	 * @return {[type]} [description]
	 */
	TextRenderer$1.prototype.renderGlyph = function() {

	};

	TextRenderer$1.prototype.renderUnderline = function() {

	};

	/**
	 * Returns the bounds of the current text layout. 
	 *
	 * The height does not extend past the baseline of the
	 * last line; unless `includeUnderline` is true, in which
	 * case the underline's position and height is included
	 * in the calculation. 
	 *
	 * The bounding y position is offset so that the box has an upper-left
	 * origin, for parity with HTML5 canvas rendering.
	 * 
	 * @param {Boolean} includeUnderline whether to include the underline in the calculation, default false
	 * @param {Object} out an optional {width, height} object for re-use
	 * @return {Object} a size with { width, height } properties
	 */
	TextRenderer$1.prototype.getBounds = function (includeUnderline, out) {
	    if (!out)
	        out = { x: 0, y: 0, width: 0, height: 0 };

	    var wordwrapper = this.wordwrap;
	    var itr = this.iterator;

	    //tighten the bounding box around the first line..
	    var firstLineHeight = 0;
	    if (wordwrapper.lines.length > 0) {
	        var firstLine = wordwrapper.lines[0];
	        itr.getBounds(this.text, firstLine.start, firstLine.end, undefined, tmpBounds);
	        firstLineHeight = tmpBounds.height;
	    }

	    out.width = wordwrapper.getMaxLineWidth();   
	    out.height = Math.max(0, wordwrapper.lines.length-1) * itr.getLineGap() + firstLineHeight;

	    out.x = 0;
	    out.y = -out.height;

	    if (includeUnderline) {
	        var underlineHeight = this.computeUnderlineHeight();
	        var underlinePosition = this.computeUnderlinePosition();
	        var underlineOff = underlinePosition+underlineHeight/2;
	        out.height += underlineOff;
	    }

	    return out;
	};

	/**
	 * Computes the scaled underline height as pixels, based on 
	 * the explicit `underlineHeight` (in pixels). If `underlineHeight` is
	 * undefined or null, it will try to use the font's non-zero underline height, 
	 * otherwise default to 1/8 of the font's EM square.
	 * 
	 * @return {Number} the pixel height of the underline 
	 */
	TextRenderer$1.prototype.computeUnderlineHeight = function () {
	    var font = this.font;
	    var scale = this.iterator.fontScale;
	    if (this.underlineThickness===0||this.underlineThickness) {
	        return this.underlineThickness; 
	    } else if (font.underline_thickness) {
	        return font.underline_thickness * scale; 
	    } else if (font.bitmap)
	        return font.size/8;
	    else
	        return (font.units_per_EM/8)*scale;
	};

	/**
	 * Computes the scaled underline height as pixels, based on 
	 * the explicit `underlinePosition` (in pixels). If `underlinePosition` is
	 * undefined or null, it will try to use the font's non-zero underline position, 
	 * otherwise default to 1/4 of the font's EM square.
	 *
	 * This is the Y offset from the text baseline to the center of the underline 
	 * bar, in pixels. It is generally a positive value.
	 * 
	 * @return {Number} the pixel position of the underline 
	 */
	TextRenderer$1.prototype.computeUnderlinePosition = function () {
	    var font = this.font;
	    var scale = this.iterator.fontScale;
	        
	    if (this.underlinePosition===0||this.underlinePosition) {
	        return this.underlinePosition; 
	    } else if (font.underline_position) {
	        return -font.underline_position * scale; 
	    } else if (font.bitmap) {
	        return font.size/4;
	    } else {
	        return (font.units_per_EM/4)*scale;
	    }
	};

	/**
	 * Gets the descent of the current font (assumes its size 
	 * is already set). This is an absolute (positive) value.
	 * 
	 * @return {[type]} [description]
	 */
	TextRenderer$1.prototype.getDescender = function () {
	    return Math.abs(this.iterator.fontScale * this.iterator.font.descender);
	};

	/**
	 * Gets the descent of the current font (assumes its size 
	 * is already set). This is an absolute (positive) value.
	 * 
	 * @return {[type]} [description]
	 */
	TextRenderer$1.prototype.getAscender = function () {
	    return Math.abs(this.iterator.fontScale * this.iterator.font.ascender);
	};

	//Signals for subclasses to optionally implmeent
	//This may be useful to stop/start paths with different fills
	TextRenderer$1.prototype.onBegin = function() { };
	TextRenderer$1.prototype.onEnd = function() { };
	TextRenderer$1.prototype.onBeginLine = function(lineIndex) { };
	TextRenderer$1.prototype.onEndLine = function(lineIndex) { };

	/**
	 * Renders the current text layout, where lower-left is 
	 * the origin. Multiple lines will be positioned above the
	 * origin.
	 */
	TextRenderer$1.prototype.render = function (x, y, start, end) {
	    x = x||0;
	    y = y||0;

	    var text = this.text;
	    var wordwrapper = this.wordwrap;

	    //if we have nothing to draw
	    if (!text || wordwrapper.lines.length === 0)
	        return;

	    //default start/end params
	    start = start||0;
	    end = typeof end === "number" ? end : text.length;

	    var itr = this.iterator;
	    var scale = itr.fontScale;
	    itr.font;
	    var underline = this.underline;

	    //used for alignment...
	    var maxLineWidth = wordwrapper.getMaxLineWidth();
	    
	    y -= Math.max(0, wordwrapper.lines.length-1) * itr.getLineGap();


	    //use numbers to avoid str compare for each glyph
	    var alignType = ALIGN_ARRAY.indexOf(this.align||"");
	    if (alignType===-1)
	        alignType = LEFT_ALIGN;

	    var underlineX = 0;
	    var underlineStartX = 0;
	    var underlineY = 0;
	    var underlineWidth = 0;

	    var underlineStarted = false;

	    //Try to use user-specified underline settings, otherwise use the font if possible,
	    //otherwise just use a rough default based on EM square.    
	    var underlinePos = this.computeUnderlinePosition();
	    var underlineHeight = this.computeUnderlineHeight();

	    this.onBegin();
	    
	    //set the origin and pen position
	    itr.begin(x, y);
	    for (var k=0; k<wordwrapper.lines.length; k++) {
	        var line = wordwrapper.lines[k];
	        underlineStarted = false;

	        var lastAdvance = 0;

	        itr.pen.x;
	        itr.pen.y;

	        this.onBeginLine(k);

	        //TODO: use multiple Nodes inside a single line
	        //a node will have attributes like font, size, color, 
	        //letter-spacing, underline, etc.
	        //This will affect the line height, as it will have to be the max of all nodes.

	        for (var i=line.start; i<line.end; i++) {
	            text.charAt(i);

	            //Step the iterator, moving forward based on kerning from last char
	            var glyph = itr.step(text, i);

	            if (!glyph)
	                continue;

	            //within desired range
	            if (i >= start && i < end) {
	                var tx = itr.pen.x;
	                var ty = itr.pen.y;

	                if (alignType === CENTER_ALIGN) {
	                    tx += (maxLineWidth-line.width)/2;
	                } else if (alignType === RIGHT_ALIGN) {
	                    tx += (maxLineWidth-line.width);
	                }

	                if (!underlineStarted) {
	                    underlineX = tx;
	                    underlineStartX = tx;
	                    underlineY = ty + underlinePos;
	                    underlineWidth = 0;
	                    underlineStarted = true;
	                } else {
	                    underlineWidth = tx - underlineStartX;
	                }

	                this.renderGlyph(i, glyph, scale, tx, ty);
	            }

	            //Advance the iterator to the next glyph in the string
	            var newAdvance = itr.advance(glyph);

	            if (i >= start && i < end)
	                lastAdvance = newAdvance;
	        }

	        this.onEndLine(k);

	        if (underline) {
	            underlineWidth += lastAdvance;
	            this.renderUnderline(underlineX, underlineY-underlineHeight/2, underlineWidth, underlineHeight);
	        }
	        
	        //Steps down a line...
	        if (k < wordwrapper.lines.length-1) {
	            itr.advanceLine();
	        }
	    }

	    //finish the iterator...
	    itr.end();
	    this.onEnd();
	};

	var fontpathRenderer = TextRenderer$1;

	var inherits_browser = {exports: {}};

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      ctor.prototype = Object.create(superCtor.prototype, {
	        constructor: {
	          value: ctor,
	          enumerable: false,
	          writable: true,
	          configurable: true
	        }
	      });
	    }
	  };
	} else {
	  // old school shim for old browsers
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      var TempCtor = function () {};
	      TempCtor.prototype = superCtor.prototype;
	      ctor.prototype = new TempCtor();
	      ctor.prototype.constructor = ctor;
	    }
	  };
	}

	var Base$1 = fontpathRenderer;
	var inherits$1 = inherits_browser.exports;

	//TODO: Eventually lots of this code will just replace fontpath-renderer...

	function FontpathRenderer(options) {
	    if (!(this instanceof FontpathRenderer))
	        return new FontpathRenderer(options)
	    Base$1.call(this, options);

	    this.data = {
	        glyphs: [],
	        underlines: []
	    };
	}

	inherits$1(FontpathRenderer, Base$1);

	FontpathRenderer.prototype.renderGlyph = function(i, glyph, scale, x, y) {
	    this.data.glyphs.push(new Glyph(i, glyph, 
	                this.text.charCodeAt(i), 
	                [ scale, this.font.bitmap ? scale : -scale ],
	                [ x, y ]));
	};

	FontpathRenderer.prototype.renderUnderline = function(x, y, width, height) {
	    this.data.underlines.push(new Underline(
	        [ x, y ],
	        [ width, height ]
	    ));
	};

	FontpathRenderer.prototype.render = function(x, y, start, end) {
	    //new data for result
	    this.data.glyphs.length = 0;
	    this.data.underlines.length = 0;
	    Base$1.prototype.render.call(this, x, y, start, end);
	    return this.data
	};

	function Glyph(index, glyph, charCode, scale, position) {
	    this.glyph = glyph;
	    this.index = index;
	    this.charCode = charCode;
	    this.position = position;
	    this.scale = scale;
	}

	function Underline(position, size) {
	    this.position = position;
	    this.size = size;
	}

	var fontpathSimpleRenderer = FontpathRenderer;

	var glBasicShader = {exports: {}};

	var identity_1 = identity$2;

	/**
	 * Set a mat4 to the identity matrix
	 *
	 * @param {mat4} out the receiving matrix
	 * @returns {mat4} out
	 */
	function identity$2(out) {
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = 1;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = 1;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out;
	}

	function dupe_array(count, value, i) {
	  var c = count[i]|0;
	  if(c <= 0) {
	    return []
	  }
	  var result = new Array(c), j;
	  if(i === count.length-1) {
	    for(j=0; j<c; ++j) {
	      result[j] = value;
	    }
	  } else {
	    for(j=0; j<c; ++j) {
	      result[j] = dupe_array(count, value, i+1);
	    }
	  }
	  return result
	}

	function dupe_number(count, value) {
	  var result, i;
	  result = new Array(count);
	  for(i=0; i<count; ++i) {
	    result[i] = value;
	  }
	  return result
	}

	function dupe(count, value) {
	  if(typeof value === "undefined") {
	    value = 0;
	  }
	  switch(typeof count) {
	    case "number":
	      if(count > 0) {
	        return dupe_number(count|0, value)
	      }
	    break
	    case "object":
	      if(typeof (count.length) === "number") {
	        return dupe_array(count, value, 0)
	      }
	    break
	  }
	  return []
	}

	var dup$2 = dupe;

	var reflect = makeReflectTypes;

	//Construct type info for reflection.
	//
	// This iterates over the flattened list of uniform type values and smashes them into a JSON object.
	//
	// The leaves of the resulting object are either indices or type strings representing primitive glslify types
	function makeReflectTypes(uniforms, useIndex) {
	  var obj = {};
	  for(var i=0; i<uniforms.length; ++i) {
	    var n = uniforms[i].name;
	    var parts = n.split(".");
	    var o = obj;
	    for(var j=0; j<parts.length; ++j) {
	      var x = parts[j].split("[");
	      if(x.length > 1) {
	        if(!(x[0] in o)) {
	          o[x[0]] = [];
	        }
	        o = o[x[0]];
	        for(var k=1; k<x.length; ++k) {
	          var y = parseInt(x[k]);
	          if(k<x.length-1 || j<parts.length-1) {
	            if(!(y in o)) {
	              if(k < x.length-1) {
	                o[y] = [];
	              } else {
	                o[y] = {};
	              }
	            }
	            o = o[y];
	          } else {
	            if(useIndex) {
	              o[y] = i;
	            } else {
	              o[y] = uniforms[i].type;
	            }
	          }
	        }
	      } else if(j < parts.length-1) {
	        if(!(x[0] in o)) {
	          o[x[0]] = {};
	        }
	        o = o[x[0]];
	      } else {
	        if(useIndex) {
	          o[x[0]] = i;
	        } else {
	          o[x[0]] = uniforms[i].type;
	        }
	      }
	    }
	  }
	  return obj
	}

	var dup$1 = dup$2;
	var coallesceUniforms = reflect;

	var createUniforms = createUniformWrapper$1;

	//Binds a function and returns a value
	function identity$1(x) {
	  var c = new Function('y', 'return function(){return y}');
	  return c(x)
	}

	//Create shims for uniforms
	function createUniformWrapper$1(gl, program, uniforms, locations) {

	  function makeGetter(index) {
	    var proc = new Function('gl', 'prog', 'locations', 
	      'return function(){return gl.getUniform(prog,locations[' + index + '])}'); 
	    return proc(gl, program, locations)
	  }

	  function makePropSetter(path, index, type) {
	    switch(type) {
	      case 'bool':
	      case 'int':
	      case 'sampler2D':
	      case 'samplerCube':
	        return 'gl.uniform1i(locations[' + index + '],obj' + path + ')'
	      case 'float':
	        return 'gl.uniform1f(locations[' + index + '],obj' + path + ')'
	      default:
	        var vidx = type.indexOf('vec');
	        if(0 <= vidx && vidx <= 1 && type.length === 4 + vidx) {
	          var d = type.charCodeAt(type.length-1) - 48;
	          if(d < 2 || d > 4) {
	            throw new Error('gl-shader: Invalid data type')
	          }
	          switch(type.charAt(0)) {
	            case 'b':
	            case 'i':
	              return 'gl.uniform' + d + 'iv(locations[' + index + '],obj' + path + ')'
	            case 'v':
	              return 'gl.uniform' + d + 'fv(locations[' + index + '],obj' + path + ')'
	            default:
	              throw new Error('gl-shader: Unrecognized data type for vector ' + name + ': ' + type)
	          }
	        } else if(type.indexOf('mat') === 0 && type.length === 4) {
	          var d = type.charCodeAt(type.length-1) - 48;
	          if(d < 2 || d > 4) {
	            throw new Error('gl-shader: Invalid uniform dimension type for matrix ' + name + ': ' + type)
	          }
	          return 'gl.uniformMatrix' + d + 'fv(locations[' + index + '],false,obj' + path + ')'
	        } else {
	          throw new Error('gl-shader: Unknown uniform data type for ' + name + ': ' + type)
	        }
	      break
	    }
	  }

	  function enumerateIndices(prefix, type) {
	    if(typeof type !== 'object') {
	      return [ [prefix, type] ]
	    }
	    var indices = [];
	    for(var id in type) {
	      var prop = type[id];
	      var tprefix = prefix;
	      if(parseInt(id) + '' === id) {
	        tprefix += '[' + id + ']';
	      } else {
	        tprefix += '.' + id;
	      }
	      if(typeof prop === 'object') {
	        indices.push.apply(indices, enumerateIndices(tprefix, prop));
	      } else {
	        indices.push([tprefix, prop]);
	      }
	    }
	    return indices
	  }

	  function makeSetter(type) {
	    var code = [ 'return function updateProperty(obj){' ];
	    var indices = enumerateIndices('', type);
	    for(var i=0; i<indices.length; ++i) {
	      var item = indices[i];
	      var path = item[0];
	      var idx  = item[1];
	      if(locations[idx]) {
	        code.push(makePropSetter(path, idx, uniforms[idx].type));
	      }
	    }
	    code.push('return obj}');
	    var proc = new Function('gl', 'prog', 'locations', code.join('\n'));
	    return proc(gl, program, locations)
	  }

	  function defaultValue(type) {
	    switch(type) {
	      case 'bool':
	        return false
	      case 'int':
	      case 'sampler2D':
	      case 'samplerCube':
	        return 0
	      case 'float':
	        return 0.0
	      default:
	        var vidx = type.indexOf('vec');
	        if(0 <= vidx && vidx <= 1 && type.length === 4 + vidx) {
	          var d = type.charCodeAt(type.length-1) - 48;
	          if(d < 2 || d > 4) {
	            throw new Error('gl-shader: Invalid data type')
	          }
	          if(type.charAt(0) === 'b') {
	            return dup$1(d, false)
	          }
	          return dup$1(d)
	        } else if(type.indexOf('mat') === 0 && type.length === 4) {
	          var d = type.charCodeAt(type.length-1) - 48;
	          if(d < 2 || d > 4) {
	            throw new Error('gl-shader: Invalid uniform dimension type for matrix ' + name + ': ' + type)
	          }
	          return dup$1([d,d])
	        } else {
	          throw new Error('gl-shader: Unknown uniform data type for ' + name + ': ' + type)
	        }
	    }
	  }

	  function storeProperty(obj, prop, type) {
	    if(typeof type === 'object') {
	      var child = processObject(type);
	      Object.defineProperty(obj, prop, {
	        get: identity$1(child),
	        set: makeSetter(type),
	        enumerable: true,
	        configurable: false
	      });
	    } else {
	      if(locations[type]) {
	        Object.defineProperty(obj, prop, {
	          get: makeGetter(type),
	          set: makeSetter(type),
	          enumerable: true,
	          configurable: false
	        });
	      } else {
	        obj[prop] = defaultValue(uniforms[type].type);
	      }
	    }
	  }

	  function processObject(obj) {
	    var result;
	    if(Array.isArray(obj)) {
	      result = new Array(obj.length);
	      for(var i=0; i<obj.length; ++i) {
	        storeProperty(result, i, obj[i]);
	      }
	    } else {
	      result = {};
	      for(var id in obj) {
	        storeProperty(result, id, obj[id]);
	      }
	    }
	    return result
	  }

	  //Return data
	  var coallesced = coallesceUniforms(uniforms, true);
	  return {
	    get: identity$1(processObject(coallesced)),
	    set: makeSetter(coallesced),
	    enumerable: true,
	    configurable: true
	  }
	}

	var createAttributes = createAttributeWrapper$1;

	//Shader attribute class
	function ShaderAttribute(gl, program, location, dimension, name, constFunc, relink) {
	  this._gl = gl;
	  this._program = program;
	  this._location = location;
	  this._dimension = dimension;
	  this._name = name;
	  this._constFunc = constFunc;
	  this._relink = relink;
	}

	var proto$1 = ShaderAttribute.prototype;

	proto$1.pointer = function setAttribPointer(type, normalized, stride, offset) {
	  var gl = this._gl;
	  gl.vertexAttribPointer(this._location, this._dimension, type||gl.FLOAT, !!normalized, stride||0, offset||0);
	  this._gl.enableVertexAttribArray(this._location);
	};

	Object.defineProperty(proto$1, 'location', {
	  get: function() {
	    return this._location
	  }
	  , set: function(v) {
	    if(v !== this._location) {
	      this._location = v;
	      this._gl.bindAttribLocation(this._program, v, this._name);
	      this._gl.linkProgram(this._program);
	      this._relink();
	    }
	  }
	});


	//Adds a vector attribute to obj
	function addVectorAttribute(gl, program, location, dimension, obj, name, doLink) {
	  var constFuncArgs = [ 'gl', 'v' ];
	  var varNames = [];
	  for(var i=0; i<dimension; ++i) {
	    constFuncArgs.push('x'+i);
	    varNames.push('x'+i);
	  }
	  constFuncArgs.push([
	    'if(x0.length===void 0){return gl.vertexAttrib', dimension, 'f(v,', varNames.join(), ')}else{return gl.vertexAttrib', dimension, 'fv(v,x0)}'
	  ].join(''));
	  var constFunc = Function.apply(undefined, constFuncArgs);
	  var attr = new ShaderAttribute(gl, program, location, dimension, name, constFunc, doLink);
	  Object.defineProperty(obj, name, {
	    set: function(x) {
	      gl.disableVertexAttribArray(attr._location);
	      constFunc(gl, attr._location, x);
	      return x
	    }
	    , get: function() {
	      return attr
	    }
	    , enumerable: true
	  });
	}

	//Create shims for attributes
	function createAttributeWrapper$1(gl, program, attributes, doLink) {
	  var obj = {};
	  for(var i=0, n=attributes.length; i<n; ++i) {
	    var a = attributes[i];
	    var name = a.name;
	    var type = a.type;
	    var location = gl.getAttribLocation(program, name);
	    
	    switch(type) {
	      case 'bool':
	      case 'int':
	      case 'float':
	        addVectorAttribute(gl, program, location, 1, obj, name, doLink);
	      break
	      
	      default:
	        if(type.indexOf('vec') >= 0) {
	          var d = type.charCodeAt(type.length-1) - 48;
	          if(d < 2 || d > 4) {
	            throw new Error('gl-shader: Invalid data type for attribute ' + name + ': ' + type)
	          }
	          addVectorAttribute(gl, program, location, d, obj, name, doLink);
	        } else {
	          throw new Error('gl-shader: Unknown data type for attribute ' + name + ': ' + type)
	        }
	      break
	    }
	  }
	  return obj
	}

	var createUniformWrapper = createUniforms;
	var createAttributeWrapper = createAttributes;
	var makeReflect = reflect;

	//Shader object
	function Shader(gl, prog, vertShader, fragShader) {
	  this.gl = gl;
	  this.handle = prog;
	  this.attributes = null;
	  this.uniforms = null;
	  this.types = null;
	  this.vertexShader = vertShader;
	  this.fragmentShader = fragShader;
	}

	//Binds the shader
	Shader.prototype.bind = function() {
	  this.gl.useProgram(this.handle);
	};

	//Destroy shader, release resources
	Shader.prototype.dispose = function() {
	  var gl = this.gl;
	  gl.deleteShader(this.vertexShader);
	  gl.deleteShader(this.fragmentShader);
	  gl.deleteProgram(this.handle);
	};

	Shader.prototype.updateExports = function(uniforms, attributes) {
	  var locations = new Array(uniforms.length);
	  var program = this.handle;
	  var gl = this.gl;

	  var doLink = relinkUniforms.bind(void 0,
	    gl,
	    program,
	    locations,
	    uniforms
	  );
	  doLink();

	  this.types = {
	    uniforms: makeReflect(uniforms),
	    attributes: makeReflect(attributes)
	  };

	  this.attributes = createAttributeWrapper(
	    gl,
	    program,
	    attributes,
	    doLink
	  );

	  Object.defineProperty(this, 'uniforms', createUniformWrapper(
	    gl,
	    program,
	    uniforms,
	    locations
	  ));
	};

	//Relinks all uniforms
	function relinkUniforms(gl, program, locations, uniforms) {
	  for(var i=0; i<uniforms.length; ++i) {
	    locations[i] = gl.getUniformLocation(program, uniforms[i].name);
	  }
	}

	//Compiles and links a shader program with the given attribute and vertex list
	function createShader$2(
	    gl
	  , vertSource
	  , fragSource
	  , uniforms
	  , attributes) {
	  
	  //Compile vertex shader
	  var vertShader = gl.createShader(gl.VERTEX_SHADER);
	  gl.shaderSource(vertShader, vertSource);
	  gl.compileShader(vertShader);
	  if(!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {
	    var errLog = gl.getShaderInfoLog(vertShader);
	    console.error('gl-shader: Error compling vertex shader:', errLog);
	    throw new Error('gl-shader: Error compiling vertex shader:' + errLog)
	  }
	  
	  //Compile fragment shader
	  var fragShader = gl.createShader(gl.FRAGMENT_SHADER);
	  gl.shaderSource(fragShader, fragSource);
	  gl.compileShader(fragShader);
	  if(!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
	    var errLog = gl.getShaderInfoLog(fragShader);
	    console.error('gl-shader: Error compiling fragment shader:', errLog);
	    throw new Error('gl-shader: Error compiling fragment shader:' + errLog)
	  }
	  
	  //Link program
	  var program = gl.createProgram();
	  gl.attachShader(program, fragShader);
	  gl.attachShader(program, vertShader);

	  //Optional default attriubte locations
	  attributes.forEach(function(a) {
	    if (typeof a.location === 'number') 
	      gl.bindAttribLocation(program, a.location, a.name);
	  });

	  gl.linkProgram(program);
	  if(!gl.getProgramParameter(program, gl.LINK_STATUS)) {
	    var errLog = gl.getProgramInfoLog(program);
	    console.error('gl-shader: Error linking shader program:', errLog);
	    throw new Error('gl-shader: Error linking shader program:' + errLog)
	  }
	  
	  //Return final linked shader object
	  var shader = new Shader(
	    gl,
	    program,
	    vertShader,
	    fragShader
	  );
	  shader.updateExports(uniforms, attributes);

	  return shader
	}

	var shaderCore = createShader$2;

	(function (module) {
	var identity = identity_1;
	var createShader = shaderCore;

	var POSITION_ATTRIBUTE = 'position',
	    NORMAL_ATTRIBUTE = 'normal',
	    COLOR_ATTRIBUTE = 'color',
	    TEXCOORD_ATTRIBUTE = 'texcoord';


	module.exports = function(gl, options) {
	    options = options||{};
	    options.texcoord = typeof options.texcoord === 'number' 
	                ? options.texcoord : (options.texcoord||0);
	        
	    var shaderSource = module.exports.generate(options),
	        vert = shaderSource.vertex,
	        frag = shaderSource.fragment,
	        uniforms = shaderSource.uniforms,
	        attribs = shaderSource.attributes;
	    
	    var shader = createShader(gl, vert, frag, uniforms, attribs);
	    shader.bind();
	    for (var i=0; i<options.texcoord; i++) 
	        shader.uniforms['texture'+i] = i;

	    var arr = identity( new Float32Array(16) );
	    shader.uniforms.projection = arr;
	    shader.uniforms.model = arr;
	    shader.uniforms.view = arr;
	    shader.uniforms.tint = options.tint || [1, 1, 1, 1];

	    return shader
	};

	module.exports.generate = function(options) {
	    options = options||{};
	    options.texcoord = typeof options.texcoord === 'number' 
	                ? options.texcoord : (options.texcoord||0);

	    var pointSize = typeof options.pointSize === 'number' ? options.pointSize : 1;
	    var vert = typeof options.vertex === 'string'
	            ? options.vertex : createVertexShader(options.normal, options.color, options.texcoord, pointSize);
	    var frag = typeof options.fragment === 'string'
	            ? options.fragment : createFragmentShader(options.color, options.texcoord);

	    var uniforms = [
	        { type: 'mat4', name: 'projection' },
	        { type: 'mat4', name: 'view' },
	        { type: 'mat4', name: 'model' },
	        { type: 'vec4', name: 'tint' }
	    ];

	    //Similar to old school pipeline, we will use fixed locations
	    //http://www.opengl.org/sdk/docs/tutorials/ClockworkCoders/attributes.php
	    var attribs = [
	        { type: 'vec4', name: POSITION_ATTRIBUTE, location: 0 }
	    ];

	    if (options.normal)
	        attribs.push({ type: 'vec3', name: NORMAL_ATTRIBUTE, location: 1 });
	    if (options.color)
	        attribs.push({ type: 'vec4', name: COLOR_ATTRIBUTE, location: 2 });

	    var idx = 3;
	    for (var i=0; i<options.texcoord; i++) {
	        uniforms.push({ type: 'sampler2D', name: 'texture'+i });
	        attribs.push({ type: 'vec2', name: TEXCOORD_ATTRIBUTE+i, location: idx++ });
	    }

	    return { vertex: vert, fragment: frag, uniforms: uniforms, attributes: attribs }
	};


	function createVertexShader(hasNormals, hasColors, numTexCoords, pointSize) {
	    numTexCoords = numTexCoords || 0;
	    var shader = "";
	    shader += "attribute vec4 "+POSITION_ATTRIBUTE+";\n"
	         + (hasNormals ? "attribute vec3 " + NORMAL_ATTRIBUTE + ";\n" : "")
	         + (hasColors ? "attribute vec4 " + COLOR_ATTRIBUTE + ";\n" : "");

	    var i;
	    pointSize = pointSize.toFixed(5);

	    for (i = 0; i < numTexCoords; i++) {
	        shader += "attribute vec2 " + TEXCOORD_ATTRIBUTE + i + ";\n";
	    }

	    shader += "uniform mat4 projection;\n";
	    shader += "uniform mat4 view;\n";
	    shader += "uniform mat4 model;\n";
	    
	    shader += (hasColors ? "varying vec4 v_col;\n" : "");

	    for (i = 0; i < numTexCoords; i++) {
	        shader += "varying vec2 v_tex" + i + ";\n";
	    }

	    shader += "\nvoid main() {\n" + "   gl_Position = projection * view * model * " + POSITION_ATTRIBUTE + ";\n"
	            + (hasColors ? "   v_col = " + COLOR_ATTRIBUTE + ";\n" : "");

	    for (i = 0; i < numTexCoords; i++) {
	        shader += "   v_tex" + i + " = " + TEXCOORD_ATTRIBUTE + i + ";\n";
	    }
	    shader += "   gl_PointSize = "+pointSize+";\n";
	    shader += "}\n";

	    return shader;
	}

	function createFragmentShader(hasColors, numTexCoords) {
	    numTexCoords = numTexCoords || 0;
	    var shader = "#ifdef GL_ES\n" + "precision mediump float;\n" + "#endif\n\n";
	 
	    if (hasColors) 
	        shader += "varying vec4 v_col;\n";

	    var i;
	    for (i = 0; i < numTexCoords; i++) {
	        shader += "varying vec2 v_tex" + i + ";\n";
	        shader += "uniform sampler2D texture" + i + ";\n";
	    }
	    shader += "uniform vec4 tint;\n";

	    shader += "\nvoid main() {\n" + "   gl_FragColor = ";

	    if (hasColors)
	        shader += "v_col";

	    if (hasColors && numTexCoords > 0) 
	        shader += " * ";
	    else if (!hasColors && !numTexCoords)
	        shader += "vec4(1.0)";

	    for (i = 0; i < numTexCoords; i++) {
	        if (i == numTexCoords - 1) {
	                shader += " texture2D(texture" + i + ",  v_tex" + i + ")";
	        } else {
	                shader += " texture2D(texture" + i + ",  v_tex" + i + ") *";
	        }
	    }

	    shader += " * tint";
	    shader += ";\n}";
	    return shader;
	}
	}(glBasicShader));

	var create_1 = create;

	/**
	 * Creates a new identity mat4
	 *
	 * @returns {mat4} a new 4x4 matrix
	 */
	function create() {
	    var out = new Float32Array(16);
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = 1;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = 1;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out;
	}

	var translate_1 = translate;

	/**
	 * Translate a mat4 by the given vector
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to translate
	 * @param {vec3} v vector to translate by
	 * @returns {mat4} out
	 */
	function translate(out, a, v) {
	    var x = v[0], y = v[1], z = v[2],
	        a00, a01, a02, a03,
	        a10, a11, a12, a13,
	        a20, a21, a22, a23;

	    if (a === out) {
	        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
	        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
	        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
	        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
	    } else {
	        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
	        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
	        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

	        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
	        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
	        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

	        out[12] = a00 * x + a10 * y + a20 * z + a[12];
	        out[13] = a01 * x + a11 * y + a21 * z + a[13];
	        out[14] = a02 * x + a12 * y + a22 * z + a[14];
	        out[15] = a03 * x + a13 * y + a23 * z + a[15];
	    }

	    return out;
	}

	var scale_1 = scale;

	/**
	 * Scales the mat4 by the dimensions in the given vec3
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to scale
	 * @param {vec3} v the vec3 to scale the matrix by
	 * @returns {mat4} out
	 **/
	function scale(out, a, v) {
	    var x = v[0], y = v[1], z = v[2];

	    out[0] = a[0] * x;
	    out[1] = a[1] * x;
	    out[2] = a[2] * x;
	    out[3] = a[3] * x;
	    out[4] = a[4] * y;
	    out[5] = a[5] * y;
	    out[6] = a[6] * y;
	    out[7] = a[7] * y;
	    out[8] = a[8] * z;
	    out[9] = a[9] * z;
	    out[10] = a[10] * z;
	    out[11] = a[11] * z;
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	    return out;
	}

	var pool$1 = {};

	var twiddle = {};

	/**
	 * Bit twiddling hacks for JavaScript.
	 *
	 * Author: Mikola Lysenko
	 *
	 * Ported from Stanford bit twiddling hack library:
	 *    http://graphics.stanford.edu/~seander/bithacks.html
	 */

	//Number of bits in an integer
	var INT_BITS = 32;

	//Constants
	twiddle.INT_BITS  = INT_BITS;
	twiddle.INT_MAX   =  0x7fffffff;
	twiddle.INT_MIN   = -1<<(INT_BITS-1);

	//Returns -1, 0, +1 depending on sign of x
	twiddle.sign = function(v) {
	  return (v > 0) - (v < 0);
	};

	//Computes absolute value of integer
	twiddle.abs = function(v) {
	  var mask = v >> (INT_BITS-1);
	  return (v ^ mask) - mask;
	};

	//Computes minimum of integers x and y
	twiddle.min = function(x, y) {
	  return y ^ ((x ^ y) & -(x < y));
	};

	//Computes maximum of integers x and y
	twiddle.max = function(x, y) {
	  return x ^ ((x ^ y) & -(x < y));
	};

	//Checks if a number is a power of two
	twiddle.isPow2 = function(v) {
	  return !(v & (v-1)) && (!!v);
	};

	//Computes log base 2 of v
	twiddle.log2 = function(v) {
	  var r, shift;
	  r =     (v > 0xFFFF) << 4; v >>>= r;
	  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;
	  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;
	  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;
	  return r | (v >> 1);
	};

	//Computes log base 10 of v
	twiddle.log10 = function(v) {
	  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
	          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
	          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
	};

	//Counts number of bits
	twiddle.popCount = function(v) {
	  v = v - ((v >>> 1) & 0x55555555);
	  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
	  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
	};

	//Counts number of trailing zeros
	function countTrailingZeros(v) {
	  var c = 32;
	  v &= -v;
	  if (v) c--;
	  if (v & 0x0000FFFF) c -= 16;
	  if (v & 0x00FF00FF) c -= 8;
	  if (v & 0x0F0F0F0F) c -= 4;
	  if (v & 0x33333333) c -= 2;
	  if (v & 0x55555555) c -= 1;
	  return c;
	}
	twiddle.countTrailingZeros = countTrailingZeros;

	//Rounds to next power of 2
	twiddle.nextPow2 = function(v) {
	  v += v === 0;
	  --v;
	  v |= v >>> 1;
	  v |= v >>> 2;
	  v |= v >>> 4;
	  v |= v >>> 8;
	  v |= v >>> 16;
	  return v + 1;
	};

	//Rounds down to previous power of 2
	twiddle.prevPow2 = function(v) {
	  v |= v >>> 1;
	  v |= v >>> 2;
	  v |= v >>> 4;
	  v |= v >>> 8;
	  v |= v >>> 16;
	  return v - (v>>>1);
	};

	//Computes parity of word
	twiddle.parity = function(v) {
	  v ^= v >>> 16;
	  v ^= v >>> 8;
	  v ^= v >>> 4;
	  v &= 0xf;
	  return (0x6996 >>> v) & 1;
	};

	var REVERSE_TABLE = new Array(256);

	(function(tab) {
	  for(var i=0; i<256; ++i) {
	    var v = i, r = i, s = 7;
	    for (v >>>= 1; v; v >>>= 1) {
	      r <<= 1;
	      r |= v & 1;
	      --s;
	    }
	    tab[i] = (r << s) & 0xff;
	  }
	})(REVERSE_TABLE);

	//Reverse bits in a 32 bit word
	twiddle.reverse = function(v) {
	  return  (REVERSE_TABLE[ v         & 0xff] << 24) |
	          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |
	          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |
	           REVERSE_TABLE[(v >>> 24) & 0xff];
	};

	//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
	twiddle.interleave2 = function(x, y) {
	  x &= 0xFFFF;
	  x = (x | (x << 8)) & 0x00FF00FF;
	  x = (x | (x << 4)) & 0x0F0F0F0F;
	  x = (x | (x << 2)) & 0x33333333;
	  x = (x | (x << 1)) & 0x55555555;

	  y &= 0xFFFF;
	  y = (y | (y << 8)) & 0x00FF00FF;
	  y = (y | (y << 4)) & 0x0F0F0F0F;
	  y = (y | (y << 2)) & 0x33333333;
	  y = (y | (y << 1)) & 0x55555555;

	  return x | (y << 1);
	};

	//Extracts the nth interleaved component
	twiddle.deinterleave2 = function(v, n) {
	  v = (v >>> n) & 0x55555555;
	  v = (v | (v >>> 1))  & 0x33333333;
	  v = (v | (v >>> 2))  & 0x0F0F0F0F;
	  v = (v | (v >>> 4))  & 0x00FF00FF;
	  v = (v | (v >>> 16)) & 0x000FFFF;
	  return (v << 16) >> 16;
	};


	//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
	twiddle.interleave3 = function(x, y, z) {
	  x &= 0x3FF;
	  x  = (x | (x<<16)) & 4278190335;
	  x  = (x | (x<<8))  & 251719695;
	  x  = (x | (x<<4))  & 3272356035;
	  x  = (x | (x<<2))  & 1227133513;

	  y &= 0x3FF;
	  y  = (y | (y<<16)) & 4278190335;
	  y  = (y | (y<<8))  & 251719695;
	  y  = (y | (y<<4))  & 3272356035;
	  y  = (y | (y<<2))  & 1227133513;
	  x |= (y << 1);
	  
	  z &= 0x3FF;
	  z  = (z | (z<<16)) & 4278190335;
	  z  = (z | (z<<8))  & 251719695;
	  z  = (z | (z<<4))  & 3272356035;
	  z  = (z | (z<<2))  & 1227133513;
	  
	  return x | (z << 2);
	};

	//Extracts nth interleaved component of a 3-tuple
	twiddle.deinterleave3 = function(v, n) {
	  v = (v >>> n)       & 1227133513;
	  v = (v | (v>>>2))   & 3272356035;
	  v = (v | (v>>>4))   & 251719695;
	  v = (v | (v>>>8))   & 4278190335;
	  v = (v | (v>>>16))  & 0x3FF;
	  return (v<<22)>>22;
	};

	//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
	twiddle.nextCombination = function(v) {
	  var t = v | (v - 1);
	  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
	};

	var global$1 = (typeof global !== "undefined" ? global :
	            typeof self !== "undefined" ? self :
	            typeof window !== "undefined" ? window : {});

	var lookup = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
	var inited = false;
	function init () {
	  inited = true;
	  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	  for (var i = 0, len = code.length; i < len; ++i) {
	    lookup[i] = code[i];
	    revLookup[code.charCodeAt(i)] = i;
	  }

	  revLookup['-'.charCodeAt(0)] = 62;
	  revLookup['_'.charCodeAt(0)] = 63;
	}

	function toByteArray (b64) {
	  if (!inited) {
	    init();
	  }
	  var i, j, l, tmp, placeHolders, arr;
	  var len = b64.length;

	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }

	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

	  // base64 is 4/3 + up to two characters of the original data
	  arr = new Arr(len * 3 / 4 - placeHolders);

	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len;

	  var L = 0;

	  for (i = 0, j = 0; i < l; i += 4, j += 3) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
	    arr[L++] = (tmp >> 16) & 0xFF;
	    arr[L++] = (tmp >> 8) & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }

	  if (placeHolders === 2) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
	    arr[L++] = tmp & 0xFF;
	  } else if (placeHolders === 1) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
	    arr[L++] = (tmp >> 8) & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }

	  return arr
	}

	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	}

	function encodeChunk (uint8, start, end) {
	  var tmp;
	  var output = [];
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
	    output.push(tripletToBase64(tmp));
	  }
	  return output.join('')
	}

	function fromByteArray (uint8) {
	  if (!inited) {
	    init();
	  }
	  var tmp;
	  var len = uint8.length;
	  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
	  var output = '';
	  var parts = [];
	  var maxChunkLength = 16383; // must be multiple of 3

	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
	  }

	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1];
	    output += lookup[tmp >> 2];
	    output += lookup[(tmp << 4) & 0x3F];
	    output += '==';
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
	    output += lookup[tmp >> 10];
	    output += lookup[(tmp >> 4) & 0x3F];
	    output += lookup[(tmp << 2) & 0x3F];
	    output += '=';
	  }

	  parts.push(output);

	  return parts.join('')
	}

	function read (buffer, offset, isLE, mLen, nBytes) {
	  var e, m;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = -7;
	  var i = isLE ? (nBytes - 1) : 0;
	  var d = isLE ? -1 : 1;
	  var s = buffer[offset + i];

	  i += d;

	  e = s & ((1 << (-nBits)) - 1);
	  s >>= (-nBits);
	  nBits += eLen;
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1);
	  e >>= (-nBits);
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	function write (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
	  var i = isLE ? 0 : (nBytes - 1);
	  var d = isLE ? 1 : -1;
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

	  value = Math.abs(value);

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }

	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128;
	}

	var toString$1 = {}.toString;

	var isArray$1 = Array.isArray || function (arr) {
	  return toString$1.call(arr) == '[object Array]';
	};

	var INSPECT_MAX_BYTES = 50;

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer$1.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
	  ? global$1.TYPED_ARRAY_SUPPORT
	  : true;

	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	var _kMaxLength = kMaxLength();

	function kMaxLength () {
	  return Buffer$1.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	function createBuffer$2 (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length);
	    that.__proto__ = Buffer$1.prototype;
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer$1(length);
	    }
	    that.length = length;
	  }

	  return that
	}

	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */

	function Buffer$1 (arg, encodingOrOffset, length) {
	  if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
	    return new Buffer$1(arg, encodingOrOffset, length)
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}

	Buffer$1.poolSize = 8192; // not used by this implementation

	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer$1._augment = function (arr) {
	  arr.__proto__ = Buffer$1.prototype;
	  return arr
	};

	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }

	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }

	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }

	  return fromObject(that, value)
	}

	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer$1.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	};

	if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	  Buffer$1.prototype.__proto__ = Uint8Array.prototype;
	  Buffer$1.__proto__ = Uint8Array;
	}

	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}

	function alloc (that, size, fill, encoding) {
	  assertSize(size);
	  if (size <= 0) {
	    return createBuffer$2(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer$2(that, size).fill(fill, encoding)
	      : createBuffer$2(that, size).fill(fill)
	  }
	  return createBuffer$2(that, size)
	}

	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer$1.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	};

	function allocUnsafe (that, size) {
	  assertSize(size);
	  that = createBuffer$2(that, size < 0 ? 0 : checked(size) | 0);
	  if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0;
	    }
	  }
	  return that
	}

	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer$1.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	};
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer$1.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	};

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8';
	  }

	  if (!Buffer$1.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }

	  var length = byteLength(string, encoding) | 0;
	  that = createBuffer$2(that, length);

	  var actual = that.write(string, encoding);

	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual);
	  }

	  return that
	}

	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0;
	  that = createBuffer$2(that, length);
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255;
	  }
	  return that
	}

	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }

	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }

	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array);
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset);
	  } else {
	    array = new Uint8Array(array, byteOffset, length);
	  }

	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array;
	    that.__proto__ = Buffer$1.prototype;
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array);
	  }
	  return that
	}

	function fromObject (that, obj) {
	  if (internalIsBuffer(obj)) {
	    var len = checked(obj.length) | 0;
	    that = createBuffer$2(that, len);

	    if (that.length === 0) {
	      return that
	    }

	    obj.copy(that, 0, 0, len);
	    return that
	  }

	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer$2(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }

	    if (obj.type === 'Buffer' && isArray$1(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }

	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0;
	  }
	  return Buffer$1.alloc(+length)
	}
	Buffer$1.isBuffer = isBuffer$2;
	function internalIsBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer$1.compare = function compare (a, b) {
	  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length;
	  var y = b.length;

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	};

	Buffer$1.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	};

	Buffer$1.concat = function concat (list, length) {
	  if (!isArray$1(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }

	  if (list.length === 0) {
	    return Buffer$1.alloc(0)
	  }

	  var i;
	  if (length === undefined) {
	    length = 0;
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length;
	    }
	  }

	  var buffer = Buffer$1.allocUnsafe(length);
	  var pos = 0;
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i];
	    if (!internalIsBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos);
	    pos += buf.length;
	  }
	  return buffer
	};

	function byteLength (string, encoding) {
	  if (internalIsBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string;
	  }

	  var len = string.length;
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	}
	Buffer$1.byteLength = byteLength;

	function slowToString (encoding, start, end) {
	  var loweredCase = false;

	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.

	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0;
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }

	  if (end === undefined || end > this.length) {
	    end = this.length;
	  }

	  if (end <= 0) {
	    return ''
	  }

	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0;
	  start >>>= 0;

	  if (end <= start) {
	    return ''
	  }

	  if (!encoding) encoding = 'utf8';

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase();
	        loweredCase = true;
	    }
	  }
	}

	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer$1.prototype._isBuffer = true;

	function swap (b, n, m) {
	  var i = b[n];
	  b[n] = b[m];
	  b[m] = i;
	}

	Buffer$1.prototype.swap16 = function swap16 () {
	  var len = this.length;
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1);
	  }
	  return this
	};

	Buffer$1.prototype.swap32 = function swap32 () {
	  var len = this.length;
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3);
	    swap(this, i + 1, i + 2);
	  }
	  return this
	};

	Buffer$1.prototype.swap64 = function swap64 () {
	  var len = this.length;
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7);
	    swap(this, i + 1, i + 6);
	    swap(this, i + 2, i + 5);
	    swap(this, i + 3, i + 4);
	  }
	  return this
	};

	Buffer$1.prototype.toString = function toString () {
	  var length = this.length | 0;
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	};

	Buffer$1.prototype.equals = function equals (b) {
	  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer$1.compare(this, b) === 0
	};

	Buffer$1.prototype.inspect = function inspect () {
	  var str = '';
	  var max = INSPECT_MAX_BYTES;
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
	    if (this.length > max) str += ' ... ';
	  }
	  return '<Buffer ' + str + '>'
	};

	Buffer$1.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!internalIsBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }

	  if (start === undefined) {
	    start = 0;
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0;
	  }
	  if (thisStart === undefined) {
	    thisStart = 0;
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length;
	  }

	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }

	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }

	  start >>>= 0;
	  end >>>= 0;
	  thisStart >>>= 0;
	  thisEnd >>>= 0;

	  if (this === target) return 0

	  var x = thisEnd - thisStart;
	  var y = end - start;
	  var len = Math.min(x, y);

	  var thisCopy = this.slice(thisStart, thisEnd);
	  var targetCopy = target.slice(start, end);

	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i];
	      y = targetCopy[i];
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	};

	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1

	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset;
	    byteOffset = 0;
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff;
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000;
	  }
	  byteOffset = +byteOffset;  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1);
	  }

	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1;
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0;
	    else return -1
	  }

	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer$1.from(val, encoding);
	  }

	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (internalIsBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF; // Search for a byte value [0-255]
	    if (Buffer$1.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1;
	  var arrLength = arr.length;
	  var valLength = val.length;

	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase();
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2;
	      arrLength /= 2;
	      valLength /= 2;
	      byteOffset /= 2;
	    }
	  }

	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }

	  var i;
	  if (dir) {
	    var foundIndex = -1;
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i;
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex;
	        foundIndex = -1;
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true;
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false;
	          break
	        }
	      }
	      if (found) return i
	    }
	  }

	  return -1
	}

	Buffer$1.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	};

	Buffer$1.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	};

	Buffer$1.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	};

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0;
	  var remaining = buf.length - offset;
	  if (!length) {
	    length = remaining;
	  } else {
	    length = Number(length);
	    if (length > remaining) {
	      length = remaining;
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length;
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2;
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16);
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed;
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer$1.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8';
	    length = this.length;
	    offset = 0;
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset;
	    length = this.length;
	    offset = 0;
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0;
	    if (isFinite(length)) {
	      length = length | 0;
	      if (encoding === undefined) encoding = 'utf8';
	    } else {
	      encoding = length;
	      length = undefined;
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }

	  var remaining = this.length - offset;
	  if (length === undefined || length > remaining) length = remaining;

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8';

	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	};

	Buffer$1.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	};

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return fromByteArray(buf)
	  } else {
	    return fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end);
	  var res = [];

	  var i = start;
	  while (i < end) {
	    var firstByte = buf[i];
	    var codePoint = null;
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1;

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint;

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte;
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1];
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          fourthByte = buf[i + 3];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint;
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD;
	      bytesPerSequence = 1;
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000;
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
	      codePoint = 0xDC00 | codePoint & 0x3FF;
	    }

	    res.push(codePoint);
	    i += bytesPerSequence;
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000;

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length;
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = '';
	  var i = 0;
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    );
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F);
	  }
	  return ret
	}

	function latin1Slice (buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i]);
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length;

	  if (!start || start < 0) start = 0;
	  if (!end || end < 0 || end > len) end = len;

	  var out = '';
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i]);
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end);
	  var res = '';
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
	  }
	  return res
	}

	Buffer$1.prototype.slice = function slice (start, end) {
	  var len = this.length;
	  start = ~~start;
	  end = end === undefined ? len : ~~end;

	  if (start < 0) {
	    start += len;
	    if (start < 0) start = 0;
	  } else if (start > len) {
	    start = len;
	  }

	  if (end < 0) {
	    end += len;
	    if (end < 0) end = 0;
	  } else if (end > len) {
	    end = len;
	  }

	  if (end < start) end = start;

	  var newBuf;
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end);
	    newBuf.__proto__ = Buffer$1.prototype;
	  } else {
	    var sliceLen = end - start;
	    newBuf = new Buffer$1(sliceLen, undefined);
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start];
	    }
	  }

	  return newBuf
	};

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer$1.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }

	  return val
	};

	Buffer$1.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length);
	  }

	  var val = this[offset + --byteLength];
	  var mul = 1;
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul;
	  }

	  return val
	};

	Buffer$1.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length);
	  return this[offset]
	};

	Buffer$1.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  return this[offset] | (this[offset + 1] << 8)
	};

	Buffer$1.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  return (this[offset] << 8) | this[offset + 1]
	};

	Buffer$1.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	};

	Buffer$1.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	};

	Buffer$1.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }
	  mul *= 0x80;

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

	  return val
	};

	Buffer$1.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var i = byteLength;
	  var mul = 1;
	  var val = this[offset + --i];
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul;
	  }
	  mul *= 0x80;

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

	  return val
	};

	Buffer$1.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length);
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	};

	Buffer$1.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  var val = this[offset] | (this[offset + 1] << 8);
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	};

	Buffer$1.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  var val = this[offset + 1] | (this[offset] << 8);
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	};

	Buffer$1.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	};

	Buffer$1.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	};

	Buffer$1.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return read(this, offset, true, 23, 4)
	};

	Buffer$1.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return read(this, offset, false, 23, 4)
	};

	Buffer$1.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length);
	  return read(this, offset, true, 52, 8)
	};

	Buffer$1.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length);
	  return read(this, offset, false, 52, 8)
	};

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}

	Buffer$1.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	    checkInt(this, value, offset, byteLength, maxBytes, 0);
	  }

	  var mul = 1;
	  var i = 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$1.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	    checkInt(this, value, offset, byteLength, maxBytes, 0);
	  }

	  var i = byteLength - 1;
	  var mul = 1;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$1.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
	  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  this[offset] = (value & 0xff);
	  return offset + 1
	};

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8;
	  }
	}

	Buffer$1.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	  } else {
	    objectWriteUInt16(this, value, offset, true);
	  }
	  return offset + 2
	};

	Buffer$1.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8);
	    this[offset + 1] = (value & 0xff);
	  } else {
	    objectWriteUInt16(this, value, offset, false);
	  }
	  return offset + 2
	};

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
	  }
	}

	Buffer$1.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24);
	    this[offset + 2] = (value >>> 16);
	    this[offset + 1] = (value >>> 8);
	    this[offset] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, true);
	  }
	  return offset + 4
	};

	Buffer$1.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24);
	    this[offset + 1] = (value >>> 16);
	    this[offset + 2] = (value >>> 8);
	    this[offset + 3] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, false);
	  }
	  return offset + 4
	};

	Buffer$1.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);

	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
	  }

	  var i = 0;
	  var mul = 1;
	  var sub = 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1;
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$1.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);

	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
	  }

	  var i = byteLength - 1;
	  var mul = 1;
	  var sub = 0;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1;
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer$1.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
	  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  if (value < 0) value = 0xff + value + 1;
	  this[offset] = (value & 0xff);
	  return offset + 1
	};

	Buffer$1.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	  } else {
	    objectWriteUInt16(this, value, offset, true);
	  }
	  return offset + 2
	};

	Buffer$1.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8);
	    this[offset + 1] = (value & 0xff);
	  } else {
	    objectWriteUInt16(this, value, offset, false);
	  }
	  return offset + 2
	};

	Buffer$1.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	    this[offset + 2] = (value >>> 16);
	    this[offset + 3] = (value >>> 24);
	  } else {
	    objectWriteUInt32(this, value, offset, true);
	  }
	  return offset + 4
	};

	Buffer$1.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	  if (value < 0) value = 0xffffffff + value + 1;
	  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24);
	    this[offset + 1] = (value >>> 16);
	    this[offset + 2] = (value >>> 8);
	    this[offset + 3] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, false);
	  }
	  return offset + 4
	};

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4);
	  }
	  write(buf, value, offset, littleEndian, 23, 4);
	  return offset + 4
	}

	Buffer$1.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	};

	Buffer$1.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	};

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8);
	  }
	  write(buf, value, offset, littleEndian, 52, 8);
	  return offset + 8
	}

	Buffer$1.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	};

	Buffer$1.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	};

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer$1.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0;
	  if (!end && end !== 0) end = this.length;
	  if (targetStart >= target.length) targetStart = target.length;
	  if (!targetStart) targetStart = 0;
	  if (end > 0 && end < start) end = start;

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length;
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start;
	  }

	  var len = end - start;
	  var i;

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else if (len < 1000 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    );
	  }

	  return len
	};

	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer$1.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start;
	      start = 0;
	      end = this.length;
	    } else if (typeof end === 'string') {
	      encoding = end;
	      end = this.length;
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0);
	      if (code < 256) {
	        val = code;
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer$1.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255;
	  }

	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }

	  if (end <= start) {
	    return this
	  }

	  start = start >>> 0;
	  end = end === undefined ? this.length : end >>> 0;

	  if (!val) val = 0;

	  var i;
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val;
	    }
	  } else {
	    var bytes = internalIsBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer$1(val, encoding).toString());
	    var len = bytes.length;
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len];
	    }
	  }

	  return this
	};

	// HELPER FUNCTIONS
	// ================

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '=';
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity;
	  var codePoint;
	  var length = string.length;
	  var leadSurrogate = null;
	  var bytes = [];

	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i);

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint;

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	        leadSurrogate = codePoint;
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	    }

	    leadSurrogate = null;

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint);
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      );
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      );
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      );
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = [];
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF);
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo;
	  var byteArray = [];
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i);
	    hi = c >> 8;
	    lo = c % 256;
	    byteArray.push(lo);
	    byteArray.push(hi);
	  }

	  return byteArray
	}


	function base64ToBytes (str) {
	  return toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i];
	  }
	  return i
	}

	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}


	// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
	// The _isBuffer check is for Safari 5-7 support, because it's missing
	// Object.prototype.constructor. Remove this eventually
	function isBuffer$2(obj) {
	  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer$1(obj))
	}

	function isFastBuffer (obj) {
	  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	}

	// For Node v0.10 support. Remove this eventually.
	function isSlowBuffer$1 (obj) {
	  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
	}

	var bufferEs6 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		INSPECT_MAX_BYTES: INSPECT_MAX_BYTES,
		kMaxLength: _kMaxLength,
		Buffer: Buffer$1,
		SlowBuffer: SlowBuffer,
		isBuffer: isBuffer$2
	});

	var require$$2 = /*@__PURE__*/getAugmentedNamespace(bufferEs6);

	var bits = twiddle;
	var dup = dup$2;
	var Buffer = require$$2.Buffer;

	//Legacy pool support
	if(!commonjsGlobal.__TYPEDARRAY_POOL) {
	  commonjsGlobal.__TYPEDARRAY_POOL = {
	      UINT8     : dup([32, 0])
	    , UINT16    : dup([32, 0])
	    , UINT32    : dup([32, 0])
	    , BIGUINT64 : dup([32, 0])
	    , INT8      : dup([32, 0])
	    , INT16     : dup([32, 0])
	    , INT32     : dup([32, 0])
	    , BIGINT64  : dup([32, 0])
	    , FLOAT     : dup([32, 0])
	    , DOUBLE    : dup([32, 0])
	    , DATA      : dup([32, 0])
	    , UINT8C    : dup([32, 0])
	    , BUFFER    : dup([32, 0])
	  };
	}

	var hasUint8C = (typeof Uint8ClampedArray) !== 'undefined';
	var hasBigUint64 = (typeof BigUint64Array) !== 'undefined';
	var hasBigInt64 = (typeof BigInt64Array) !== 'undefined';
	var POOL = commonjsGlobal.__TYPEDARRAY_POOL;

	//Upgrade pool
	if(!POOL.UINT8C) {
	  POOL.UINT8C = dup([32, 0]);
	}
	if(!POOL.BIGUINT64) {
	  POOL.BIGUINT64 = dup([32, 0]);
	}
	if(!POOL.BIGINT64) {
	  POOL.BIGINT64 = dup([32, 0]);
	}
	if(!POOL.BUFFER) {
	  POOL.BUFFER = dup([32, 0]);
	}

	//New technique: Only allocate from ArrayBufferView and Buffer
	var DATA    = POOL.DATA
	  , BUFFER  = POOL.BUFFER;

	pool$1.free = function free(array) {
	  if(Buffer.isBuffer(array)) {
	    BUFFER[bits.log2(array.length)].push(array);
	  } else {
	    if(Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {
	      array = array.buffer;
	    }
	    if(!array) {
	      return
	    }
	    var n = array.length || array.byteLength;
	    var log_n = bits.log2(n)|0;
	    DATA[log_n].push(array);
	  }
	};

	function freeArrayBuffer(buffer) {
	  if(!buffer) {
	    return
	  }
	  var n = buffer.length || buffer.byteLength;
	  var log_n = bits.log2(n);
	  DATA[log_n].push(buffer);
	}

	function freeTypedArray(array) {
	  freeArrayBuffer(array.buffer);
	}

	pool$1.freeUint8 =
	pool$1.freeUint16 =
	pool$1.freeUint32 =
	pool$1.freeBigUint64 =
	pool$1.freeInt8 =
	pool$1.freeInt16 =
	pool$1.freeInt32 =
	pool$1.freeBigInt64 =
	pool$1.freeFloat32 = 
	pool$1.freeFloat =
	pool$1.freeFloat64 = 
	pool$1.freeDouble = 
	pool$1.freeUint8Clamped = 
	pool$1.freeDataView = freeTypedArray;

	pool$1.freeArrayBuffer = freeArrayBuffer;

	pool$1.freeBuffer = function freeBuffer(array) {
	  BUFFER[bits.log2(array.length)].push(array);
	};

	pool$1.malloc = function malloc(n, dtype) {
	  if(dtype === undefined || dtype === 'arraybuffer') {
	    return mallocArrayBuffer(n)
	  } else {
	    switch(dtype) {
	      case 'uint8':
	        return mallocUint8(n)
	      case 'uint16':
	        return mallocUint16(n)
	      case 'uint32':
	        return mallocUint32(n)
	      case 'int8':
	        return mallocInt8(n)
	      case 'int16':
	        return mallocInt16(n)
	      case 'int32':
	        return mallocInt32(n)
	      case 'float':
	      case 'float32':
	        return mallocFloat(n)
	      case 'double':
	      case 'float64':
	        return mallocDouble(n)
	      case 'uint8_clamped':
	        return mallocUint8Clamped(n)
	      case 'bigint64':
	        return mallocBigInt64(n)
	      case 'biguint64':
	        return mallocBigUint64(n)
	      case 'buffer':
	        return mallocBuffer(n)
	      case 'data':
	      case 'dataview':
	        return mallocDataView(n)

	      default:
	        return null
	    }
	  }
	  return null
	};

	function mallocArrayBuffer(n) {
	  var n = bits.nextPow2(n);
	  var log_n = bits.log2(n);
	  var d = DATA[log_n];
	  if(d.length > 0) {
	    return d.pop()
	  }
	  return new ArrayBuffer(n)
	}
	pool$1.mallocArrayBuffer = mallocArrayBuffer;

	function mallocUint8(n) {
	  return new Uint8Array(mallocArrayBuffer(n), 0, n)
	}
	pool$1.mallocUint8 = mallocUint8;

	function mallocUint16(n) {
	  return new Uint16Array(mallocArrayBuffer(2*n), 0, n)
	}
	pool$1.mallocUint16 = mallocUint16;

	function mallocUint32(n) {
	  return new Uint32Array(mallocArrayBuffer(4*n), 0, n)
	}
	pool$1.mallocUint32 = mallocUint32;

	function mallocInt8(n) {
	  return new Int8Array(mallocArrayBuffer(n), 0, n)
	}
	pool$1.mallocInt8 = mallocInt8;

	function mallocInt16(n) {
	  return new Int16Array(mallocArrayBuffer(2*n), 0, n)
	}
	pool$1.mallocInt16 = mallocInt16;

	function mallocInt32(n) {
	  return new Int32Array(mallocArrayBuffer(4*n), 0, n)
	}
	pool$1.mallocInt32 = mallocInt32;

	function mallocFloat(n) {
	  return new Float32Array(mallocArrayBuffer(4*n), 0, n)
	}
	pool$1.mallocFloat32 = pool$1.mallocFloat = mallocFloat;

	function mallocDouble(n) {
	  return new Float64Array(mallocArrayBuffer(8*n), 0, n)
	}
	pool$1.mallocFloat64 = pool$1.mallocDouble = mallocDouble;

	function mallocUint8Clamped(n) {
	  if(hasUint8C) {
	    return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n)
	  } else {
	    return mallocUint8(n)
	  }
	}
	pool$1.mallocUint8Clamped = mallocUint8Clamped;

	function mallocBigUint64(n) {
	  if(hasBigUint64) {
	    return new BigUint64Array(mallocArrayBuffer(8*n), 0, n)
	  } else {
	    return null;
	  }
	}
	pool$1.mallocBigUint64 = mallocBigUint64;

	function mallocBigInt64(n) {
	  if (hasBigInt64) {
	    return new BigInt64Array(mallocArrayBuffer(8*n), 0, n)
	  } else {
	    return null;
	  }
	}
	pool$1.mallocBigInt64 = mallocBigInt64;

	function mallocDataView(n) {
	  return new DataView(mallocArrayBuffer(n), 0, n)
	}
	pool$1.mallocDataView = mallocDataView;

	function mallocBuffer(n) {
	  n = bits.nextPow2(n);
	  var log_n = bits.log2(n);
	  var cache = BUFFER[log_n];
	  if(cache.length > 0) {
	    return cache.pop()
	  }
	  return new Buffer(n)
	}
	pool$1.mallocBuffer = mallocBuffer;

	pool$1.clearCache = function clearCache() {
	  for(var i=0; i<32; ++i) {
	    POOL.UINT8[i].length = 0;
	    POOL.UINT16[i].length = 0;
	    POOL.UINT32[i].length = 0;
	    POOL.INT8[i].length = 0;
	    POOL.INT16[i].length = 0;
	    POOL.INT32[i].length = 0;
	    POOL.FLOAT[i].length = 0;
	    POOL.DOUBLE[i].length = 0;
	    POOL.BIGUINT64[i].length = 0;
	    POOL.BIGINT64[i].length = 0;
	    POOL.UINT8C[i].length = 0;
	    DATA[i].length = 0;
	    BUFFER[i].length = 0;
	  }
	};

	var ndarrayOps = {};

	function unique_pred(list, compare) {
	  var ptr = 1
	    , len = list.length
	    , a=list[0], b=list[0];
	  for(var i=1; i<len; ++i) {
	    b = a;
	    a = list[i];
	    if(compare(a, b)) {
	      if(i === ptr) {
	        ptr++;
	        continue
	      }
	      list[ptr++] = a;
	    }
	  }
	  list.length = ptr;
	  return list
	}

	function unique_eq(list) {
	  var ptr = 1
	    , len = list.length
	    , a=list[0], b = list[0];
	  for(var i=1; i<len; ++i, b=a) {
	    b = a;
	    a = list[i];
	    if(a !== b) {
	      if(i === ptr) {
	        ptr++;
	        continue
	      }
	      list[ptr++] = a;
	    }
	  }
	  list.length = ptr;
	  return list
	}

	function unique(list, compare, sorted) {
	  if(list.length === 0) {
	    return list
	  }
	  if(compare) {
	    if(!sorted) {
	      list.sort(compare);
	    }
	    return unique_pred(list, compare)
	  }
	  if(!sorted) {
	    list.sort();
	  }
	  return unique_eq(list)
	}

	var uniq$1 = unique;

	var uniq = uniq$1;

	// This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)
	// TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of "pointers" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.
	function innerFill(order, proc, body) {
	  var dimension = order.length
	    , nargs = proc.arrayArgs.length
	    , has_index = proc.indexArgs.length>0
	    , code = []
	    , vars = []
	    , idx=0, pidx=0, i, j;
	  for(i=0; i<dimension; ++i) { // Iteration variables
	    vars.push(["i",i,"=0"].join(""));
	  }
	  //Compute scan deltas
	  for(j=0; j<nargs; ++j) {
	    for(i=0; i<dimension; ++i) {
	      pidx = idx;
	      idx = order[i];
	      if(i === 0) { // The innermost/fastest dimension's delta is simply its stride
	        vars.push(["d",j,"s",i,"=t",j,"p",idx].join(""));
	      } else { // For other dimensions the delta is basically the stride minus something which essentially "rewinds" the previous (more inner) dimension
	        vars.push(["d",j,"s",i,"=(t",j,"p",idx,"-s",pidx,"*t",j,"p",pidx,")"].join(""));
	      }
	    }
	  }
	  if (vars.length > 0) {
	    code.push("var " + vars.join(","));
	  }  
	  //Scan loop
	  for(i=dimension-1; i>=0; --i) { // Start at largest stride and work your way inwards
	    idx = order[i];
	    code.push(["for(i",i,"=0;i",i,"<s",idx,";++i",i,"){"].join(""));
	  }
	  //Push body of inner loop
	  code.push(body);
	  //Advance scan pointers
	  for(i=0; i<dimension; ++i) {
	    pidx = idx;
	    idx = order[i];
	    for(j=0; j<nargs; ++j) {
	      code.push(["p",j,"+=d",j,"s",i].join(""));
	    }
	    if(has_index) {
	      if(i > 0) {
	        code.push(["index[",pidx,"]-=s",pidx].join(""));
	      }
	      code.push(["++index[",idx,"]"].join(""));
	    }
	    code.push("}");
	  }
	  return code.join("\n")
	}

	// Generate "outer" loops that loop over blocks of data, applying "inner" loops to the blocks by manipulating the local variables in such a way that the inner loop only "sees" the current block.
	// TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.
	//       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and "shape" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.
	function outerFill(matched, order, proc, body) {
	  var dimension = order.length
	    , nargs = proc.arrayArgs.length
	    , blockSize = proc.blockSize
	    , has_index = proc.indexArgs.length > 0
	    , code = [];
	  for(var i=0; i<nargs; ++i) {
	    code.push(["var offset",i,"=p",i].join(""));
	  }
	  //Generate loops for unmatched dimensions
	  // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)
	  // TODO: It would be nice if the order in which these loops are placed would also be somehow "optimal" (at the very least we should check that it really doesn't hurt us if they're not).
	  for(var i=matched; i<dimension; ++i) {
	    code.push(["for(var j"+i+"=SS[", order[i], "]|0;j", i, ">0;){"].join("")); // Iterate back to front
	    code.push(["if(j",i,"<",blockSize,"){"].join("")); // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).
	    code.push(["s",order[i],"=j",i].join(""));
	    code.push(["j",i,"=0"].join(""));
	    code.push(["}else{s",order[i],"=",blockSize].join(""));
	    code.push(["j",i,"-=",blockSize,"}"].join(""));
	    if(has_index) {
	      code.push(["index[",order[i],"]=j",i].join(""));
	    }
	  }
	  for(var i=0; i<nargs; ++i) {
	    var indexStr = ["offset"+i];
	    for(var j=matched; j<dimension; ++j) {
	      indexStr.push(["j",j,"*t",i,"p",order[j]].join(""));
	    }
	    code.push(["p",i,"=(",indexStr.join("+"),")"].join(""));
	  }
	  code.push(innerFill(order, proc, body));
	  for(var i=matched; i<dimension; ++i) {
	    code.push("}");
	  }
	  return code.join("\n")
	}

	//Count the number of compatible inner orders
	// This is the length of the longest common prefix of the arrays in orders.
	// Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.
	// This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.
	function countMatches(orders) {
	  var matched = 0, dimension = orders[0].length;
	  while(matched < dimension) {
	    for(var j=1; j<orders.length; ++j) {
	      if(orders[j][matched] !== orders[0][matched]) {
	        return matched
	      }
	    }
	    ++matched;
	  }
	  return matched
	}

	//Processes a block according to the given data types
	// Replaces variable names by different ones, either "local" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.
	function processBlock(block, proc, dtypes) {
	  var code = block.body;
	  var pre = [];
	  var post = [];
	  for(var i=0; i<block.args.length; ++i) {
	    var carg = block.args[i];
	    if(carg.count <= 0) {
	      continue
	    }
	    var re = new RegExp(carg.name, "g");
	    var ptrStr = "";
	    var arrNum = proc.arrayArgs.indexOf(i);
	    switch(proc.argTypes[i]) {
	      case "offset":
	        var offArgIndex = proc.offsetArgIndex.indexOf(i);
	        var offArg = proc.offsetArgs[offArgIndex];
	        arrNum = offArg.array;
	        ptrStr = "+q" + offArgIndex; // Adds offset to the "pointer" in the array
	      case "array":
	        ptrStr = "p" + arrNum + ptrStr;
	        var localStr = "l" + i;
	        var arrStr = "a" + arrNum;
	        if (proc.arrayBlockIndices[arrNum] === 0) { // Argument to body is just a single value from this array
	          if(carg.count === 1) { // Argument/array used only once(?)
	            if(dtypes[arrNum] === "generic") {
	              if(carg.lvalue) {
	                pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")); // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
	                code = code.replace(re, localStr);
	                post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""));
	              } else {
	                code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""));
	              }
	            } else {
	              code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""));
	            }
	          } else if(dtypes[arrNum] === "generic") {
	            pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")); // TODO: Could we optimize by checking for carg.rvalue?
	            code = code.replace(re, localStr);
	            if(carg.lvalue) {
	              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""));
	            }
	          } else {
	            pre.push(["var ", localStr, "=", arrStr, "[", ptrStr, "]"].join("")); // TODO: Could we optimize by checking for carg.rvalue?
	            code = code.replace(re, localStr);
	            if(carg.lvalue) {
	              post.push([arrStr, "[", ptrStr, "]=", localStr].join(""));
	            }
	          }
	        } else { // Argument to body is a "block"
	          var reStrArr = [carg.name], ptrStrArr = [ptrStr];
	          for(var j=0; j<Math.abs(proc.arrayBlockIndices[arrNum]); j++) {
	            reStrArr.push("\\s*\\[([^\\]]+)\\]");
	            ptrStrArr.push("$" + (j+1) + "*t" + arrNum + "b" + j); // Matched index times stride
	          }
	          re = new RegExp(reStrArr.join(""), "g");
	          ptrStr = ptrStrArr.join("+");
	          if(dtypes[arrNum] === "generic") {
	            /*if(carg.lvalue) {
	              pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
	              code = code.replace(re, localStr)
	              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
	            } else {
	              code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
	            }*/
	            throw new Error("cwise: Generic arrays not supported in combination with blocks!")
	          } else {
	            // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.
	            code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""));
	          }
	        }
	      break
	      case "scalar":
	        code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i));
	      break
	      case "index":
	        code = code.replace(re, "index");
	      break
	      case "shape":
	        code = code.replace(re, "shape");
	      break
	    }
	  }
	  return [pre.join("\n"), code, post.join("\n")].join("\n").trim()
	}

	function typeSummary(dtypes) {
	  var summary = new Array(dtypes.length);
	  var allEqual = true;
	  for(var i=0; i<dtypes.length; ++i) {
	    var t = dtypes[i];
	    var digits = t.match(/\d+/);
	    if(!digits) {
	      digits = "";
	    } else {
	      digits = digits[0];
	    }
	    if(t.charAt(0) === 0) {
	      summary[i] = "u" + t.charAt(1) + digits;
	    } else {
	      summary[i] = t.charAt(0) + digits;
	    }
	    if(i > 0) {
	      allEqual = allEqual && summary[i] === summary[i-1];
	    }
	  }
	  if(allEqual) {
	    return summary[0]
	  }
	  return summary.join("")
	}

	//Generates a cwise operator
	function generateCWiseOp(proc, typesig) {

	  //Compute dimension
	  // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.
	  var dimension = (typesig[1].length - Math.abs(proc.arrayBlockIndices[0]))|0;
	  var orders = new Array(proc.arrayArgs.length);
	  var dtypes = new Array(proc.arrayArgs.length);
	  for(var i=0; i<proc.arrayArgs.length; ++i) {
	    dtypes[i] = typesig[2*i];
	    orders[i] = typesig[2*i+1];
	  }
	  
	  //Determine where block and loop indices start and end
	  var blockBegin = [], blockEnd = []; // These indices are exposed as blocks
	  var loopBegin = [], loopEnd = []; // These indices are iterated over
	  var loopOrders = []; // orders restricted to the loop indices
	  for(var i=0; i<proc.arrayArgs.length; ++i) {
	    if (proc.arrayBlockIndices[i]<0) {
	      loopBegin.push(0);
	      loopEnd.push(dimension);
	      blockBegin.push(dimension);
	      blockEnd.push(dimension+proc.arrayBlockIndices[i]);
	    } else {
	      loopBegin.push(proc.arrayBlockIndices[i]); // Non-negative
	      loopEnd.push(proc.arrayBlockIndices[i]+dimension);
	      blockBegin.push(0);
	      blockEnd.push(proc.arrayBlockIndices[i]);
	    }
	    var newOrder = [];
	    for(var j=0; j<orders[i].length; j++) {
	      if (loopBegin[i]<=orders[i][j] && orders[i][j]<loopEnd[i]) {
	        newOrder.push(orders[i][j]-loopBegin[i]); // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.
	      }
	    }
	    loopOrders.push(newOrder);
	  }

	  //First create arguments for procedure
	  var arglist = ["SS"]; // SS is the overall shape over which we iterate
	  var code = ["'use strict'"];
	  var vars = [];
	  
	  for(var j=0; j<dimension; ++j) {
	    vars.push(["s", j, "=SS[", j, "]"].join("")); // The limits for each dimension.
	  }
	  for(var i=0; i<proc.arrayArgs.length; ++i) {
	    arglist.push("a"+i); // Actual data array
	    arglist.push("t"+i); // Strides
	    arglist.push("p"+i); // Offset in the array at which the data starts (also used for iterating over the data)
	    
	    for(var j=0; j<dimension; ++j) { // Unpack the strides into vars for looping
	      vars.push(["t",i,"p",j,"=t",i,"[",loopBegin[i]+j,"]"].join(""));
	    }
	    
	    for(var j=0; j<Math.abs(proc.arrayBlockIndices[i]); ++j) { // Unpack the strides into vars for block iteration
	      vars.push(["t",i,"b",j,"=t",i,"[",blockBegin[i]+j,"]"].join(""));
	    }
	  }
	  for(var i=0; i<proc.scalarArgs.length; ++i) {
	    arglist.push("Y" + i);
	  }
	  if(proc.shapeArgs.length > 0) {
	    vars.push("shape=SS.slice(0)"); // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)
	  }
	  if(proc.indexArgs.length > 0) {
	    // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.
	    var zeros = new Array(dimension);
	    for(var i=0; i<dimension; ++i) {
	      zeros[i] = "0";
	    }
	    vars.push(["index=[", zeros.join(","), "]"].join(""));
	  }
	  for(var i=0; i<proc.offsetArgs.length; ++i) { // Offset arguments used for stencil operations
	    var off_arg = proc.offsetArgs[i];
	    var init_string = [];
	    for(var j=0; j<off_arg.offset.length; ++j) {
	      if(off_arg.offset[j] === 0) {
	        continue
	      } else if(off_arg.offset[j] === 1) {
	        init_string.push(["t", off_arg.array, "p", j].join(""));      
	      } else {
	        init_string.push([off_arg.offset[j], "*t", off_arg.array, "p", j].join(""));
	      }
	    }
	    if(init_string.length === 0) {
	      vars.push("q" + i + "=0");
	    } else {
	      vars.push(["q", i, "=", init_string.join("+")].join(""));
	    }
	  }

	  //Prepare this variables
	  var thisVars = uniq([].concat(proc.pre.thisVars)
	                      .concat(proc.body.thisVars)
	                      .concat(proc.post.thisVars));
	  vars = vars.concat(thisVars);
	  if (vars.length > 0) {
	    code.push("var " + vars.join(","));
	  }
	  for(var i=0; i<proc.arrayArgs.length; ++i) {
	    code.push("p"+i+"|=0");
	  }
	  
	  //Inline prelude
	  if(proc.pre.body.length > 3) {
	    code.push(processBlock(proc.pre, proc, dtypes));
	  }

	  //Process body
	  var body = processBlock(proc.body, proc, dtypes);
	  var matched = countMatches(loopOrders);
	  if(matched < dimension) {
	    code.push(outerFill(matched, loopOrders[0], proc, body)); // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.
	  } else {
	    code.push(innerFill(loopOrders[0], proc, body));
	  }

	  //Inline epilog
	  if(proc.post.body.length > 3) {
	    code.push(processBlock(proc.post, proc, dtypes));
	  }
	  
	  if(proc.debug) {
	    console.log("-----Generated cwise routine for ", typesig, ":\n" + code.join("\n") + "\n----------");
	  }
	  
	  var loopName = [(proc.funcName||"unnamed"), "_cwise_loop_", orders[0].join("s"),"m",matched,typeSummary(dtypes)].join("");
	  var f = new Function(["function ",loopName,"(", arglist.join(","),"){", code.join("\n"),"} return ", loopName].join(""));
	  return f()
	}
	var compile$1 = generateCWiseOp;

	// The function below is called when constructing a cwise function object, and does the following:
	// A function object is constructed which accepts as argument a compilation function and returns another function.
	// It is this other function that is eventually returned by createThunk, and this function is the one that actually
	// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.
	// The compilation passed to the first function object is used for compiling new functions.
	// Once this function object is created, it is called with compile as argument, where the first argument of compile
	// is bound to "proc" (essentially containing a preprocessed version of the user arguments to cwise).
	// So createThunk roughly works like this:
	// function createThunk(proc) {
	//   var thunk = function(compileBound) {
	//     var CACHED = {}
	//     return function(arrays and scalars) {
	//       if (dtype and order of arrays in CACHED) {
	//         var func = CACHED[dtype and order of arrays]
	//       } else {
	//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)
	//       }
	//       return func(arrays and scalars)
	//     }
	//   }
	//   return thunk(compile.bind1(proc))
	// }

	var compile = compile$1;

	function createThunk$1(proc) {
	  var code = ["'use strict'", "var CACHED={}"];
	  var vars = [];
	  var thunkName = proc.funcName + "_cwise_thunk";
	  
	  //Build thunk
	  code.push(["return function ", thunkName, "(", proc.shimArgs.join(","), "){"].join(""));
	  var typesig = [];
	  var string_typesig = [];
	  var proc_args = [["array",proc.arrayArgs[0],".shape.slice(", // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).
	                    Math.max(0,proc.arrayBlockIndices[0]),proc.arrayBlockIndices[0]<0?(","+proc.arrayBlockIndices[0]+")"):")"].join("")];
	  var shapeLengthConditions = [], shapeConditions = [];
	  // Process array arguments
	  for(var i=0; i<proc.arrayArgs.length; ++i) {
	    var j = proc.arrayArgs[i];
	    vars.push(["t", j, "=array", j, ".dtype,",
	               "r", j, "=array", j, ".order"].join(""));
	    typesig.push("t" + j);
	    typesig.push("r" + j);
	    string_typesig.push("t"+j);
	    string_typesig.push("r"+j+".join()");
	    proc_args.push("array" + j + ".data");
	    proc_args.push("array" + j + ".stride");
	    proc_args.push("array" + j + ".offset|0");
	    if (i>0) { // Gather conditions to check for shape equality (ignoring block indices)
	      shapeLengthConditions.push("array" + proc.arrayArgs[0] + ".shape.length===array" + j + ".shape.length+" + (Math.abs(proc.arrayBlockIndices[0])-Math.abs(proc.arrayBlockIndices[i])));
	      shapeConditions.push("array" + proc.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0,proc.arrayBlockIndices[0]) + "]===array" + j + ".shape[shapeIndex+" + Math.max(0,proc.arrayBlockIndices[i]) + "]");
	    }
	  }
	  // Check for shape equality
	  if (proc.arrayArgs.length > 1) {
	    code.push("if (!(" + shapeLengthConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')");
	    code.push("for(var shapeIndex=array" + proc.arrayArgs[0] + ".shape.length-" + Math.abs(proc.arrayBlockIndices[0]) + "; shapeIndex-->0;) {");
	    code.push("if (!(" + shapeConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')");
	    code.push("}");
	  }
	  // Process scalar arguments
	  for(var i=0; i<proc.scalarArgs.length; ++i) {
	    proc_args.push("scalar" + proc.scalarArgs[i]);
	  }
	  // Check for cached function (and if not present, generate it)
	  vars.push(["type=[", string_typesig.join(","), "].join()"].join(""));
	  vars.push("proc=CACHED[type]");
	  code.push("var " + vars.join(","));
	  
	  code.push(["if(!proc){",
	             "CACHED[type]=proc=compile([", typesig.join(","), "])}",
	             "return proc(", proc_args.join(","), ")}"].join(""));

	  if(proc.debug) {
	    console.log("-----Generated thunk:\n" + code.join("\n") + "\n----------");
	  }
	  
	  //Compile thunk
	  var thunk = new Function("compile", code.join("\n"));
	  return thunk(compile.bind(undefined, proc))
	}

	var thunk = createThunk$1;

	var createThunk = thunk;

	function Procedure() {
	  this.argTypes = [];
	  this.shimArgs = [];
	  this.arrayArgs = [];
	  this.arrayBlockIndices = [];
	  this.scalarArgs = [];
	  this.offsetArgs = [];
	  this.offsetArgIndex = [];
	  this.indexArgs = [];
	  this.shapeArgs = [];
	  this.funcName = "";
	  this.pre = null;
	  this.body = null;
	  this.post = null;
	  this.debug = false;
	}

	function compileCwise(user_args) {
	  //Create procedure
	  var proc = new Procedure();
	  
	  //Parse blocks
	  proc.pre    = user_args.pre;
	  proc.body   = user_args.body;
	  proc.post   = user_args.post;

	  //Parse arguments
	  var proc_args = user_args.args.slice(0);
	  proc.argTypes = proc_args;
	  for(var i=0; i<proc_args.length; ++i) {
	    var arg_type = proc_args[i];
	    if(arg_type === "array" || (typeof arg_type === "object" && arg_type.blockIndices)) {
	      proc.argTypes[i] = "array";
	      proc.arrayArgs.push(i);
	      proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0);
	      proc.shimArgs.push("array" + i);
	      if(i < proc.pre.args.length && proc.pre.args[i].count>0) {
	        throw new Error("cwise: pre() block may not reference array args")
	      }
	      if(i < proc.post.args.length && proc.post.args[i].count>0) {
	        throw new Error("cwise: post() block may not reference array args")
	      }
	    } else if(arg_type === "scalar") {
	      proc.scalarArgs.push(i);
	      proc.shimArgs.push("scalar" + i);
	    } else if(arg_type === "index") {
	      proc.indexArgs.push(i);
	      if(i < proc.pre.args.length && proc.pre.args[i].count > 0) {
	        throw new Error("cwise: pre() block may not reference array index")
	      }
	      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
	        throw new Error("cwise: body() block may not write to array index")
	      }
	      if(i < proc.post.args.length && proc.post.args[i].count > 0) {
	        throw new Error("cwise: post() block may not reference array index")
	      }
	    } else if(arg_type === "shape") {
	      proc.shapeArgs.push(i);
	      if(i < proc.pre.args.length && proc.pre.args[i].lvalue) {
	        throw new Error("cwise: pre() block may not write to array shape")
	      }
	      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
	        throw new Error("cwise: body() block may not write to array shape")
	      }
	      if(i < proc.post.args.length && proc.post.args[i].lvalue) {
	        throw new Error("cwise: post() block may not write to array shape")
	      }
	    } else if(typeof arg_type === "object" && arg_type.offset) {
	      proc.argTypes[i] = "offset";
	      proc.offsetArgs.push({ array: arg_type.array, offset:arg_type.offset });
	      proc.offsetArgIndex.push(i);
	    } else {
	      throw new Error("cwise: Unknown argument type " + proc_args[i])
	    }
	  }
	  
	  //Make sure at least one array argument was specified
	  if(proc.arrayArgs.length <= 0) {
	    throw new Error("cwise: No array arguments specified")
	  }
	  
	  //Make sure arguments are correct
	  if(proc.pre.args.length > proc_args.length) {
	    throw new Error("cwise: Too many arguments in pre() block")
	  }
	  if(proc.body.args.length > proc_args.length) {
	    throw new Error("cwise: Too many arguments in body() block")
	  }
	  if(proc.post.args.length > proc_args.length) {
	    throw new Error("cwise: Too many arguments in post() block")
	  }

	  //Check debug flag
	  proc.debug = !!user_args.printCode || !!user_args.debug;
	  
	  //Retrieve name
	  proc.funcName = user_args.funcName || "cwise";
	  
	  //Read in block size
	  proc.blockSize = user_args.blockSize || 64;

	  return createThunk(proc)
	}

	var compiler = compileCwise;

	(function (exports) {

	var compile = compiler;

	var EmptyProc = {
	  body: "",
	  args: [],
	  thisVars: [],
	  localVars: []
	};

	function fixup(x) {
	  if(!x) {
	    return EmptyProc
	  }
	  for(var i=0; i<x.args.length; ++i) {
	    var a = x.args[i];
	    if(i === 0) {
	      x.args[i] = {name: a, lvalue:true, rvalue: !!x.rvalue, count:x.count||1 };
	    } else {
	      x.args[i] = {name: a, lvalue:false, rvalue:true, count: 1};
	    }
	  }
	  if(!x.thisVars) {
	    x.thisVars = [];
	  }
	  if(!x.localVars) {
	    x.localVars = [];
	  }
	  return x
	}

	function pcompile(user_args) {
	  return compile({
	    args:     user_args.args,
	    pre:      fixup(user_args.pre),
	    body:     fixup(user_args.body),
	    post:     fixup(user_args.proc),
	    funcName: user_args.funcName
	  })
	}

	function makeOp(user_args) {
	  var args = [];
	  for(var i=0; i<user_args.args.length; ++i) {
	    args.push("a"+i);
	  }
	  var wrapper = new Function("P", [
	    "return function ", user_args.funcName, "_ndarrayops(", args.join(","), ") {P(", args.join(","), ");return a0}"
	  ].join(""));
	  return wrapper(pcompile(user_args))
	}

	var assign_ops = {
	  add:  "+",
	  sub:  "-",
	  mul:  "*",
	  div:  "/",
	  mod:  "%",
	  band: "&",
	  bor:  "|",
	  bxor: "^",
	  lshift: "<<",
	  rshift: ">>",
	  rrshift: ">>>"
	}
	;(function(){
	  for(var id in assign_ops) {
	    var op = assign_ops[id];
	    exports[id] = makeOp({
	      args: ["array","array","array"],
	      body: {args:["a","b","c"],
	             body: "a=b"+op+"c"},
	      funcName: id
	    });
	    exports[id+"eq"] = makeOp({
	      args: ["array","array"],
	      body: {args:["a","b"],
	             body:"a"+op+"=b"},
	      rvalue: true,
	      funcName: id+"eq"
	    });
	    exports[id+"s"] = makeOp({
	      args: ["array", "array", "scalar"],
	      body: {args:["a","b","s"],
	             body:"a=b"+op+"s"},
	      funcName: id+"s"
	    });
	    exports[id+"seq"] = makeOp({
	      args: ["array","scalar"],
	      body: {args:["a","s"],
	             body:"a"+op+"=s"},
	      rvalue: true,
	      funcName: id+"seq"
	    });
	  }
	})();

	var unary_ops = {
	  not: "!",
	  bnot: "~",
	  neg: "-",
	  recip: "1.0/"
	}
	;(function(){
	  for(var id in unary_ops) {
	    var op = unary_ops[id];
	    exports[id] = makeOp({
	      args: ["array", "array"],
	      body: {args:["a","b"],
	             body:"a="+op+"b"},
	      funcName: id
	    });
	    exports[id+"eq"] = makeOp({
	      args: ["array"],
	      body: {args:["a"],
	             body:"a="+op+"a"},
	      rvalue: true,
	      count: 2,
	      funcName: id+"eq"
	    });
	  }
	})();

	var binary_ops = {
	  and: "&&",
	  or: "||",
	  eq: "===",
	  neq: "!==",
	  lt: "<",
	  gt: ">",
	  leq: "<=",
	  geq: ">="
	}
	;(function() {
	  for(var id in binary_ops) {
	    var op = binary_ops[id];
	    exports[id] = makeOp({
	      args: ["array","array","array"],
	      body: {args:["a", "b", "c"],
	             body:"a=b"+op+"c"},
	      funcName: id
	    });
	    exports[id+"s"] = makeOp({
	      args: ["array","array","scalar"],
	      body: {args:["a", "b", "s"],
	             body:"a=b"+op+"s"},
	      funcName: id+"s"
	    });
	    exports[id+"eq"] = makeOp({
	      args: ["array", "array"],
	      body: {args:["a", "b"],
	             body:"a=a"+op+"b"},
	      rvalue:true,
	      count:2,
	      funcName: id+"eq"
	    });
	    exports[id+"seq"] = makeOp({
	      args: ["array", "scalar"],
	      body: {args:["a","s"],
	             body:"a=a"+op+"s"},
	      rvalue:true,
	      count:2,
	      funcName: id+"seq"
	    });
	  }
	})();

	var math_unary = [
	  "abs",
	  "acos",
	  "asin",
	  "atan",
	  "ceil",
	  "cos",
	  "exp",
	  "floor",
	  "log",
	  "round",
	  "sin",
	  "sqrt",
	  "tan"
	]
	;(function() {
	  for(var i=0; i<math_unary.length; ++i) {
	    var f = math_unary[i];
	    exports[f] = makeOp({
	                    args: ["array", "array"],
	                    pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
	                    body: {args:["a","b"], body:"a=this_f(b)", thisVars:["this_f"]},
	                    funcName: f
	                  });
	    exports[f+"eq"] = makeOp({
	                      args: ["array"],
	                      pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
	                      body: {args: ["a"], body:"a=this_f(a)", thisVars:["this_f"]},
	                      rvalue: true,
	                      count: 2,
	                      funcName: f+"eq"
	                    });
	  }
	})();

	var math_comm = [
	  "max",
	  "min",
	  "atan2",
	  "pow"
	]
	;(function(){
	  for(var i=0; i<math_comm.length; ++i) {
	    var f= math_comm[i];
	    exports[f] = makeOp({
	                  args:["array", "array", "array"],
	                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
	                  body: {args:["a","b","c"], body:"a=this_f(b,c)", thisVars:["this_f"]},
	                  funcName: f
	                });
	    exports[f+"s"] = makeOp({
	                  args:["array", "array", "scalar"],
	                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
	                  body: {args:["a","b","c"], body:"a=this_f(b,c)", thisVars:["this_f"]},
	                  funcName: f+"s"
	                  });
	    exports[f+"eq"] = makeOp({ args:["array", "array"],
	                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
	                  body: {args:["a","b"], body:"a=this_f(a,b)", thisVars:["this_f"]},
	                  rvalue: true,
	                  count: 2,
	                  funcName: f+"eq"
	                  });
	    exports[f+"seq"] = makeOp({ args:["array", "scalar"],
	                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
	                  body: {args:["a","b"], body:"a=this_f(a,b)", thisVars:["this_f"]},
	                  rvalue:true,
	                  count:2,
	                  funcName: f+"seq"
	                  });
	  }
	})();

	var math_noncomm = [
	  "atan2",
	  "pow"
	]
	;(function(){
	  for(var i=0; i<math_noncomm.length; ++i) {
	    var f= math_noncomm[i];
	    exports[f+"op"] = makeOp({
	                  args:["array", "array", "array"],
	                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
	                  body: {args:["a","b","c"], body:"a=this_f(c,b)", thisVars:["this_f"]},
	                  funcName: f+"op"
	                });
	    exports[f+"ops"] = makeOp({
	                  args:["array", "array", "scalar"],
	                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
	                  body: {args:["a","b","c"], body:"a=this_f(c,b)", thisVars:["this_f"]},
	                  funcName: f+"ops"
	                  });
	    exports[f+"opeq"] = makeOp({ args:["array", "array"],
	                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
	                  body: {args:["a","b"], body:"a=this_f(b,a)", thisVars:["this_f"]},
	                  rvalue: true,
	                  count: 2,
	                  funcName: f+"opeq"
	                  });
	    exports[f+"opseq"] = makeOp({ args:["array", "scalar"],
	                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
	                  body: {args:["a","b"], body:"a=this_f(b,a)", thisVars:["this_f"]},
	                  rvalue:true,
	                  count:2,
	                  funcName: f+"opseq"
	                  });
	  }
	})();

	exports.any = compile({
	  args:["array"],
	  pre: EmptyProc,
	  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "if(a){return true}", localVars: [], thisVars: []},
	  post: {args:[], localVars:[], thisVars:[], body:"return false"},
	  funcName: "any"
	});

	exports.all = compile({
	  args:["array"],
	  pre: EmptyProc,
	  body: {args:[{name:"x", lvalue:false, rvalue:true, count:1}], body: "if(!x){return false}", localVars: [], thisVars: []},
	  post: {args:[], localVars:[], thisVars:[], body:"return true"},
	  funcName: "all"
	});

	exports.sum = compile({
	  args:["array"],
	  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
	  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "this_s+=a", localVars: [], thisVars: ["this_s"]},
	  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
	  funcName: "sum"
	});

	exports.prod = compile({
	  args:["array"],
	  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=1"},
	  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "this_s*=a", localVars: [], thisVars: ["this_s"]},
	  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
	  funcName: "prod"
	});

	exports.norm2squared = compile({
	  args:["array"],
	  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
	  body: {args:[{name:"a", lvalue:false, rvalue:true, count:2}], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"]},
	  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
	  funcName: "norm2squared"
	});
	  
	exports.norm2 = compile({
	  args:["array"],
	  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
	  body: {args:[{name:"a", lvalue:false, rvalue:true, count:2}], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"]},
	  post: {args:[], localVars:[], thisVars:["this_s"], body:"return Math.sqrt(this_s)"},
	  funcName: "norm2"
	});
	  

	exports.norminf = compile({
	  args:["array"],
	  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
	  body: {args:[{name:"a", lvalue:false, rvalue:true, count:4}], body:"if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}", localVars: [], thisVars: ["this_s"]},
	  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
	  funcName: "norminf"
	});

	exports.norm1 = compile({
	  args:["array"],
	  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
	  body: {args:[{name:"a", lvalue:false, rvalue:true, count:3}], body: "this_s+=a<0?-a:a", localVars: [], thisVars: ["this_s"]},
	  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
	  funcName: "norm1"
	});

	exports.sup = compile({
	  args: [ "array" ],
	  pre:
	   { body: "this_h=-Infinity",
	     args: [],
	     thisVars: [ "this_h" ],
	     localVars: [] },
	  body:
	   { body: "if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_",
	     args: [{"name":"_inline_1_arg0_","lvalue":false,"rvalue":true,"count":2} ],
	     thisVars: [ "this_h" ],
	     localVars: [] },
	  post:
	   { body: "return this_h",
	     args: [],
	     thisVars: [ "this_h" ],
	     localVars: [] }
	 });

	exports.inf = compile({
	  args: [ "array" ],
	  pre:
	   { body: "this_h=Infinity",
	     args: [],
	     thisVars: [ "this_h" ],
	     localVars: [] },
	  body:
	   { body: "if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_",
	     args: [{"name":"_inline_1_arg0_","lvalue":false,"rvalue":true,"count":2} ],
	     thisVars: [ "this_h" ],
	     localVars: [] },
	  post:
	   { body: "return this_h",
	     args: [],
	     thisVars: [ "this_h" ],
	     localVars: [] }
	 });

	exports.argmin = compile({
	  args:["index","array","shape"],
	  pre:{
	    body:"{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}",
	    args:[
	      {name:"_inline_0_arg0_",lvalue:false,rvalue:false,count:0},
	      {name:"_inline_0_arg1_",lvalue:false,rvalue:false,count:0},
	      {name:"_inline_0_arg2_",lvalue:false,rvalue:true,count:1}
	      ],
	    thisVars:["this_i","this_v"],
	    localVars:[]},
	  body:{
	    body:"{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
	    args:[
	      {name:"_inline_1_arg0_",lvalue:false,rvalue:true,count:2},
	      {name:"_inline_1_arg1_",lvalue:false,rvalue:true,count:2}],
	    thisVars:["this_i","this_v"],
	    localVars:["_inline_1_k"]},
	  post:{
	    body:"{return this_i}",
	    args:[],
	    thisVars:["this_i"],
	    localVars:[]}
	});

	exports.argmax = compile({
	  args:["index","array","shape"],
	  pre:{
	    body:"{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}",
	    args:[
	      {name:"_inline_0_arg0_",lvalue:false,rvalue:false,count:0},
	      {name:"_inline_0_arg1_",lvalue:false,rvalue:false,count:0},
	      {name:"_inline_0_arg2_",lvalue:false,rvalue:true,count:1}
	      ],
	    thisVars:["this_i","this_v"],
	    localVars:[]},
	  body:{
	    body:"{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
	    args:[
	      {name:"_inline_1_arg0_",lvalue:false,rvalue:true,count:2},
	      {name:"_inline_1_arg1_",lvalue:false,rvalue:true,count:2}],
	    thisVars:["this_i","this_v"],
	    localVars:["_inline_1_k"]},
	  post:{
	    body:"{return this_i}",
	    args:[],
	    thisVars:["this_i"],
	    localVars:[]}
	});  

	exports.random = makeOp({
	  args: ["array"],
	  pre: {args:[], body:"this_f=Math.random", thisVars:["this_f"]},
	  body: {args: ["a"], body:"a=this_f()", thisVars:["this_f"]},
	  funcName: "random"
	});

	exports.assign = makeOp({
	  args:["array", "array"],
	  body: {args:["a", "b"], body:"a=b"},
	  funcName: "assign" });

	exports.assigns = makeOp({
	  args:["array", "scalar"],
	  body: {args:["a", "b"], body:"a=b"},
	  funcName: "assigns" });


	exports.equals = compile({
	  args:["array", "array"],
	  pre: EmptyProc,
	  body: {args:[{name:"x", lvalue:false, rvalue:true, count:1},
	               {name:"y", lvalue:false, rvalue:true, count:1}], 
	        body: "if(x!==y){return false}", 
	        localVars: [], 
	        thisVars: []},
	  post: {args:[], localVars:[], thisVars:[], body:"return true"},
	  funcName: "equals"
	});
	}(ndarrayOps));

	function iota$1(n) {
	  var result = new Array(n);
	  for(var i=0; i<n; ++i) {
	    result[i] = i;
	  }
	  return result
	}

	var iota_1 = iota$1;

	/*!
	 * Determine if an object is a Buffer
	 *
	 * @author   Feross Aboukhadijeh <https://feross.org>
	 * @license  MIT
	 */

	// The _isBuffer check is for Safari 5-7 support, because it's missing
	// Object.prototype.constructor. Remove this eventually
	var isBuffer_1 = function (obj) {
	  return obj != null && (isBuffer$1(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
	};

	function isBuffer$1 (obj) {
	  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	}

	// For Node v0.10 support. Remove this eventually.
	function isSlowBuffer (obj) {
	  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer$1(obj.slice(0, 0))
	}

	var iota = iota_1;
	var isBuffer = isBuffer_1;

	var hasTypedArrays  = ((typeof Float64Array) !== "undefined");

	function compare1st(a, b) {
	  return a[0] - b[0]
	}

	function order() {
	  var stride = this.stride;
	  var terms = new Array(stride.length);
	  var i;
	  for(i=0; i<terms.length; ++i) {
	    terms[i] = [Math.abs(stride[i]), i];
	  }
	  terms.sort(compare1st);
	  var result = new Array(terms.length);
	  for(i=0; i<result.length; ++i) {
	    result[i] = terms[i][1];
	  }
	  return result
	}

	function compileConstructor(dtype, dimension) {
	  var className = ["View", dimension, "d", dtype].join("");
	  if(dimension < 0) {
	    className = "View_Nil" + dtype;
	  }
	  var useGetters = (dtype === "generic");

	  if(dimension === -1) {
	    //Special case for trivial arrays
	    var code =
	      "function "+className+"(a){this.data=a;};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return -1};\
proto.size=0;\
proto.dimension=-1;\
proto.shape=proto.stride=proto.order=[];\
proto.lo=proto.hi=proto.transpose=proto.step=\
function(){return new "+className+"(this.data);};\
proto.get=proto.set=function(){};\
proto.pick=function(){return null};\
return function construct_"+className+"(a){return new "+className+"(a);}";
	    var procedure = new Function(code);
	    return procedure()
	  } else if(dimension === 0) {
	    //Special case for 0d arrays
	    var code =
	      "function "+className+"(a,d) {\
this.data = a;\
this.offset = d\
};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return this.offset};\
proto.dimension=0;\
proto.size=1;\
proto.shape=\
proto.stride=\
proto.order=[];\
proto.lo=\
proto.hi=\
proto.transpose=\
proto.step=function "+className+"_copy() {\
return new "+className+"(this.data,this.offset)\
};\
proto.pick=function "+className+"_pick(){\
return TrivialArray(this.data);\
};\
proto.valueOf=proto.get=function "+className+"_get(){\
return "+(useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]")+
	"};\
proto.set=function "+className+"_set(v){\
return "+(useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v")+"\
};\
return function construct_"+className+"(a,b,c,d){return new "+className+"(a,d)}";
	    var procedure = new Function("TrivialArray", code);
	    return procedure(CACHED_CONSTRUCTORS[dtype][0])
	  }

	  var code = ["'use strict'"];

	  //Create constructor for view
	  var indices = iota(dimension);
	  var args = indices.map(function(i) { return "i"+i });
	  var index_str = "this.offset+" + indices.map(function(i) {
	        return "this.stride[" + i + "]*i" + i
	      }).join("+");
	  var shapeArg = indices.map(function(i) {
	      return "b"+i
	    }).join(",");
	  var strideArg = indices.map(function(i) {
	      return "c"+i
	    }).join(",");
	  code.push(
	    "function "+className+"(a," + shapeArg + "," + strideArg + ",d){this.data=a",
	      "this.shape=[" + shapeArg + "]",
	      "this.stride=[" + strideArg + "]",
	      "this.offset=d|0}",
	    "var proto="+className+".prototype",
	    "proto.dtype='"+dtype+"'",
	    "proto.dimension="+dimension);

	  //view.size:
	  code.push("Object.defineProperty(proto,'size',{get:function "+className+"_size(){\
return "+indices.map(function(i) { return "this.shape["+i+"]" }).join("*"),
	"}})");

	  //view.order:
	  if(dimension === 1) {
	    code.push("proto.order=[0]");
	  } else {
	    code.push("Object.defineProperty(proto,'order',{get:");
	    if(dimension < 4) {
	      code.push("function "+className+"_order(){");
	      if(dimension === 2) {
	        code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})");
	      } else if(dimension === 3) {
	        code.push(
	"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\
if(s0>s1){\
if(s1>s2){\
return [2,1,0];\
}else if(s0>s2){\
return [1,2,0];\
}else{\
return [1,0,2];\
}\
}else if(s0>s2){\
return [2,0,1];\
}else if(s2>s1){\
return [0,1,2];\
}else{\
return [0,2,1];\
}}})");
	      }
	    } else {
	      code.push("ORDER})");
	    }
	  }

	  //view.set(i0, ..., v):
	  code.push(
	"proto.set=function "+className+"_set("+args.join(",")+",v){");
	  if(useGetters) {
	    code.push("return this.data.set("+index_str+",v)}");
	  } else {
	    code.push("return this.data["+index_str+"]=v}");
	  }

	  //view.get(i0, ...):
	  code.push("proto.get=function "+className+"_get("+args.join(",")+"){");
	  if(useGetters) {
	    code.push("return this.data.get("+index_str+")}");
	  } else {
	    code.push("return this.data["+index_str+"]}");
	  }

	  //view.index:
	  code.push(
	    "proto.index=function "+className+"_index(", args.join(), "){return "+index_str+"}");

	  //view.hi():
	  code.push("proto.hi=function "+className+"_hi("+args.join(",")+"){return new "+className+"(this.data,"+
	    indices.map(function(i) {
	      return ["(typeof i",i,"!=='number'||i",i,"<0)?this.shape[", i, "]:i", i,"|0"].join("")
	    }).join(",")+","+
	    indices.map(function(i) {
	      return "this.stride["+i + "]"
	    }).join(",")+",this.offset)}");

	  //view.lo():
	  var a_vars = indices.map(function(i) { return "a"+i+"=this.shape["+i+"]" });
	  var c_vars = indices.map(function(i) { return "c"+i+"=this.stride["+i+"]" });
	  code.push("proto.lo=function "+className+"_lo("+args.join(",")+"){var b=this.offset,d=0,"+a_vars.join(",")+","+c_vars.join(","));
	  for(var i=0; i<dimension; ++i) {
	    code.push(
	"if(typeof i"+i+"==='number'&&i"+i+">=0){\
d=i"+i+"|0;\
b+=c"+i+"*d;\
a"+i+"-=d}");
	  }
	  code.push("return new "+className+"(this.data,"+
	    indices.map(function(i) {
	      return "a"+i
	    }).join(",")+","+
	    indices.map(function(i) {
	      return "c"+i
	    }).join(",")+",b)}");

	  //view.step():
	  code.push("proto.step=function "+className+"_step("+args.join(",")+"){var "+
	    indices.map(function(i) {
	      return "a"+i+"=this.shape["+i+"]"
	    }).join(",")+","+
	    indices.map(function(i) {
	      return "b"+i+"=this.stride["+i+"]"
	    }).join(",")+",c=this.offset,d=0,ceil=Math.ceil");
	  for(var i=0; i<dimension; ++i) {
	    code.push(
	"if(typeof i"+i+"==='number'){\
d=i"+i+"|0;\
if(d<0){\
c+=b"+i+"*(a"+i+"-1);\
a"+i+"=ceil(-a"+i+"/d)\
}else{\
a"+i+"=ceil(a"+i+"/d)\
}\
b"+i+"*=d\
}");
	  }
	  code.push("return new "+className+"(this.data,"+
	    indices.map(function(i) {
	      return "a" + i
	    }).join(",")+","+
	    indices.map(function(i) {
	      return "b" + i
	    }).join(",")+",c)}");

	  //view.transpose():
	  var tShape = new Array(dimension);
	  var tStride = new Array(dimension);
	  for(var i=0; i<dimension; ++i) {
	    tShape[i] = "a[i"+i+"]";
	    tStride[i] = "b[i"+i+"]";
	  }
	  code.push("proto.transpose=function "+className+"_transpose("+args+"){"+
	    args.map(function(n,idx) { return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)"}).join(";"),
	    "var a=this.shape,b=this.stride;return new "+className+"(this.data,"+tShape.join(",")+","+tStride.join(",")+",this.offset)}");

	  //view.pick():
	  code.push("proto.pick=function "+className+"_pick("+args+"){var a=[],b=[],c=this.offset");
	  for(var i=0; i<dimension; ++i) {
	    code.push("if(typeof i"+i+"==='number'&&i"+i+">=0){c=(c+this.stride["+i+"]*i"+i+")|0}else{a.push(this.shape["+i+"]);b.push(this.stride["+i+"])}");
	  }
	  code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}");

	  //Add return statement
	  code.push("return function construct_"+className+"(data,shape,stride,offset){return new "+className+"(data,"+
	    indices.map(function(i) {
	      return "shape["+i+"]"
	    }).join(",")+","+
	    indices.map(function(i) {
	      return "stride["+i+"]"
	    }).join(",")+",offset)}");

	  //Compile procedure
	  var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"));
	  return procedure(CACHED_CONSTRUCTORS[dtype], order)
	}

	function arrayDType(data) {
	  if(isBuffer(data)) {
	    return "buffer"
	  }
	  if(hasTypedArrays) {
	    switch(Object.prototype.toString.call(data)) {
	      case "[object Float64Array]":
	        return "float64"
	      case "[object Float32Array]":
	        return "float32"
	      case "[object Int8Array]":
	        return "int8"
	      case "[object Int16Array]":
	        return "int16"
	      case "[object Int32Array]":
	        return "int32"
	      case "[object Uint8Array]":
	        return "uint8"
	      case "[object Uint16Array]":
	        return "uint16"
	      case "[object Uint32Array]":
	        return "uint32"
	      case "[object Uint8ClampedArray]":
	        return "uint8_clamped"
	      case "[object BigInt64Array]":
	        return "bigint64"
	      case "[object BigUint64Array]":
	        return "biguint64"
	    }
	  }
	  if(Array.isArray(data)) {
	    return "array"
	  }
	  return "generic"
	}

	var CACHED_CONSTRUCTORS = {
	  "float32":[],
	  "float64":[],
	  "int8":[],
	  "int16":[],
	  "int32":[],
	  "uint8":[],
	  "uint16":[],
	  "uint32":[],
	  "array":[],
	  "uint8_clamped":[],
	  "bigint64": [],
	  "biguint64": [],
	  "buffer":[],
	  "generic":[]
	}

	;
	function wrappedNDArrayCtor(data, shape, stride, offset) {
	  if(data === undefined) {
	    var ctor = CACHED_CONSTRUCTORS.array[0];
	    return ctor([])
	  } else if(typeof data === "number") {
	    data = [data];
	  }
	  if(shape === undefined) {
	    shape = [ data.length ];
	  }
	  var d = shape.length;
	  if(stride === undefined) {
	    stride = new Array(d);
	    for(var i=d-1, sz=1; i>=0; --i) {
	      stride[i] = sz;
	      sz *= shape[i];
	    }
	  }
	  if(offset === undefined) {
	    offset = 0;
	    for(var i=0; i<d; ++i) {
	      if(stride[i] < 0) {
	        offset -= (shape[i]-1)*stride[i];
	      }
	    }
	  }
	  var dtype = arrayDType(data);
	  var ctor_list = CACHED_CONSTRUCTORS[dtype];
	  while(ctor_list.length <= d+1) {
	    ctor_list.push(compileConstructor(dtype, ctor_list.length-1));
	  }
	  var ctor = ctor_list[d+1];
	  return ctor(data, shape, stride, offset)
	}

	var ndarray$1 = wrappedNDArrayCtor;

	var pool = pool$1;
	var ops = ndarrayOps;
	var ndarray = ndarray$1;

	var SUPPORTED_TYPES = [
	  "uint8",
	  "uint8_clamped",
	  "uint16",
	  "uint32",
	  "int8",
	  "int16",
	  "int32",
	  "float32" ];

	function GLBuffer(gl, type, handle, length, usage) {
	  this.gl = gl;
	  this.type = type;
	  this.handle = handle;
	  this.length = length;
	  this.usage = usage;
	}

	var proto = GLBuffer.prototype;

	proto.bind = function() {
	  this.gl.bindBuffer(this.type, this.handle);
	};

	proto.unbind = function() {
	  this.gl.bindBuffer(this.type, null);
	};

	proto.dispose = function() {
	  this.gl.deleteBuffer(this.handle);
	};

	function updateTypeArray(gl, type, len, usage, data, offset) {
	  var dataLen = data.length * data.BYTES_PER_ELEMENT;
	  if(offset < 0) {
	    gl.bufferData(type, data, usage);
	    return dataLen
	  }
	  if(dataLen + offset > len) {
	    throw new Error("gl-buffer: If resizing buffer, must not specify offset")
	  }
	  gl.bufferSubData(type, offset, data);
	  return len
	}

	function makeScratchTypeArray(array, dtype) {
	  var res = pool.malloc(array.length, dtype);
	  var n = array.length;
	  for(var i=0; i<n; ++i) {
	    res[i] = array[i];
	  }
	  return res
	}

	function isPacked(shape, stride) {
	  var n = 1;
	  for(var i=stride.length-1; i>=0; --i) {
	    if(stride[i] !== n) {
	      return false
	    }
	    n *= shape[i];
	  }
	  return true
	}

	proto.update = function(array, offset) {
	  if(typeof offset !== "number") {
	    offset = -1;
	  }
	  this.bind();
	  if(typeof array === "object" && typeof array.shape !== "undefined") { //ndarray
	    var dtype = array.dtype;
	    if(SUPPORTED_TYPES.indexOf(dtype) < 0) {
	      dtype = "float32";
	    }
	    if(this.type === this.gl.ELEMENT_ARRAY_BUFFER) {
	      var ext = gl.getExtension('OES_element_index_uint');
	      if(ext && dtype !== "uint16") {
	        dtype = "uint32";
	      } else {
	        dtype = "uint16";
	      }
	    }
	    if(dtype === array.dtype && isPacked(array.shape, array.stride)) {
	      if(array.offset === 0 && array.data.length === array.shape[0]) {
	        this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, array.data, offset);
	      } else {
	        this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, array.data.subarray(array.offset, array.shape[0]), offset);
	      }
	    } else {
	      var tmp = pool.malloc(array.size, dtype);
	      var ndt = ndarray(tmp, array.shape);
	      ops.assign(ndt, array);
	      if(offset < 0) {
	        this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, tmp, offset);
	      } else {
	        this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, tmp.subarray(0, array.size), offset);
	      }
	      pool.free(tmp);
	    }
	  } else if(Array.isArray(array)) { //Vanilla array
	    var t;
	    if(this.type === this.gl.ELEMENT_ARRAY_BUFFER) {
	      t = makeScratchTypeArray(array, "uint16");
	    } else {
	      t = makeScratchTypeArray(array, "float32");
	    }
	    if(offset < 0) {
	      this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, t, offset);
	    } else {
	      this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, t.subarray(0, array.length), offset);
	    }
	    pool.free(t);
	  } else if(typeof array === "object" && typeof array.length === "number") { //Typed array
	    this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, array, offset);
	  } else if(typeof array === "number" || array === undefined) { //Number/default
	    if(offset >= 0) {
	      throw new Error("gl-buffer: Cannot specify offset when resizing buffer")
	    }
	    array = array | 0;
	    if(array <= 0) {
	      array = 1;
	    }
	    this.gl.bufferData(this.type, array|0, this.usage);
	    this.length = array;
	  } else { //Error, case should not happen
	    throw new Error("gl-buffer: Invalid data type")
	  }
	};

	function createBuffer$1(gl, data, type, usage) {
	  type = type || gl.ARRAY_BUFFER;
	  usage = usage || gl.DYNAMIC_DRAW;
	  if(type !== gl.ARRAY_BUFFER && type !== gl.ELEMENT_ARRAY_BUFFER) {
	    throw new Error("gl-buffer: Invalid type for webgl buffer, must be either gl.ARRAY_BUFFER or gl.ELEMENT_ARRAY_BUFFER")
	  }
	  if(usage !== gl.DYNAMIC_DRAW && usage !== gl.STATIC_DRAW && usage !== gl.STREAM_DRAW) {
	    throw new Error("gl-buffer: Invalid usage for buffer, must be either gl.DYNAMIC_DRAW, gl.STATIC_DRAW or gl.STREAM_DRAW")
	  }
	  var handle = gl.createBuffer();
	  var result = new GLBuffer(gl, type, handle, 0, usage);
	  result.update(data);
	  return result
	}

	var buffer = createBuffer$1;

	function doBind(gl, elements, attributes) {
	  if(elements) {
	    elements.bind();
	  } else {
	    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
	  }
	  var nattribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS)|0;
	  if(attributes) {
	    if(attributes.length > nattribs) {
	      throw new Error("gl-vao: Too many vertex attributes")
	    }
	    for(var i=0; i<attributes.length; ++i) {
	      var attrib = attributes[i];
	      if(attrib.buffer) {
	        var buffer = attrib.buffer;
	        var size = attrib.size || 4;
	        var type = attrib.type || gl.FLOAT;
	        var normalized = !!attrib.normalized;
	        var stride = attrib.stride || 0;
	        var offset = attrib.offset || 0;
	        buffer.bind();
	        gl.enableVertexAttribArray(i);
	        gl.vertexAttribPointer(i, size, type, normalized, stride, offset);
	      } else {
	        if(typeof attrib === "number") {
	          gl.vertexAttrib1f(i, attrib);
	        } else if(attrib.length === 1) {
	          gl.vertexAttrib1f(i, attrib[0]);
	        } else if(attrib.length === 2) {
	          gl.vertexAttrib2f(i, attrib[0], attrib[1]);
	        } else if(attrib.length === 3) {
	          gl.vertexAttrib3f(i, attrib[0], attrib[1], attrib[2]);
	        } else if(attrib.length === 4) {
	          gl.vertexAttrib4f(i, attrib[0], attrib[1], attrib[2], attrib[3]);
	        } else {
	          throw new Error("gl-vao: Invalid vertex attribute")
	        }
	        gl.disableVertexAttribArray(i);
	      }
	    }
	    for(; i<nattribs; ++i) {
	      gl.disableVertexAttribArray(i);
	    }
	  } else {
	    gl.bindBuffer(gl.ARRAY_BUFFER, null);
	    for(var i=0; i<nattribs; ++i) {
	      gl.disableVertexAttribArray(i);
	    }
	  }
	}

	var doBind_1 = doBind;

	var bindAttribs$1 = doBind_1;

	function VertexAttribute(location, dimension, a, b, c, d) {
	  this.location = location;
	  this.dimension = dimension;
	  this.a = a;
	  this.b = b;
	  this.c = c;
	  this.d = d;
	}

	VertexAttribute.prototype.bind = function(gl) {
	  switch(this.dimension) {
	    case 1:
	      gl.vertexAttrib1f(this.location, this.a);
	    break
	    case 2:
	      gl.vertexAttrib2f(this.location, this.a, this.b);
	    break
	    case 3:
	      gl.vertexAttrib3f(this.location, this.a, this.b, this.c);
	    break
	    case 4:
	      gl.vertexAttrib4f(this.location, this.a, this.b, this.c, this.d);
	    break
	  }
	};

	function VAONative(gl, ext, handle) {
	  this.gl = gl;
	  this._ext = ext;
	  this.handle = handle;
	  this._attribs = [];
	  this._useElements = false;
	  this._elementsType = gl.UNSIGNED_SHORT;
	}

	VAONative.prototype.bind = function() {
	  this._ext.bindVertexArrayOES(this.handle);
	  for(var i=0; i<this._attribs.length; ++i) {
	    this._attribs[i].bind(this.gl);
	  }
	};

	VAONative.prototype.unbind = function() {
	  this._ext.bindVertexArrayOES(null);
	};

	VAONative.prototype.dispose = function() {
	  this._ext.deleteVertexArrayOES(this.handle);
	};

	VAONative.prototype.update = function(attributes, elements, elementsType) {
	  this.bind();
	  bindAttribs$1(this.gl, elements, attributes);
	  this.unbind();
	  this._attribs.length = 0;
	  if(attributes)
	  for(var i=0; i<attributes.length; ++i) {
	    var a = attributes[i];
	    if(typeof a === "number") {
	      this._attribs.push(new VertexAttribute(i, 1, a));
	    } else if(Array.isArray(a)) {
	      this._attribs.push(new VertexAttribute(i, a.length, a[0], a[1], a[2], a[3]));
	    }
	  }
	  this._useElements = !!elements;
	  this._elementsType = elementsType || this.gl.UNSIGNED_SHORT;
	};

	VAONative.prototype.draw = function(mode, count, offset) {
	  offset = offset || 0;
	  var gl = this.gl;
	  if(this._useElements) {
	    gl.drawElements(mode, count, this._elementsType, offset);
	  } else {
	    gl.drawArrays(mode, offset, count);
	  }
	};

	function createVAONative$1(gl, ext) {
	  return new VAONative(gl, ext, ext.createVertexArrayOES())
	}

	var vaoNative = createVAONative$1;

	var bindAttribs = doBind_1;

	function VAOEmulated(gl) {
	  this.gl = gl;
	  this._elements = null;
	  this._attributes = null;
	  this._elementsType = gl.UNSIGNED_SHORT;
	}

	VAOEmulated.prototype.bind = function() {
	  bindAttribs(this.gl, this._elements, this._attributes);
	};

	VAOEmulated.prototype.update = function(attributes, elements, elementsType) {
	  this._elements = elements;
	  this._attributes = attributes;
	  this._elementsType = elementsType || this.gl.UNSIGNED_SHORT;
	};

	VAOEmulated.prototype.dispose = function() { };
	VAOEmulated.prototype.unbind = function() { };

	VAOEmulated.prototype.draw = function(mode, count, offset) {
	  offset = offset || 0;
	  var gl = this.gl;
	  if(this._elements) {
	    gl.drawElements(mode, count, this._elementsType, offset);
	  } else {
	    gl.drawArrays(mode, offset, count);
	  }
	};

	function createVAOEmulated$1(gl) {
	  return new VAOEmulated(gl)
	}

	var vaoEmulated = createVAOEmulated$1;

	var createVAONative = vaoNative;
	var createVAOEmulated = vaoEmulated;

	function ExtensionShim (gl) {
	  this.bindVertexArrayOES = gl.bindVertexArray.bind(gl);
	  this.createVertexArrayOES = gl.createVertexArray.bind(gl);
	  this.deleteVertexArrayOES = gl.deleteVertexArray.bind(gl);
	}

	function createVAO$1(gl, attributes, elements, elementsType) {
	  var ext = gl.createVertexArray
	    ? new ExtensionShim(gl)
	    : gl.getExtension('OES_vertex_array_object');
	  var vao;

	  if(ext) {
	    vao = createVAONative(gl, ext);
	  } else {
	    vao = createVAOEmulated(gl);
	  }
	  vao.update(attributes, elements, elementsType);
	  return vao
	}

	var vao = createVAO$1;

	var createBuffer = buffer;
	var createVAO = vao;
	var createShader$1 = glBasicShader.exports;

	function BasicMesh(gl, options) {
	    if (!(this instanceof BasicMesh))
	        return new BasicMesh(gl, options)
	    
	    options = options||{};

	    this.gl = gl;

	    var usage = typeof options.usage === 'number' ? options.usage : gl.STATIC_DRAW;
	    var attribs = [];
	        
	    //position 
	    var positionSize = options.positionSize || 3;

	    //default positions to empty array
	    if (options.positions !== 0 && !options.positions) {
	        options.positions = new Float32Array();
	    }  

	    //positions is expected
	    this.positions = createBuffer(gl, options.positions, gl.ARRAY_BUFFER, usage);
	    attribs.push({
	        buffer: this.positions,
	        size: positionSize
	    });
	    this.drawCount = this.positions.length / 4 / positionSize;

	    if (options.colors) {
	        var colorSize = options.colorSize || 4;
	        this.colors = createBuffer(gl, options.colors, gl.ARRAY_BUFFER, usage);
	        attribs.push({
	            buffer: this.colors,
	            size: colorSize,
	            normalized: true
	        });
	    }
	    if (options.normals) {
	        this.normals = createBuffer(gl, options.normals, gl.ARRAY_BUFFER, usage);
	        attribs.push({
	            buffer: this.normals,
	            size: 3,
	            normalized: false
	        });
	    }
	    if (options.texcoords) {
	        this.texcoords = createBuffer(gl, options.texcoords, gl.ARRAY_BUFFER, usage);
	        attribs.push({
	            buffer: this.texcoords,
	            size: 2,
	            normalized: false
	        });
	    }

	    if (options.elements) {
	        this.elements = createBuffer(gl, options.elements, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW);
	        this.drawCount = this.elements.length / 2;
	    }

	    this.vao = createVAO(gl, attribs, this.elements);

	    var shader = options.shader;
	    if (!shader) {
	        this.defaultShader = createShader$1(gl, {
	            normal: Boolean(options.normals),
	            color: Boolean(options.colors),
	            texcoord: options.texcoords ? 1 : 0
	        });
	        shader = this.defaultShader;
	    }
	    this.shader = shader;
	}

	BasicMesh.prototype.bind = function() {
	    this.shader.bind();
	    this.vao.bind();
	};

	BasicMesh.prototype.unbind = function() {
	    this.vao.unbind();
	};

	BasicMesh.prototype.draw = function(mode, count, offset) {
	    //for convenience, try to render all vertices or elements 
	    //if the user hasn't specified a number
	    count = typeof count === 'number' ? count : this.drawCount;
	    this.vao.draw(typeof mode === 'number' ? mode : this.gl.TRIANGLES, count, offset || 0);
	};

	BasicMesh.prototype.dispose = function() {
	    if (this.defaultShader) {
	        this.defaultShader.dispose();
	        this.defaultShader = null;
	    }
	    this.vao.dispose();
	    this.positions.dispose();
	    if (this.texcoords) this.texcoords.dispose();
	    if (this.colors) this.colors.dispose();
	    if (this.normals) this.normals.dispose();
	    this.gl = null;
	};

	var glBasicMesh = BasicMesh;

	var TextRenderer = fontpathSimpleRenderer;
	var createShader = glBasicShader.exports;
	var inherits = inherits_browser.exports;

	//require only the math we really need..
	var mat4 = {
	    create: create_1,
	    identity: identity_1,
	    translate: translate_1,
	    scale: scale_1
	};

	var createMesh = glBasicMesh;

	var tmp3 = [ 0, 0, 0 ];

	function TriangleRenderer(gl, options) {
	    if (!(this instanceof TriangleRenderer))
	        return new TriangleRenderer(gl, options)
	    options = options||{};

	    TextRenderer.call(this, options);

	    if (!gl)
	        throw 'must specify gl parameter'
	    this.gl = gl;
	    this.mode = typeof options.mode === 'number' ? options.mode : gl.TRIANGLES;

	    this.projection = mat4.create();
	    this.view = mat4.create();

	    this.simplifyAmount = typeof options.simplifyAmount === 'number' ? options.simplifyAmount : 0.02;

	    this.color = options.color || [1, 1, 1, 1];
	    var shader = options.shader;
	    if (!shader) {
	        this.defaultShader = createShader(gl);
	        shader = this.defaultShader;
	    }
	    this.shader = shader;

	    this.meshCache = {};
	}

	//inherits from TextRenderer
	inherits(TriangleRenderer, TextRenderer);

	TriangleRenderer.prototype.triangulateGlyph = function(glyph) {
	    throw new Error('this method should be implemented by subclasses')
	};

	TriangleRenderer.prototype._drawGlyph = function(data) {
	    var chr = String.fromCharCode(data.charCode);
	    var cached = this.meshCache[ chr ];
	    if (!cached) {
	        var triangulated = this.triangulateGlyph(data.glyph);

	        var newMesh = createMesh(this.gl, {
	            positions: triangulated.positions,
	            positionSize: 2,
	            elements: triangulated.cells,
	            shader: this.shader
	        });

	        cached = {
	            mesh: newMesh,
	            modelTransform: mat4.create()
	        };

	        this.meshCache[chr] = cached;
	    }

	    var mesh = cached.mesh;
	    mesh.bind();

	    var modelTransform = cached.modelTransform;
	    mat4.identity( modelTransform );

	    tmp3[0] = data.position[0];
	    tmp3[1] = data.position[1];
	    tmp3[2] = 0;
	    mat4.translate( modelTransform, modelTransform, tmp3 );

	    tmp3[0] = data.scale[0];
	    tmp3[1] = data.scale[1];
	    tmp3[3] = 1;
	    mat4.scale( modelTransform, modelTransform, tmp3 );

	    mesh.shader.uniforms;
	        var uTypes = mesh.shader.types.uniforms;
	    
	    if (uTypes.tint) mesh.shader.uniforms.tint = this.color;
	    if (uTypes.model) mesh.shader.uniforms.model = modelTransform;
	    if (uTypes.projection) mesh.shader.uniforms.projection = this.projection;
	    if (uTypes.view) mesh.shader.uniforms.view = this.view;
	    
	    mesh.draw(this.mode);

	    mesh.unbind();
	};

	TriangleRenderer.prototype.draw = function(x, y, start, end) {
	    var result = this.render(x, y, start, end);

	    for (var i=0; i<result.underlines.length; i++) {
	        //TODO: maybe use gl-sprite-batch for underlines?
	    }
	    for (i=0; i<result.glyphs.length; i++) {
	        var g = result.glyphs[i];
	        this._drawGlyph(g);
	    }
	};

	TriangleRenderer.prototype.dispose = function() {
	    for (var k in this.meshCache) {
	        this.meshCache[k].mesh.dispose();
	    }
	    this.meshCache = null;
	    if (this.defaultShader) {
	        this.defaultShader.dispose();
	        this.defaultShader = null;
	    }
	    this.gl = null;
	};

	var base = TriangleRenderer;

	function Vector2$1(x, y) {
		if (typeof x === "object") {
	        this.x = x.x||0;
	        this.y = x.y||0;
	    } else {
	        this.x = x||0;
	        this.y = y||0;
	    }
	}

	//shorthand it for better minification
	var vec2 = Vector2$1.prototype;

	/**
	 * Returns a new instance of Vector2 with
	 * this vector's components. 
	 * @return {Vector2} a clone of this vector
	 */
	vec2.clone = function() {
	    return new Vector2$1(this.x, this.y);
	};

	/**
	 * Copies the x, y components from the specified
	 * Vector. Any undefined components from `otherVec`
	 * will default to zero.
	 * 
	 * @param  {otherVec} the other Vector2 to copy
	 * @return {Vector2}  this, for chaining
	 */
	vec2.copy = function(otherVec) {
	    this.x = otherVec.x||0;
	    this.y = otherVec.y||0;
	    return this;
	};

	/**
	 * A convenience function to set the components of
	 * this vector as x and y. Falsy or undefined
	 * parameters will default to zero.
	 *
	 * You can also pass a vector object instead of
	 * individual components, to copy the object's components.
	 * 
	 * @param {Number} x the x component
	 * @param {Number} y the y component
	 * @return {Vector2}  this, for chaining
	 */
	vec2.set = function(x, y) {
	    if (typeof x === "object") {
	        this.x = x.x||0;
	        this.y = x.y||0;
	    } else {
	        this.x = x||0;
	        this.y = y||0;
	    }
	    return this;
	};

	vec2.add = function(v) {
	    this.x += v.x;
	    this.y += v.y;
	    return this;
	};

	vec2.subtract = function(v) {
	    this.x -= v.x;
	    this.y -= v.y;
	    return this;
	};

	vec2.multiply = function(v) {
	    this.x *= v.x;
	    this.y *= v.y;
	    return this;
	};

	vec2.scale = function(s) {
	    this.x *= s;
	    this.y *= s;
	    return this;
	};

	vec2.divide = function(v) {
	    this.x /= v.x;
	    this.y /= v.y;
	    return this;
	};

	vec2.negate = function() {
	    this.x = -this.x;
	    this.y = -this.y;
	    return this;
	};

	vec2.distance = function(v) {
	    var dx = v.x - this.x,
	        dy = v.y - this.y;
	    return Math.sqrt(dx*dx + dy*dy);
	};

	vec2.distanceSq = function(v) {
	    var dx = v.x - this.x,
	        dy = v.y - this.y;
	    return dx*dx + dy*dy;
	};

	vec2.length = function() {
	    var x = this.x,
	        y = this.y;
	    return Math.sqrt(x*x + y*y);
	};

	vec2.lengthSq = function() {
	    var x = this.x,
	        y = this.y;
	    return x*x + y*y;
	};

	vec2.normalize = function() {
	    var x = this.x,
	        y = this.y;
	    var len = x*x + y*y;
	    if (len > 0) {
	        len = 1 / Math.sqrt(len);
	        this.x = x*len;
	        this.y = y*len;
	    }
	    return this;
	};

	vec2.dot = function(v) {
	    return this.x * v.x + this.y * v.y;
	};

	//Unlike Vector3, this returns a scalar
	//http://allenchou.net/2013/07/cross-product-of-2d-vectors/
	vec2.cross = function(v) {
	    return this.x * v.y - this.y * v.x;
	};

	vec2.lerp = function(v, t) {
	    var ax = this.x,
	        ay = this.y;
	    t = t||0;
	    this.x = ax + t * (v.x - ax);
	    this.y = ay + t * (v.y - ay);
	    return this;
	};

	vec2.transformMat3 = function(mat) {
	    var x = this.x, y = this.y, m = mat.val;
	    this.x = m[0] * x + m[3] * y + m[6];
	    this.y = m[1] * x + m[4] * y + m[7];
	    return this;
	};

	vec2.transformMat4 = function(mat) {
	    var x = this.x, 
	        y = this.y,
	        m = mat.val;
	    this.x = m[0] * x + m[4] * y + m[12];
	    this.y = m[1] * x + m[5] * y + m[13];
	    return this;
	};

	vec2.reset = function() {
	    this.x = 0;
	    this.y = 0;
	    return this;
	};

	vec2.sub = vec2.subtract;

	vec2.mul = vec2.multiply;

	vec2.div = vec2.divide;

	vec2.dist = vec2.distance;

	vec2.distSq = vec2.distanceSq;

	vec2.len = vec2.length;

	vec2.lenSq = vec2.lengthSq;

	vec2.toString = function() {
	    return 'Vector2(' + this.x + ', ' + this.y + ')';
	};

	vec2.random = function(scale) {
	    scale = scale || 1.0;
	    var r = Math.random() * 2.0 * Math.PI;
	    this.x = Math.cos(r) * scale;
	    this.y = Math.sin(r) * scale;
	    return this;
	};

	vec2.str = vec2.toString;

	var Vector2_1 = Vector2$1;

	function hasGetterOrSetter(def) {
		return (!!def.get && typeof def.get === "function") || (!!def.set && typeof def.set === "function");
	}

	function getProperty(definition, k, isClassDescriptor) {
		//This may be a lightweight object, OR it might be a property
		//that was defined previously.
		
		//For simple class descriptors we can just assume its NOT previously defined.
		var def = isClassDescriptor 
					? definition[k] 
					: Object.getOwnPropertyDescriptor(definition, k);

		if (!isClassDescriptor && def.value && typeof def.value === "object") {
			def = def.value;
		}


		//This might be a regular property, or it may be a getter/setter the user defined in a class.
		if ( def && hasGetterOrSetter(def) ) {
			if (typeof def.enumerable === "undefined")
				def.enumerable = true;
			if (typeof def.configurable === "undefined")
				def.configurable = true;
			return def;
		} else {
			return false;
		}
	}

	function hasNonConfigurable(obj, k) {
		var prop = Object.getOwnPropertyDescriptor(obj, k);
		if (!prop)
			return false;

		if (prop.value && typeof prop.value === "object")
			prop = prop.value;

		if (prop.configurable === false) 
			return true;

		return false;
	}

	//TODO: On create, 
	//		On mixin, 

	function extend$1(ctor, definition, isClassDescriptor, extend) {
		for (var k in definition) {
			if (!definition.hasOwnProperty(k))
				continue;

			var def = getProperty(definition, k, isClassDescriptor);

			if (def !== false) {
				//If Extends is used, we will check its prototype to see if 
				//the final variable exists.
				
				var parent = extend || ctor;
				if (hasNonConfigurable(parent.prototype, k)) {

					//just skip the final property
					if (Class$1.ignoreFinals)
						continue;

					//We cannot re-define a property that is configurable=false.
					//So we will consider them final and throw an error. This is by
					//default so it is clear to the developer what is happening.
					//You can set ignoreFinals to true if you need to extend a class
					//which has configurable=false; it will simply not re-define final properties.
					throw new Error("cannot override final property '"+k
								+"', set Class.ignoreFinals = true to skip");
				}

				Object.defineProperty(ctor.prototype, k, def);
			} else {
				ctor.prototype[k] = definition[k];
			}

		}
	}

	/**
	 */
	function mixin(myClass, mixins) {
		if (!mixins)
			return;

		if (!Array.isArray(mixins))
			mixins = [mixins];

		for (var i=0; i<mixins.length; i++) {
			extend$1(myClass, mixins[i].prototype || mixins[i]);
		}
	}

	/**
	 * Creates a new class with the given descriptor.
	 * The constructor, defined by the name `initialize`,
	 * is an optional function. If unspecified, an anonymous
	 * function will be used which calls the parent class (if
	 * one exists). 
	 *
	 * You can also use `Extends` and `Mixins` to provide subclassing
	 * and inheritance.
	 *
	 * @class  Class
	 * @constructor
	 * @param {Object} definition a dictionary of functions for the class
	 * @example
	 *
	 * 		var MyClass = new Class({
	 * 		
	 * 			initialize: function() {
	 * 				this.foo = 2.0;
	 * 			},
	 *
	 * 			bar: function() {
	 * 				return this.foo + 5;
	 * 			}
	 * 		});
	 */
	function Class$1(definition) {
		if (!definition)
			definition = {};

		//The variable name here dictates what we see in Chrome debugger
		var initialize;
		var Extends;

		if (definition.initialize) {
			if (typeof definition.initialize !== "function")
				throw new Error("initialize must be a function");
			initialize = definition.initialize;

			//Usually we should avoid "delete" in V8 at all costs.
			//However, its unlikely to make any performance difference
			//here since we only call this on class creation (i.e. not object creation).
			delete definition.initialize;
		} else {
			if (definition.Extends) {
				var base = definition.Extends;
				initialize = function () {
					base.apply(this, arguments);
				}; 
			} else {
				initialize = function () {}; 
			}
		}

		if (definition.Extends) {
			initialize.prototype = Object.create(definition.Extends.prototype);
			initialize.prototype.constructor = initialize;
			//for getOwnPropertyDescriptor to work, we need to act
			//directly on the Extends (or Mixin)
			Extends = definition.Extends;
			delete definition.Extends;
		} else {
			initialize.prototype.constructor = initialize;
		}

		//Grab the mixins, if they are specified...
		var mixins = null;
		if (definition.Mixins) {
			mixins = definition.Mixins;
			delete definition.Mixins;
		}

		//First, mixin if we can.
		mixin(initialize, mixins);

		//Now we grab the actual definition which defines the overrides.
		extend$1(initialize, definition, true, Extends);

		return initialize;
	}
	Class$1.extend = extend$1;
	Class$1.mixin = mixin;
	Class$1.ignoreFinals = false;

	var klasse = Class$1;

	var interpolation = {};

	/** Utility function for linear interpolation. */

	interpolation.lerp = function(v0, v1, t) {
	    return v0*(1-t)+v1*t;
	};

	/** Utility function for Hermite interpolation. */
	interpolation.smoothstep = function(v0, v1, t) {
	    // Scale, bias and saturate x to 0..1 range
	    t = Math.max(0.0, Math.min(1.0, (t - v0)/(v1 - v0) ));
	    // Evaluate polynomial
	    return t*t*(3 - 2*t);
	};

	var Vector2 = Vector2_1;
	var Class = klasse;
	var lerp = interpolation.lerp;

	function distanceTo(x1, y1, x2, y2) {
	    var dx = x2-x1;
	    var dy = y2-y1;
	    return Math.sqrt(dx*dx+dy*dy);
	}

	var tmp1 = new Vector2();
	var tmp2 = new Vector2();

	var Shape$1 = new Class({

	    initialize: function() {
	        this.steps = 1;
	        this.points = [];

	        // If step is not provided to a ***CurveTo function, 
	        // then it will be approximated with a very simple distance check
	        this.approximateCurves = true;
	        this.approximationFactor = 0.5;

	        this._move = new Vector2();
	        this._start = new Vector2();
	        this._hasMoved = false;
	        this._newPath = true;
	    },


	    reset: function() {
	        this.points.length = 0;
	        this._newPath = true;
	        this._hasMoved = false;
	        this._move.x = this._move.y = 0;
	        this._start.x = this._start.y = 0;
	    },

	    beginPath: function() {
	        this.reset();
	    },
	    
	    moveTo: function(x, y) {
	        this._newPath = true;
	        this._move.x = x;
	        this._move.y = y;
	        this._start.x = x;
	        this._start.y = y;
	        this._hasMoved = true;
	    },

	    __newPoint: function(nx, ny) {
	        this.points.push(new Vector2(nx, ny));
	        this._newPath = false;
	    },
	    
	    /** Closes the path by performing a lineTo with the first 'starting' point. 
	        If the path is empty, this does nothing. */
	    closePath: function(steps) {
	        if (this.points.length===0)
	            return;
	        this.lineTo(this._start.x, this._start.y, steps);
	    },
	    
	    lineTo: function(x, y, steps) {
	        //if we are calling lineTo before any moveTo.. make this the first point
	        if (!this._hasMoved) {
	            this.moveTo(x, y);
	            return;
	        }

	        steps = Math.max(1, steps || this.steps);
	        for (var i=0; i<=steps; i++) { 
	            if (!this._newPath && i==0)
	                continue;
	                
	            var t = i/steps;   
	            var nx = lerp(this._move.x, x, t);
	            var ny = lerp(this._move.y, y, t);
	            
	            this.__newPoint(nx, ny);
	        }
	        this._move.x = x;
	        this._move.y = y; 
	    },

	    /** Creates a bezier (cubic) curve to the specified point, with the given control points.
	    If steps is not specified or is a falsy value, this function will use the default value
	    set for this Path object. It will be capped to a minimum of 3 steps. 
	    */
	    bezierCurveTo: function(x2, y2, x3, y3, x4, y4, steps) {
	        //if we are calling bezierCurveTo before any moveTo.. the control point takes the lead
	        //this is how it works with HTML5 canvas context
	        if (!this._hasMoved) {
	            this.moveTo(x2, y2);
	        }
	        
	        var x1 = this._move.x;
	        var y1 = this._move.y;
	        
	        //try to approximate with a simple distance sum.
	        //more accurate would be to use this:
	        //http://antigrain.com/research/adaptive_bezier/
	        if (!steps) {
	            if (this.approximateCurves) {
	                var d1 = distanceTo(x1, y1, x2, y2);
	                var d2 = distanceTo(x2, y2, x3, y3);
	                var d3 = distanceTo(x3, y3, x4, y4);
	                steps = ~~((d1 + d2 + d3) * this.approximationFactor);
	            } else {
	                steps = Math.max(1, this.steps);
	            }
	        } 
	        
	        for (var i=0; i<steps; i++) {
	            var t = i / (steps-1);
	            var dt = (1 - t);
	            
	            var dt2 = dt * dt;
	            var dt3 = dt2 * dt;
	            var t2 = t * t;
	            var t3 = t2 * t;
	            
	            var x = dt3 * x1 + 3 * dt2 * t * x2 + 3 * dt * t2 * x3 + t3 * x4;
	            var y = dt3 * y1 + 3 * dt2 * t * y2 + 3 * dt * t2 * y3 + t3 * y4;
	            
	            this.__newPoint(x, y);
	        }
	        
	        this._move.x = x4;
	        this._move.y = y4;
	    },
	    
	    /** Creates a quadratic curve to the specified point, with the given control points.
	    If steps is not specified or is a falsy value, this function will use the default value
	    set for this Path object. It will be capped to a minimum of 3 steps. 
	    */
	    quadraticCurveTo: function(x2, y2, x3, y3, steps) {
	        //parity with HTML5 canvas context, just move to first control point
	        if (!this._hasMoved) {
	            this.moveTo(x2, y2);
	        } 
	        
	        var x1 = this._move.x;
	        var y1 = this._move.y;
	        
	        //try to approximate with a simple distance sum.
	        //more accurate would be to use this:
	        //http://antigrain.com/research/adaptive_bezier/
	        if (!steps) {
	            if (this.approximateCurves) {
	                var d1 = tmp1.set(x1, y1).distance( tmp2.set(x2, y2) );
	                var d2 = tmp1.set(x2, y2).distance( tmp2.set(x3, y3) );
	                steps = ~~((d1 + d2) * this.approximationFactor);
	            } else {
	                steps = Math.max(1, this.steps);
	            }
	        } 
	        
	        for (var i=0; i<steps; i++) {
	            var t = i / (steps-1);
	            var dt = (1 - t);
	            var dtSq = dt * dt;
	            var tSq = t * t;
	            
	            var x = dtSq * x1 + 2 * dt * t * x2 + tSq * x3;
	            var y = dtSq * y1 + 2 * dt * t * y2 + tSq * y3;
	            
	            this.__newPoint(x, y);
	        }
	        
	        this._move.x = x3;
	        this._move.y = y3;
	    },

	    calculateBoundingBox: function() {
	        var points = this.points;

	        var minX = Number.MAX_VALUE,
	            minY = Number.MAX_VALUE,
	            maxX = -Number.MAX_VALUE,
	            maxY = -Number.MAX_VALUE;

	        for (var i=0; i<points.length; i++) {
	            var p = points[i];

	            minX = Math.min(minX, p.x);
	            minY = Math.min(minY, p.y);
	            maxX = Math.max(maxX, p.x);
	            maxY = Math.max(maxY, p.y);
	        }

	        return {
	            x: minX,
	            y: minY,
	            width: maxX-minX,
	            height: maxY-minY
	        };
	    },

	    contains: function(x, y) {
	        var testx = x, testy = y;
	        if (typeof x === "object") {
	            testx = x.x;
	            testy = x.y;
	        }

	        var points = this.points;
	        var nvert = points.length;
	        var i, j, c = 0;
	        for (i=0, j=nvert-1; i<nvert; j=i++) {
	            if ( ((points[i].y>testy) != (points[j].y>testy)) &&
	                (testx < (points[j].x-points[i].x) * (testy-points[i].y) / (points[j].y-points[i].y) + points[i].x) ) {
	                c = !c;
	            }
	        }
	        return c;
	    },


	    simplify: function(tolerance, out) {
	        var points = this.points,
	            len = points.length,
	            point = new Vector2(),
	            sqTolerance = tolerance*tolerance,
	            prevPoint = new Vector2( points[0] );

	        if (!out)
	            out = new Shape$1();

	        var outPoints = [];
	        outPoints.push(prevPoint);

	        for (var i=1; i<len; i++) {
	            point = points[i];
	            if ( point.distanceSq(prevPoint) > sqTolerance ) {
	                outPoints.push(new Vector2(point));
	                prevPoint = point;
	            }
	        }
	        if (prevPoint.x !== point.x || prevPoint.y !== point.y)
	            outPoints.push(new Vector2(point));

	        out.points = outPoints;
	        return out; 
	    }
	});

	var shape2d = Shape$1;

	var Shape = shape2d;

	var funcs = {
	    'm': 'moveTo',
	    'l': 'lineTo',
	    'q': 'quadraticCurveTo',
	    'c': 'bezierCurveTo'
	};

	/**
	 * Decomposes a glyph and its outline from fontpath into a list of Shapes from shape2d.
	 * This is a discrete set of points that can then be used for triangulation
	 * or further effects.
	 */
	var fontpathShape2d = function(glyph, options) {
	    options = options||{};

	    var curves = Boolean(options.approximateCurves);
	    var steps = options.steps||10;
	    var factor = options.approximationFactor;
	    factor = (typeof factor==="number") ? factor : 0.5;

	    var shapes = [];
	    var shape = new Shape();
	    shape.approximateCurves = curves;
	    shape.approximationFactor = factor;
	    shape.steps = steps;

	    if (!glyph.path || glyph.path.length===0)
	        return shapes;

	    var path = glyph.path;
	    for (var i=0; i<path.length; i++) {
	        var p = path[i];
	        var args = p.slice(1);
	        var fkey = funcs[ p[0] ];

	        //assume we are on a new shape when we reach a moveto
	        //will have to revisit this with a better solution 
	        //maybe even-odd rule
	        if (i!==0 && fkey==='moveTo') {
	            //push the current shape ahead..
	            shapes.push(shape);

	            shape = new Shape();
	            shape.approximateCurves = curves;
	            shape.approximationFactor = factor;
	            shape.steps = steps;
	        }

	        shape[fkey].apply(shape, args);
	    }

	    shapes.push(shape);
	    return shapes;
	};

	var poly2tri$1 = {};

	var version$1 = "1.5.0";
	var require$$0 = {
		version: version$1
	};

	/*
	 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
	 * http://code.google.com/p/poly2tri/
	 * 
	 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
	 * https://github.com/r3mi/poly2tri.js
	 * 
	 * All rights reserved.
	 * 
	 * Distributed under the 3-clause BSD License, see LICENSE.txt
	 */

	/**
	 * The following functions operate on "Point" or any "Point like" object with {x,y},
	 * as defined by the {@link XY} type
	 * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).
	 * @module
	 * @private
	 */

	/**
	 * poly2tri.js supports using custom point class instead of {@linkcode Point}.
	 * Any "Point like" object with <code>&#123;x, y&#125;</code> attributes is supported
	 * to initialize the SweepContext polylines and points
	 * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).
	 *
	 * poly2tri.js might add extra fields to the point objects when computing the
	 * triangulation : they are prefixed with <code>_p2t_</code> to avoid collisions
	 * with fields in the custom class.
	 *
	 * @example
	 *      var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];
	 *      var swctx = new poly2tri.SweepContext(contour);
	 *
	 * @typedef {Object} XY
	 * @property {number} x - x coordinate
	 * @property {number} y - y coordinate
	 */


	/**
	 * Point pretty printing : prints x and y coordinates.
	 * @example
	 *      xy.toStringBase({x:5, y:42})
	 *      // → "(5;42)"
	 * @protected
	 * @param {!XY} p - point object with {x,y}
	 * @returns {string} <code>"(x;y)"</code>
	 */
	function toStringBase(p) {
	    return ("(" + p.x + ";" + p.y + ")");
	}

	/**
	 * Point pretty printing. Delegates to the point's custom "toString()" method if exists,
	 * else simply prints x and y coordinates.
	 * @example
	 *      xy.toString({x:5, y:42})
	 *      // → "(5;42)"
	 * @example
	 *      xy.toString({x:5,y:42,toString:function() {return this.x+":"+this.y;}})
	 *      // → "5:42"
	 * @param {!XY} p - point object with {x,y}
	 * @returns {string} <code>"(x;y)"</code>
	 */
	function toString(p) {
	    // Try a custom toString first, and fallback to own implementation if none
	    var s = p.toString();
	    return (s === '[object Object]' ? toStringBase(p) : s);
	}


	/**
	 * Compare two points component-wise. Ordered by y axis first, then x axis.
	 * @param {!XY} a - point object with {x,y}
	 * @param {!XY} b - point object with {x,y}
	 * @return {number} <code>&lt; 0</code> if <code>a &lt; b</code>,
	 *         <code>&gt; 0</code> if <code>a &gt; b</code>, 
	 *         <code>0</code> otherwise.
	 */
	function compare(a, b) {
	    if (a.y === b.y) {
	        return a.x - b.x;
	    } else {
	        return a.y - b.y;
	    }
	}

	/**
	 * Test two Point objects for equality.
	 * @param {!XY} a - point object with {x,y}
	 * @param {!XY} b - point object with {x,y}
	 * @return {boolean} <code>True</code> if <code>a == b</code>, <code>false</code> otherwise.
	 */
	function equals(a, b) {
	    return a.x === b.x && a.y === b.y;
	}


	var xy$3 = {
	    toString: toString,
	    toStringBase: toStringBase,
	    compare: compare,
	    equals: equals
	};

	/*
	 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
	 * http://code.google.com/p/poly2tri/
	 * 
	 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
	 * https://github.com/r3mi/poly2tri.js
	 * 
	 * All rights reserved.
	 * 
	 * Distributed under the 3-clause BSD License, see LICENSE.txt
	 */

	/*
	 * Class added in the JavaScript version (was not present in the c++ version)
	 */

	var xy$2 = xy$3;

	/**
	 * Custom exception class to indicate invalid Point values
	 * @constructor
	 * @public
	 * @extends Error
	 * @struct
	 * @param {string=} message - error message
	 * @param {Array.<XY>=} points - invalid points
	 */
	var PointError$2 = function(message, points) {
	    this.name = "PointError";
	    /**
	     * Invalid points
	     * @public
	     * @type {Array.<XY>}
	     */
	    this.points = points = points || [];
	    /**
	     * Error message
	     * @public
	     * @type {string}
	     */
	    this.message = message || "Invalid Points!";
	    for (var i = 0; i < points.length; i++) {
	        this.message += " " + xy$2.toString(points[i]);
	    }
	};
	PointError$2.prototype = new Error();
	PointError$2.prototype.constructor = PointError$2;


	var pointerror = PointError$2;

	/*
	 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
	 * http://code.google.com/p/poly2tri/
	 * 
	 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
	 * https://github.com/r3mi/poly2tri.js
	 * 
	 * All rights reserved.
	 * 
	 * Distributed under the 3-clause BSD License, see LICENSE.txt
	 */


	/*
	 * Note
	 * ====
	 * the structure of this JavaScript version of poly2tri intentionally follows
	 * as closely as possible the structure of the reference C++ version, to make it 
	 * easier to keep the 2 versions in sync.
	 */

	var xy$1 = xy$3;

	// ------------------------------------------------------------------------Point
	/**
	 * Construct a point
	 * @example
	 *      var point = new poly2tri.Point(150, 150);
	 * @public
	 * @constructor
	 * @struct
	 * @param {number=} x    coordinate (0 if undefined)
	 * @param {number=} y    coordinate (0 if undefined)
	 */
	var Point$1 = function(x, y) {
	    /**
	     * @type {number}
	     * @expose
	     */
	    this.x = +x || 0;
	    /**
	     * @type {number}
	     * @expose
	     */
	    this.y = +y || 0;

	    // All extra fields added to Point are prefixed with _p2t_
	    // to avoid collisions if custom Point class is used.

	    /**
	     * The edges this point constitutes an upper ending point
	     * @private
	     * @type {Array.<Edge>}
	     */
	    this._p2t_edge_list = null;
	};

	/**
	 * For pretty printing
	 * @example
	 *      "p=" + new poly2tri.Point(5,42)
	 *      // → "p=(5;42)"
	 * @returns {string} <code>"(x;y)"</code>
	 */
	Point$1.prototype.toString = function() {
	    return xy$1.toStringBase(this);
	};

	/**
	 * JSON output, only coordinates
	 * @example
	 *      JSON.stringify(new poly2tri.Point(1,2))
	 *      // → '{"x":1,"y":2}'
	 */
	Point$1.prototype.toJSON = function() {
	    return { x: this.x, y: this.y };
	};

	/**
	 * Creates a copy of this Point object.
	 * @return {Point} new cloned point
	 */
	Point$1.prototype.clone = function() {
	    return new Point$1(this.x, this.y);
	};

	/**
	 * Set this Point instance to the origo. <code>(0; 0)</code>
	 * @return {Point} this (for chaining)
	 */
	Point$1.prototype.set_zero = function() {
	    this.x = 0.0;
	    this.y = 0.0;
	    return this; // for chaining
	};

	/**
	 * Set the coordinates of this instance.
	 * @param {number} x   coordinate
	 * @param {number} y   coordinate
	 * @return {Point} this (for chaining)
	 */
	Point$1.prototype.set = function(x, y) {
	    this.x = +x || 0;
	    this.y = +y || 0;
	    return this; // for chaining
	};

	/**
	 * Negate this Point instance. (component-wise)
	 * @return {Point} this (for chaining)
	 */
	Point$1.prototype.negate = function() {
	    this.x = -this.x;
	    this.y = -this.y;
	    return this; // for chaining
	};

	/**
	 * Add another Point object to this instance. (component-wise)
	 * @param {!Point} n - Point object.
	 * @return {Point} this (for chaining)
	 */
	Point$1.prototype.add = function(n) {
	    this.x += n.x;
	    this.y += n.y;
	    return this; // for chaining
	};

	/**
	 * Subtract this Point instance with another point given. (component-wise)
	 * @param {!Point} n - Point object.
	 * @return {Point} this (for chaining)
	 */
	Point$1.prototype.sub = function(n) {
	    this.x -= n.x;
	    this.y -= n.y;
	    return this; // for chaining
	};

	/**
	 * Multiply this Point instance by a scalar. (component-wise)
	 * @param {number} s   scalar.
	 * @return {Point} this (for chaining)
	 */
	Point$1.prototype.mul = function(s) {
	    this.x *= s;
	    this.y *= s;
	    return this; // for chaining
	};

	/**
	 * Return the distance of this Point instance from the origo.
	 * @return {number} distance
	 */
	Point$1.prototype.length = function() {
	    return Math.sqrt(this.x * this.x + this.y * this.y);
	};

	/**
	 * Normalize this Point instance (as a vector).
	 * @return {number} The original distance of this instance from the origo.
	 */
	Point$1.prototype.normalize = function() {
	    var len = this.length();
	    this.x /= len;
	    this.y /= len;
	    return len;
	};

	/**
	 * Test this Point object with another for equality.
	 * @param {!XY} p - any "Point like" object with {x,y}
	 * @return {boolean} <code>true</code> if same x and y coordinates, <code>false</code> otherwise.
	 */
	Point$1.prototype.equals = function(p) {
	    return this.x === p.x && this.y === p.y;
	};


	// -----------------------------------------------------Point ("static" methods)

	/**
	 * Negate a point component-wise and return the result as a new Point object.
	 * @param {!XY} p - any "Point like" object with {x,y}
	 * @return {Point} the resulting Point object.
	 */
	Point$1.negate = function(p) {
	    return new Point$1(-p.x, -p.y);
	};

	/**
	 * Add two points component-wise and return the result as a new Point object.
	 * @param {!XY} a - any "Point like" object with {x,y}
	 * @param {!XY} b - any "Point like" object with {x,y}
	 * @return {Point} the resulting Point object.
	 */
	Point$1.add = function(a, b) {
	    return new Point$1(a.x + b.x, a.y + b.y);
	};

	/**
	 * Subtract two points component-wise and return the result as a new Point object.
	 * @param {!XY} a - any "Point like" object with {x,y}
	 * @param {!XY} b - any "Point like" object with {x,y}
	 * @return {Point} the resulting Point object.
	 */
	Point$1.sub = function(a, b) {
	    return new Point$1(a.x - b.x, a.y - b.y);
	};

	/**
	 * Multiply a point by a scalar and return the result as a new Point object.
	 * @param {number} s - the scalar
	 * @param {!XY} p - any "Point like" object with {x,y}
	 * @return {Point} the resulting Point object.
	 */
	Point$1.mul = function(s, p) {
	    return new Point$1(s * p.x, s * p.y);
	};

	/**
	 * Perform the cross product on either two points (this produces a scalar)
	 * or a point and a scalar (this produces a point).
	 * This function requires two parameters, either may be a Point object or a
	 * number.
	 * @param  {XY|number} a - Point object or scalar.
	 * @param  {XY|number} b - Point object or scalar.
	 * @return {Point|number} a Point object or a number, depending on the parameters.
	 */
	Point$1.cross = function(a, b) {
	    if (typeof(a) === 'number') {
	        if (typeof(b) === 'number') {
	            return a * b;
	        } else {
	            return new Point$1(-a * b.y, a * b.x);
	        }
	    } else {
	        if (typeof(b) === 'number') {
	            return new Point$1(b * a.y, -b * a.x);
	        } else {
	            return a.x * b.y - a.y * b.x;
	        }
	    }
	};


	// -----------------------------------------------------------------"Point-Like"
	/*
	 * The following functions operate on "Point" or any "Point like" object 
	 * with {x,y} (duck typing).
	 */

	Point$1.toString = xy$1.toString;
	Point$1.compare = xy$1.compare;
	Point$1.cmp = xy$1.compare; // backward compatibility
	Point$1.equals = xy$1.equals;

	/**
	 * Peform the dot product on two vectors.
	 * @public
	 * @param {!XY} a - any "Point like" object with {x,y}
	 * @param {!XY} b - any "Point like" object with {x,y}
	 * @return {number} The dot product
	 */
	Point$1.dot = function(a, b) {
	    return a.x * b.x + a.y * b.y;
	};


	// ---------------------------------------------------------Exports (public API)

	var point = Point$1;

	/*
	 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
	 * http://code.google.com/p/poly2tri/
	 * 
	 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
	 * https://github.com/r3mi/poly2tri.js
	 *
	 * All rights reserved.
	 * 
	 * Distributed under the 3-clause BSD License, see LICENSE.txt
	 */


	/*
	 * Note
	 * ====
	 * the structure of this JavaScript version of poly2tri intentionally follows
	 * as closely as possible the structure of the reference C++ version, to make it 
	 * easier to keep the 2 versions in sync.
	 */

	var xy = xy$3;


	// ---------------------------------------------------------------------Triangle
	/**
	 * Triangle class.<br>
	 * Triangle-based data structures are known to have better performance than
	 * quad-edge structures.
	 * See: J. Shewchuk, "Triangle: Engineering a 2D Quality Mesh Generator and
	 * Delaunay Triangulator", "Triangulations in CGAL"
	 *
	 * @constructor
	 * @struct
	 * @param {!XY} pa  point object with {x,y}
	 * @param {!XY} pb  point object with {x,y}
	 * @param {!XY} pc  point object with {x,y}
	 */
	var Triangle$2 = function(a, b, c) {
	    /**
	     * Triangle points
	     * @private
	     * @type {Array.<XY>}
	     */
	    this.points_ = [a, b, c];

	    /**
	     * Neighbor list
	     * @private
	     * @type {Array.<Triangle>}
	     */
	    this.neighbors_ = [null, null, null];

	    /**
	     * Has this triangle been marked as an interior triangle?
	     * @private
	     * @type {boolean}
	     */
	    this.interior_ = false;

	    /**
	     * Flags to determine if an edge is a Constrained edge
	     * @private
	     * @type {Array.<boolean>}
	     */
	    this.constrained_edge = [false, false, false];

	    /**
	     * Flags to determine if an edge is a Delauney edge
	     * @private
	     * @type {Array.<boolean>}
	     */
	    this.delaunay_edge = [false, false, false];
	};

	var p2s = xy.toString;
	/**
	 * For pretty printing ex. <code>"[(5;42)(10;20)(21;30)]"</code>.
	 * @public
	 * @return {string}
	 */
	Triangle$2.prototype.toString = function() {
	    return ("[" + p2s(this.points_[0]) + p2s(this.points_[1]) + p2s(this.points_[2]) + "]");
	};

	/**
	 * Get one vertice of the triangle.
	 * The output triangles of a triangulation have vertices which are references
	 * to the initial input points (not copies): any custom fields in the
	 * initial points can be retrieved in the output triangles.
	 * @example
	 *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];
	 *      var swctx = new poly2tri.SweepContext(contour);
	 *      swctx.triangulate();
	 *      var triangles = swctx.getTriangles();
	 *      typeof triangles[0].getPoint(0).id
	 *      // → "number"
	 * @param {number} index - vertice index: 0, 1 or 2
	 * @public
	 * @returns {XY}
	 */
	Triangle$2.prototype.getPoint = function(index) {
	    return this.points_[index];
	};

	/**
	 * For backward compatibility
	 * @function
	 * @deprecated use {@linkcode Triangle#getPoint} instead
	 */
	Triangle$2.prototype.GetPoint = Triangle$2.prototype.getPoint;

	/**
	 * Get all 3 vertices of the triangle as an array
	 * @public
	 * @return {Array.<XY>}
	 */
	// Method added in the JavaScript version (was not present in the c++ version)
	Triangle$2.prototype.getPoints = function() {
	    return this.points_;
	};

	/**
	 * @private
	 * @param {number} index
	 * @returns {?Triangle}
	 */
	Triangle$2.prototype.getNeighbor = function(index) {
	    return this.neighbors_[index];
	};

	/**
	 * Test if this Triangle contains the Point object given as parameter as one of its vertices.
	 * Only point references are compared, not values.
	 * @public
	 * @param {XY} point - point object with {x,y}
	 * @return {boolean} <code>True</code> if the Point object is of the Triangle's vertices,
	 *         <code>false</code> otherwise.
	 */
	Triangle$2.prototype.containsPoint = function(point) {
	    var points = this.points_;
	    // Here we are comparing point references, not values
	    return (point === points[0] || point === points[1] || point === points[2]);
	};

	/**
	 * Test if this Triangle contains the Edge object given as parameter as its
	 * bounding edges. Only point references are compared, not values.
	 * @private
	 * @param {Edge} edge
	 * @return {boolean} <code>True</code> if the Edge object is of the Triangle's bounding
	 *         edges, <code>false</code> otherwise.
	 */
	Triangle$2.prototype.containsEdge = function(edge) {
	    return this.containsPoint(edge.p) && this.containsPoint(edge.q);
	};

	/**
	 * Test if this Triangle contains the two Point objects given as parameters among its vertices.
	 * Only point references are compared, not values.
	 * @param {XY} p1 - point object with {x,y}
	 * @param {XY} p2 - point object with {x,y}
	 * @return {boolean}
	 */
	Triangle$2.prototype.containsPoints = function(p1, p2) {
	    return this.containsPoint(p1) && this.containsPoint(p2);
	};

	/**
	 * Has this triangle been marked as an interior triangle?
	 * @returns {boolean}
	 */
	Triangle$2.prototype.isInterior = function() {
	    return this.interior_;
	};

	/**
	 * Mark this triangle as an interior triangle
	 * @private
	 * @param {boolean} interior
	 * @returns {Triangle} this
	 */
	Triangle$2.prototype.setInterior = function(interior) {
	    this.interior_ = interior;
	    return this;
	};

	/**
	 * Update neighbor pointers.
	 * @private
	 * @param {XY} p1 - point object with {x,y}
	 * @param {XY} p2 - point object with {x,y}
	 * @param {Triangle} t Triangle object.
	 * @throws {Error} if can't find objects
	 */
	Triangle$2.prototype.markNeighborPointers = function(p1, p2, t) {
	    var points = this.points_;
	    // Here we are comparing point references, not values
	    if ((p1 === points[2] && p2 === points[1]) || (p1 === points[1] && p2 === points[2])) {
	        this.neighbors_[0] = t;
	    } else if ((p1 === points[0] && p2 === points[2]) || (p1 === points[2] && p2 === points[0])) {
	        this.neighbors_[1] = t;
	    } else if ((p1 === points[0] && p2 === points[1]) || (p1 === points[1] && p2 === points[0])) {
	        this.neighbors_[2] = t;
	    } else {
	        throw new Error('poly2tri Invalid Triangle.markNeighborPointers() call');
	    }
	};

	/**
	 * Exhaustive search to update neighbor pointers
	 * @private
	 * @param {!Triangle} t
	 */
	Triangle$2.prototype.markNeighbor = function(t) {
	    var points = this.points_;
	    if (t.containsPoints(points[1], points[2])) {
	        this.neighbors_[0] = t;
	        t.markNeighborPointers(points[1], points[2], this);
	    } else if (t.containsPoints(points[0], points[2])) {
	        this.neighbors_[1] = t;
	        t.markNeighborPointers(points[0], points[2], this);
	    } else if (t.containsPoints(points[0], points[1])) {
	        this.neighbors_[2] = t;
	        t.markNeighborPointers(points[0], points[1], this);
	    }
	};


	Triangle$2.prototype.clearNeighbors = function() {
	    this.neighbors_[0] = null;
	    this.neighbors_[1] = null;
	    this.neighbors_[2] = null;
	};

	Triangle$2.prototype.clearDelaunayEdges = function() {
	    this.delaunay_edge[0] = false;
	    this.delaunay_edge[1] = false;
	    this.delaunay_edge[2] = false;
	};

	/**
	 * Returns the point clockwise to the given point.
	 * @private
	 * @param {XY} p - point object with {x,y}
	 */
	Triangle$2.prototype.pointCW = function(p) {
	    var points = this.points_;
	    // Here we are comparing point references, not values
	    if (p === points[0]) {
	        return points[2];
	    } else if (p === points[1]) {
	        return points[0];
	    } else if (p === points[2]) {
	        return points[1];
	    } else {
	        return null;
	    }
	};

	/**
	 * Returns the point counter-clockwise to the given point.
	 * @private
	 * @param {XY} p - point object with {x,y}
	 */
	Triangle$2.prototype.pointCCW = function(p) {
	    var points = this.points_;
	    // Here we are comparing point references, not values
	    if (p === points[0]) {
	        return points[1];
	    } else if (p === points[1]) {
	        return points[2];
	    } else if (p === points[2]) {
	        return points[0];
	    } else {
	        return null;
	    }
	};

	/**
	 * Returns the neighbor clockwise to given point.
	 * @private
	 * @param {XY} p - point object with {x,y}
	 */
	Triangle$2.prototype.neighborCW = function(p) {
	    // Here we are comparing point references, not values
	    if (p === this.points_[0]) {
	        return this.neighbors_[1];
	    } else if (p === this.points_[1]) {
	        return this.neighbors_[2];
	    } else {
	        return this.neighbors_[0];
	    }
	};

	/**
	 * Returns the neighbor counter-clockwise to given point.
	 * @private
	 * @param {XY} p - point object with {x,y}
	 */
	Triangle$2.prototype.neighborCCW = function(p) {
	    // Here we are comparing point references, not values
	    if (p === this.points_[0]) {
	        return this.neighbors_[2];
	    } else if (p === this.points_[1]) {
	        return this.neighbors_[0];
	    } else {
	        return this.neighbors_[1];
	    }
	};

	Triangle$2.prototype.getConstrainedEdgeCW = function(p) {
	    // Here we are comparing point references, not values
	    if (p === this.points_[0]) {
	        return this.constrained_edge[1];
	    } else if (p === this.points_[1]) {
	        return this.constrained_edge[2];
	    } else {
	        return this.constrained_edge[0];
	    }
	};

	Triangle$2.prototype.getConstrainedEdgeCCW = function(p) {
	    // Here we are comparing point references, not values
	    if (p === this.points_[0]) {
	        return this.constrained_edge[2];
	    } else if (p === this.points_[1]) {
	        return this.constrained_edge[0];
	    } else {
	        return this.constrained_edge[1];
	    }
	};

	// Additional check from Java version (see issue #88)
	Triangle$2.prototype.getConstrainedEdgeAcross = function(p) {
	    // Here we are comparing point references, not values
	    if (p === this.points_[0]) {
	        return this.constrained_edge[0];
	    } else if (p === this.points_[1]) {
	        return this.constrained_edge[1];
	    } else {
	        return this.constrained_edge[2];
	    }
	};

	Triangle$2.prototype.setConstrainedEdgeCW = function(p, ce) {
	    // Here we are comparing point references, not values
	    if (p === this.points_[0]) {
	        this.constrained_edge[1] = ce;
	    } else if (p === this.points_[1]) {
	        this.constrained_edge[2] = ce;
	    } else {
	        this.constrained_edge[0] = ce;
	    }
	};

	Triangle$2.prototype.setConstrainedEdgeCCW = function(p, ce) {
	    // Here we are comparing point references, not values
	    if (p === this.points_[0]) {
	        this.constrained_edge[2] = ce;
	    } else if (p === this.points_[1]) {
	        this.constrained_edge[0] = ce;
	    } else {
	        this.constrained_edge[1] = ce;
	    }
	};

	Triangle$2.prototype.getDelaunayEdgeCW = function(p) {
	    // Here we are comparing point references, not values
	    if (p === this.points_[0]) {
	        return this.delaunay_edge[1];
	    } else if (p === this.points_[1]) {
	        return this.delaunay_edge[2];
	    } else {
	        return this.delaunay_edge[0];
	    }
	};

	Triangle$2.prototype.getDelaunayEdgeCCW = function(p) {
	    // Here we are comparing point references, not values
	    if (p === this.points_[0]) {
	        return this.delaunay_edge[2];
	    } else if (p === this.points_[1]) {
	        return this.delaunay_edge[0];
	    } else {
	        return this.delaunay_edge[1];
	    }
	};

	Triangle$2.prototype.setDelaunayEdgeCW = function(p, e) {
	    // Here we are comparing point references, not values
	    if (p === this.points_[0]) {
	        this.delaunay_edge[1] = e;
	    } else if (p === this.points_[1]) {
	        this.delaunay_edge[2] = e;
	    } else {
	        this.delaunay_edge[0] = e;
	    }
	};

	Triangle$2.prototype.setDelaunayEdgeCCW = function(p, e) {
	    // Here we are comparing point references, not values
	    if (p === this.points_[0]) {
	        this.delaunay_edge[2] = e;
	    } else if (p === this.points_[1]) {
	        this.delaunay_edge[0] = e;
	    } else {
	        this.delaunay_edge[1] = e;
	    }
	};

	/**
	 * The neighbor across to given point.
	 * @private
	 * @param {XY} p - point object with {x,y}
	 * @returns {Triangle}
	 */
	Triangle$2.prototype.neighborAcross = function(p) {
	    // Here we are comparing point references, not values
	    if (p === this.points_[0]) {
	        return this.neighbors_[0];
	    } else if (p === this.points_[1]) {
	        return this.neighbors_[1];
	    } else {
	        return this.neighbors_[2];
	    }
	};

	/**
	 * @private
	 * @param {!Triangle} t Triangle object.
	 * @param {XY} p - point object with {x,y}
	 */
	Triangle$2.prototype.oppositePoint = function(t, p) {
	    var cw = t.pointCW(p);
	    return this.pointCW(cw);
	};

	/**
	 * Legalize triangle by rotating clockwise around oPoint
	 * @private
	 * @param {XY} opoint - point object with {x,y}
	 * @param {XY} npoint - point object with {x,y}
	 * @throws {Error} if oPoint can not be found
	 */
	Triangle$2.prototype.legalize = function(opoint, npoint) {
	    var points = this.points_;
	    // Here we are comparing point references, not values
	    if (opoint === points[0]) {
	        points[1] = points[0];
	        points[0] = points[2];
	        points[2] = npoint;
	    } else if (opoint === points[1]) {
	        points[2] = points[1];
	        points[1] = points[0];
	        points[0] = npoint;
	    } else if (opoint === points[2]) {
	        points[0] = points[2];
	        points[2] = points[1];
	        points[1] = npoint;
	    } else {
	        throw new Error('poly2tri Invalid Triangle.legalize() call');
	    }
	};

	/**
	 * Returns the index of a point in the triangle. 
	 * The point *must* be a reference to one of the triangle's vertices.
	 * @private
	 * @param {XY} p - point object with {x,y}
	 * @returns {number} index 0, 1 or 2
	 * @throws {Error} if p can not be found
	 */
	Triangle$2.prototype.index = function(p) {
	    var points = this.points_;
	    // Here we are comparing point references, not values
	    if (p === points[0]) {
	        return 0;
	    } else if (p === points[1]) {
	        return 1;
	    } else if (p === points[2]) {
	        return 2;
	    } else {
	        throw new Error('poly2tri Invalid Triangle.index() call');
	    }
	};

	/**
	 * @private
	 * @param {XY} p1 - point object with {x,y}
	 * @param {XY} p2 - point object with {x,y}
	 * @return {number} index 0, 1 or 2, or -1 if errror
	 */
	Triangle$2.prototype.edgeIndex = function(p1, p2) {
	    var points = this.points_;
	    // Here we are comparing point references, not values
	    if (p1 === points[0]) {
	        if (p2 === points[1]) {
	            return 2;
	        } else if (p2 === points[2]) {
	            return 1;
	        }
	    } else if (p1 === points[1]) {
	        if (p2 === points[2]) {
	            return 0;
	        } else if (p2 === points[0]) {
	            return 2;
	        }
	    } else if (p1 === points[2]) {
	        if (p2 === points[0]) {
	            return 1;
	        } else if (p2 === points[1]) {
	            return 0;
	        }
	    }
	    return -1;
	};

	/**
	 * Mark an edge of this triangle as constrained.
	 * @private
	 * @param {number} index - edge index
	 */
	Triangle$2.prototype.markConstrainedEdgeByIndex = function(index) {
	    this.constrained_edge[index] = true;
	};
	/**
	 * Mark an edge of this triangle as constrained.
	 * @private
	 * @param {Edge} edge instance
	 */
	Triangle$2.prototype.markConstrainedEdgeByEdge = function(edge) {
	    this.markConstrainedEdgeByPoints(edge.p, edge.q);
	};
	/**
	 * Mark an edge of this triangle as constrained.
	 * This method takes two Point instances defining the edge of the triangle.
	 * @private
	 * @param {XY} p - point object with {x,y}
	 * @param {XY} q - point object with {x,y}
	 */
	Triangle$2.prototype.markConstrainedEdgeByPoints = function(p, q) {
	    var points = this.points_;
	    // Here we are comparing point references, not values        
	    if ((q === points[0] && p === points[1]) || (q === points[1] && p === points[0])) {
	        this.constrained_edge[2] = true;
	    } else if ((q === points[0] && p === points[2]) || (q === points[2] && p === points[0])) {
	        this.constrained_edge[1] = true;
	    } else if ((q === points[1] && p === points[2]) || (q === points[2] && p === points[1])) {
	        this.constrained_edge[0] = true;
	    }
	};


	// ---------------------------------------------------------Exports (public API)

	var triangle = Triangle$2;

	var sweep$1 = {};

	/*
	 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
	 * http://code.google.com/p/poly2tri/
	 *
	 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
	 * https://github.com/r3mi/poly2tri.js
	 *
	 * All rights reserved.
	 *
	 * Distributed under the 3-clause BSD License, see LICENSE.txt
	 */

	/*
	 * Function added in the JavaScript version (was not present in the c++ version)
	 */

	/**
	 * assert and throw an exception.
	 *
	 * @private
	 * @param {boolean} condition   the condition which is asserted
	 * @param {string} message      the message which is display is condition is falsy
	 */
	function assert$1(condition, message) {
	    if (!condition) {
	        throw new Error(message || "Assert Failed");
	    }
	}
	var assert_1 = assert$1;

	var advancingfront = {exports: {}};

	/*
	 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
	 * http://code.google.com/p/poly2tri/
	 * 
	 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
	 * https://github.com/r3mi/poly2tri.js
	 * 
	 * All rights reserved.
	 * 
	 * Distributed under the 3-clause BSD License, see LICENSE.txt
	 */


	/*
	 * Note
	 * ====
	 * the structure of this JavaScript version of poly2tri intentionally follows
	 * as closely as possible the structure of the reference C++ version, to make it 
	 * easier to keep the 2 versions in sync.
	 */


	// -------------------------------------------------------------------------Node

	/**
	 * Advancing front node
	 * @constructor
	 * @private
	 * @struct
	 * @param {!XY} p - Point
	 * @param {Triangle=} t triangle (optional)
	 */
	var Node$2 = function(p, t) {
	    /** @type {XY} */
	    this.point = p;

	    /** @type {Triangle|null} */
	    this.triangle = t || null;

	    /** @type {Node|null} */
	    this.next = null;
	    /** @type {Node|null} */
	    this.prev = null;

	    /** @type {number} */
	    this.value = p.x;
	};

	// ---------------------------------------------------------------AdvancingFront
	/**
	 * @constructor
	 * @private
	 * @struct
	 * @param {Node} head
	 * @param {Node} tail
	 */
	var AdvancingFront$1 = function(head, tail) {
	    /** @type {Node} */
	    this.head_ = head;
	    /** @type {Node} */
	    this.tail_ = tail;
	    /** @type {Node} */
	    this.search_node_ = head;
	};

	/** @return {Node} */
	AdvancingFront$1.prototype.head = function() {
	    return this.head_;
	};

	/** @param {Node} node */
	AdvancingFront$1.prototype.setHead = function(node) {
	    this.head_ = node;
	};

	/** @return {Node} */
	AdvancingFront$1.prototype.tail = function() {
	    return this.tail_;
	};

	/** @param {Node} node */
	AdvancingFront$1.prototype.setTail = function(node) {
	    this.tail_ = node;
	};

	/** @return {Node} */
	AdvancingFront$1.prototype.search = function() {
	    return this.search_node_;
	};

	/** @param {Node} node */
	AdvancingFront$1.prototype.setSearch = function(node) {
	    this.search_node_ = node;
	};

	/** @return {Node} */
	AdvancingFront$1.prototype.findSearchNode = function(/*x*/) {
	    // TODO: implement BST index
	    return this.search_node_;
	};

	/**
	 * @param {number} x value
	 * @return {Node}
	 */
	AdvancingFront$1.prototype.locateNode = function(x) {
	    var node = this.search_node_;

	    /* jshint boss:true */
	    if (x < node.value) {
	        while (node = node.prev) {
	            if (x >= node.value) {
	                this.search_node_ = node;
	                return node;
	            }
	        }
	    } else {
	        while (node = node.next) {
	            if (x < node.value) {
	                this.search_node_ = node.prev;
	                return node.prev;
	            }
	        }
	    }
	    return null;
	};

	/**
	 * @param {!XY} point - Point
	 * @return {Node}
	 */
	AdvancingFront$1.prototype.locatePoint = function(point) {
	    var px = point.x;
	    var node = this.findSearchNode(px);
	    var nx = node.point.x;

	    if (px === nx) {
	        // Here we are comparing point references, not values
	        if (point !== node.point) {
	            // We might have two nodes with same x value for a short time
	            if (point === node.prev.point) {
	                node = node.prev;
	            } else if (point === node.next.point) {
	                node = node.next;
	            } else {
	                throw new Error('poly2tri Invalid AdvancingFront.locatePoint() call');
	            }
	        }
	    } else if (px < nx) {
	        /* jshint boss:true */
	        while (node = node.prev) {
	            if (point === node.point) {
	                break;
	            }
	        }
	    } else {
	        while (node = node.next) {
	            if (point === node.point) {
	                break;
	            }
	        }
	    }

	    if (node) {
	        this.search_node_ = node;
	    }
	    return node;
	};


	// ----------------------------------------------------------------------Exports

	advancingfront.exports = AdvancingFront$1;
	advancingfront.exports.Node = Node$2;

	var utils$1 = {};

	/*
	 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
	 * http://code.google.com/p/poly2tri/
	 * 
	 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
	 * https://github.com/r3mi/poly2tri.js
	 * 
	 * All rights reserved.
	 * 
	 * Distributed under the 3-clause BSD License, see LICENSE.txt
	 */

	/**
	 * Precision to detect repeated or collinear points
	 * @private
	 * @const {number}
	 * @default
	 */
	var EPSILON$1 = 1e-12;
	utils$1.EPSILON = EPSILON$1;

	/**
	 * @private
	 * @enum {number}
	 * @readonly
	 */
	var Orientation$1 = {
	    "CW": 1,
	    "CCW": -1,
	    "COLLINEAR": 0
	};
	utils$1.Orientation = Orientation$1;


	/**
	 * Formula to calculate signed area<br>
	 * Positive if CCW<br>
	 * Negative if CW<br>
	 * 0 if collinear<br>
	 * <pre>
	 * A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)
	 *              =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)
	 * </pre>
	 *
	 * @private
	 * @param {!XY} pa  point object with {x,y}
	 * @param {!XY} pb  point object with {x,y}
	 * @param {!XY} pc  point object with {x,y}
	 * @return {Orientation}
	 */
	function orient2d$1(pa, pb, pc) {
	    var detleft = (pa.x - pc.x) * (pb.y - pc.y);
	    var detright = (pa.y - pc.y) * (pb.x - pc.x);
	    var val = detleft - detright;
	    if (val > -(EPSILON$1) && val < (EPSILON$1)) {
	        return Orientation$1.COLLINEAR;
	    } else if (val > 0) {
	        return Orientation$1.CCW;
	    } else {
	        return Orientation$1.CW;
	    }
	}
	utils$1.orient2d = orient2d$1;


	/**
	 *
	 * @private
	 * @param {!XY} pa  point object with {x,y}
	 * @param {!XY} pb  point object with {x,y}
	 * @param {!XY} pc  point object with {x,y}
	 * @param {!XY} pd  point object with {x,y}
	 * @return {boolean}
	 */
	function inScanArea$1(pa, pb, pc, pd) {
	    var oadb = (pa.x - pb.x) * (pd.y - pb.y) - (pd.x - pb.x) * (pa.y - pb.y);
	    if (oadb >= -EPSILON$1) {
	        return false;
	    }

	    var oadc = (pa.x - pc.x) * (pd.y - pc.y) - (pd.x - pc.x) * (pa.y - pc.y);
	    if (oadc <= EPSILON$1) {
	        return false;
	    }
	    return true;
	}
	utils$1.inScanArea = inScanArea$1;


	/**
	 * Check if the angle between (pa,pb) and (pa,pc) is obtuse i.e. (angle > π/2 || angle < -π/2)
	 *
	 * @private
	 * @param {!XY} pa  point object with {x,y}
	 * @param {!XY} pb  point object with {x,y}
	 * @param {!XY} pc  point object with {x,y}
	 * @return {boolean} true if angle is obtuse
	 */
	function isAngleObtuse$1(pa, pb, pc) {
	    var ax = pb.x - pa.x;
	    var ay = pb.y - pa.y;
	    var bx = pc.x - pa.x;
	    var by = pc.y - pa.y;
	    return (ax * bx + ay * by) < 0;
	}
	utils$1.isAngleObtuse = isAngleObtuse$1;

	/*
	 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
	 * http://code.google.com/p/poly2tri/
	 * 
	 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
	 * https://github.com/r3mi/poly2tri.js
	 * 
	 * All rights reserved.
	 * 
	 * Distributed under the 3-clause BSD License, see LICENSE.txt
	 */

	/**
	 * This 'Sweep' module is present in order to keep this JavaScript version
	 * as close as possible to the reference C++ version, even though almost all
	 * functions could be declared as methods on the {@linkcode module:sweepcontext~SweepContext} object.
	 * @module
	 * @private
	 */

	/*
	 * Note
	 * ====
	 * the structure of this JavaScript version of poly2tri intentionally follows
	 * as closely as possible the structure of the reference C++ version, to make it 
	 * easier to keep the 2 versions in sync.
	 */

	var assert = assert_1;
	var PointError$1 = pointerror;
	var Triangle$1 = triangle;
	var Node$1 = advancingfront.exports.Node;


	// ------------------------------------------------------------------------utils

	var utils = utils$1;

	/** @const */
	var EPSILON = utils.EPSILON;

	/** @const */
	var Orientation = utils.Orientation;
	/** @const */
	var orient2d = utils.orient2d;
	/** @const */
	var inScanArea = utils.inScanArea;
	/** @const */
	var isAngleObtuse = utils.isAngleObtuse;


	// ------------------------------------------------------------------------Sweep

	/**
	 * Triangulate the polygon with holes and Steiner points.
	 * Do this AFTER you've added the polyline, holes, and Steiner points
	 * @private
	 * @param {!SweepContext} tcx - SweepContext object
	 */
	function triangulate$1(tcx) {
	    tcx.initTriangulation();
	    tcx.createAdvancingFront();
	    // Sweep points; build mesh
	    sweepPoints(tcx);
	    // Clean up
	    finalizationPolygon(tcx);
	}

	/**
	 * Start sweeping the Y-sorted point set from bottom to top
	 * @param {!SweepContext} tcx - SweepContext object
	 */
	function sweepPoints(tcx) {
	    var i, len = tcx.pointCount();
	    for (i = 1; i < len; ++i) {
	        var point = tcx.getPoint(i);
	        var node = pointEvent(tcx, point);
	        var edges = point._p2t_edge_list;
	        for (var j = 0; edges && j < edges.length; ++j) {
	            edgeEventByEdge(tcx, edges[j], node);
	        }
	    }
	}

	/**
	 * @param {!SweepContext} tcx - SweepContext object
	 */
	function finalizationPolygon(tcx) {
	    // Get an Internal triangle to start with
	    var t = tcx.front().head().next.triangle;
	    var p = tcx.front().head().next.point;
	    while (!t.getConstrainedEdgeCW(p)) {
	        t = t.neighborCCW(p);
	    }

	    // Collect interior triangles constrained by edges
	    tcx.meshClean(t);
	}

	/**
	 * Find closes node to the left of the new point and
	 * create a new triangle. If needed new holes and basins
	 * will be filled to.
	 * @param {!SweepContext} tcx - SweepContext object
	 * @param {!XY} point   Point
	 */
	function pointEvent(tcx, point) {
	    var node = tcx.locateNode(point);
	    var new_node = newFrontTriangle(tcx, point, node);

	    // Only need to check +epsilon since point never have smaller
	    // x value than node due to how we fetch nodes from the front
	    if (point.x <= node.point.x + (EPSILON)) {
	        fill(tcx, node);
	    }

	    //tcx.AddNode(new_node);

	    fillAdvancingFront(tcx, new_node);
	    return new_node;
	}

	function edgeEventByEdge(tcx, edge, node) {
	    tcx.edge_event.constrained_edge = edge;
	    tcx.edge_event.right = (edge.p.x > edge.q.x);

	    if (isEdgeSideOfTriangle(node.triangle, edge.p, edge.q)) {
	        return;
	    }

	    // For now we will do all needed filling
	    // TODO: integrate with flip process might give some better performance
	    //       but for now this avoid the issue with cases that needs both flips and fills
	    fillEdgeEvent(tcx, edge, node);
	    edgeEventByPoints(tcx, edge.p, edge.q, node.triangle, edge.q);
	}

	function edgeEventByPoints(tcx, ep, eq, triangle, point) {
	    if (isEdgeSideOfTriangle(triangle, ep, eq)) {
	        return;
	    }

	    var p1 = triangle.pointCCW(point);
	    var o1 = orient2d(eq, p1, ep);
	    if (o1 === Orientation.COLLINEAR) {
	        // TODO integrate here changes from C++ version
	        // (C++ repo revision 09880a869095 dated March 8, 2011)
	        throw new PointError$1('poly2tri EdgeEvent: Collinear not supported!', [eq, p1, ep]);
	    }

	    var p2 = triangle.pointCW(point);
	    var o2 = orient2d(eq, p2, ep);
	    if (o2 === Orientation.COLLINEAR) {
	        // TODO integrate here changes from C++ version
	        // (C++ repo revision 09880a869095 dated March 8, 2011)
	        throw new PointError$1('poly2tri EdgeEvent: Collinear not supported!', [eq, p2, ep]);
	    }

	    if (o1 === o2) {
	        // Need to decide if we are rotating CW or CCW to get to a triangle
	        // that will cross edge
	        if (o1 === Orientation.CW) {
	            triangle = triangle.neighborCCW(point);
	        } else {
	            triangle = triangle.neighborCW(point);
	        }
	        edgeEventByPoints(tcx, ep, eq, triangle, point);
	    } else {
	        // This triangle crosses constraint so lets flippin start!
	        flipEdgeEvent(tcx, ep, eq, triangle, point);
	    }
	}

	function isEdgeSideOfTriangle(triangle, ep, eq) {
	    var index = triangle.edgeIndex(ep, eq);
	    if (index !== -1) {
	        triangle.markConstrainedEdgeByIndex(index);
	        var t = triangle.getNeighbor(index);
	        if (t) {
	            t.markConstrainedEdgeByPoints(ep, eq);
	        }
	        return true;
	    }
	    return false;
	}

	/**
	 * Creates a new front triangle and legalize it
	 * @param {!SweepContext} tcx - SweepContext object
	 */
	function newFrontTriangle(tcx, point, node) {
	    var triangle = new Triangle$1(point, node.point, node.next.point);

	    triangle.markNeighbor(node.triangle);
	    tcx.addToMap(triangle);

	    var new_node = new Node$1(point);
	    new_node.next = node.next;
	    new_node.prev = node;
	    node.next.prev = new_node;
	    node.next = new_node;

	    if (!legalize(tcx, triangle)) {
	        tcx.mapTriangleToNodes(triangle);
	    }

	    return new_node;
	}

	/**
	 * Adds a triangle to the advancing front to fill a hole.
	 * @param {!SweepContext} tcx - SweepContext object
	 * @param node - middle node, that is the bottom of the hole
	 */
	function fill(tcx, node) {
	    var triangle = new Triangle$1(node.prev.point, node.point, node.next.point);

	    // TODO: should copy the constrained_edge value from neighbor triangles
	    //       for now constrained_edge values are copied during the legalize
	    triangle.markNeighbor(node.prev.triangle);
	    triangle.markNeighbor(node.triangle);

	    tcx.addToMap(triangle);

	    // Update the advancing front
	    node.prev.next = node.next;
	    node.next.prev = node.prev;


	    // If it was legalized the triangle has already been mapped
	    if (!legalize(tcx, triangle)) {
	        tcx.mapTriangleToNodes(triangle);
	    }

	    //tcx.removeNode(node);
	}

	/**
	 * Fills holes in the Advancing Front
	 * @param {!SweepContext} tcx - SweepContext object
	 */
	function fillAdvancingFront(tcx, n) {
	    // Fill right holes
	    var node = n.next;
	    while (node.next) {
	        // TODO integrate here changes from C++ version
	        // (C++ repo revision acf81f1f1764 dated April 7, 2012)
	        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {
	            break;
	        }
	        fill(tcx, node);
	        node = node.next;
	    }

	    // Fill left holes
	    node = n.prev;
	    while (node.prev) {
	        // TODO integrate here changes from C++ version
	        // (C++ repo revision acf81f1f1764 dated April 7, 2012)
	        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {
	            break;
	        }
	        fill(tcx, node);
	        node = node.prev;
	    }

	    // Fill right basins
	    if (n.next && n.next.next) {
	        if (isBasinAngleRight(n)) {
	            fillBasin(tcx, n);
	        }
	    }
	}

	/**
	 * The basin angle is decided against the horizontal line [1,0].
	 * @param {Node} node
	 * @return {boolean} true if angle < 3*π/4
	 */
	function isBasinAngleRight(node) {
	    var ax = node.point.x - node.next.next.point.x;
	    var ay = node.point.y - node.next.next.point.y;
	    assert(ay >= 0, "unordered y");
	    return (ax >= 0 || Math.abs(ax) < ay);
	}

	/**
	 * Returns true if triangle was legalized
	 * @param {!SweepContext} tcx - SweepContext object
	 * @return {boolean}
	 */
	function legalize(tcx, t) {
	    // To legalize a triangle we start by finding if any of the three edges
	    // violate the Delaunay condition
	    for (var i = 0; i < 3; ++i) {
	        if (t.delaunay_edge[i]) {
	            continue;
	        }
	        var ot = t.getNeighbor(i);
	        if (ot) {
	            var p = t.getPoint(i);
	            var op = ot.oppositePoint(t, p);
	            var oi = ot.index(op);

	            // If this is a Constrained Edge or a Delaunay Edge(only during recursive legalization)
	            // then we should not try to legalize
	            if (ot.constrained_edge[oi] || ot.delaunay_edge[oi]) {
	                t.constrained_edge[i] = ot.constrained_edge[oi];
	                continue;
	            }

	            var inside = inCircle(p, t.pointCCW(p), t.pointCW(p), op);
	            if (inside) {
	                // Lets mark this shared edge as Delaunay
	                t.delaunay_edge[i] = true;
	                ot.delaunay_edge[oi] = true;

	                // Lets rotate shared edge one vertex CW to legalize it
	                rotateTrianglePair(t, p, ot, op);

	                // We now got one valid Delaunay Edge shared by two triangles
	                // This gives us 4 new edges to check for Delaunay

	                // Make sure that triangle to node mapping is done only one time for a specific triangle
	                var not_legalized = !legalize(tcx, t);
	                if (not_legalized) {
	                    tcx.mapTriangleToNodes(t);
	                }

	                not_legalized = !legalize(tcx, ot);
	                if (not_legalized) {
	                    tcx.mapTriangleToNodes(ot);
	                }
	                // Reset the Delaunay edges, since they only are valid Delaunay edges
	                // until we add a new triangle or point.
	                // XXX: need to think about this. Can these edges be tried after we
	                //      return to previous recursive level?
	                t.delaunay_edge[i] = false;
	                ot.delaunay_edge[oi] = false;

	                // If triangle have been legalized no need to check the other edges since
	                // the recursive legalization will handles those so we can end here.
	                return true;
	            }
	        }
	    }
	    return false;
	}

	/**
	 * <b>Requirement</b>:<br>
	 * 1. a,b and c form a triangle.<br>
	 * 2. a and d is know to be on opposite side of bc<br>
	 * <pre>
	 *                a
	 *                +
	 *               / \
	 *              /   \
	 *            b/     \c
	 *            +-------+
	 *           /    d    \
	 *          /           \
	 * </pre>
	 * <b>Fact</b>: d has to be in area B to have a chance to be inside the circle formed by
	 *  a,b and c<br>
	 *  d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW<br>
	 *  This preknowledge gives us a way to optimize the incircle test
	 * @param pa - triangle point, opposite d
	 * @param pb - triangle point
	 * @param pc - triangle point
	 * @param pd - point opposite a
	 * @return {boolean} true if d is inside circle, false if on circle edge
	 */
	function inCircle(pa, pb, pc, pd) {
	    var adx = pa.x - pd.x;
	    var ady = pa.y - pd.y;
	    var bdx = pb.x - pd.x;
	    var bdy = pb.y - pd.y;

	    var adxbdy = adx * bdy;
	    var bdxady = bdx * ady;
	    var oabd = adxbdy - bdxady;
	    if (oabd <= 0) {
	        return false;
	    }

	    var cdx = pc.x - pd.x;
	    var cdy = pc.y - pd.y;

	    var cdxady = cdx * ady;
	    var adxcdy = adx * cdy;
	    var ocad = cdxady - adxcdy;
	    if (ocad <= 0) {
	        return false;
	    }

	    var bdxcdy = bdx * cdy;
	    var cdxbdy = cdx * bdy;

	    var alift = adx * adx + ady * ady;
	    var blift = bdx * bdx + bdy * bdy;
	    var clift = cdx * cdx + cdy * cdy;

	    var det = alift * (bdxcdy - cdxbdy) + blift * ocad + clift * oabd;
	    return det > 0;
	}

	/**
	 * Rotates a triangle pair one vertex CW
	 *<pre>
	 *       n2                    n2
	 *  P +-----+             P +-----+
	 *    | t  /|               |\  t |
	 *    |   / |               | \   |
	 *  n1|  /  |n3           n1|  \  |n3
	 *    | /   |    after CW   |   \ |
	 *    |/ oT |               | oT \|
	 *    +-----+ oP            +-----+
	 *       n4                    n4
	 * </pre>
	 */
	function rotateTrianglePair(t, p, ot, op) {
	    var n1, n2, n3, n4;
	    n1 = t.neighborCCW(p);
	    n2 = t.neighborCW(p);
	    n3 = ot.neighborCCW(op);
	    n4 = ot.neighborCW(op);

	    var ce1, ce2, ce3, ce4;
	    ce1 = t.getConstrainedEdgeCCW(p);
	    ce2 = t.getConstrainedEdgeCW(p);
	    ce3 = ot.getConstrainedEdgeCCW(op);
	    ce4 = ot.getConstrainedEdgeCW(op);

	    var de1, de2, de3, de4;
	    de1 = t.getDelaunayEdgeCCW(p);
	    de2 = t.getDelaunayEdgeCW(p);
	    de3 = ot.getDelaunayEdgeCCW(op);
	    de4 = ot.getDelaunayEdgeCW(op);

	    t.legalize(p, op);
	    ot.legalize(op, p);

	    // Remap delaunay_edge
	    ot.setDelaunayEdgeCCW(p, de1);
	    t.setDelaunayEdgeCW(p, de2);
	    t.setDelaunayEdgeCCW(op, de3);
	    ot.setDelaunayEdgeCW(op, de4);

	    // Remap constrained_edge
	    ot.setConstrainedEdgeCCW(p, ce1);
	    t.setConstrainedEdgeCW(p, ce2);
	    t.setConstrainedEdgeCCW(op, ce3);
	    ot.setConstrainedEdgeCW(op, ce4);

	    // Remap neighbors
	    // XXX: might optimize the markNeighbor by keeping track of
	    //      what side should be assigned to what neighbor after the
	    //      rotation. Now mark neighbor does lots of testing to find
	    //      the right side.
	    t.clearNeighbors();
	    ot.clearNeighbors();
	    if (n1) {
	        ot.markNeighbor(n1);
	    }
	    if (n2) {
	        t.markNeighbor(n2);
	    }
	    if (n3) {
	        t.markNeighbor(n3);
	    }
	    if (n4) {
	        ot.markNeighbor(n4);
	    }
	    t.markNeighbor(ot);
	}

	/**
	 * Fills a basin that has formed on the Advancing Front to the right
	 * of given node.<br>
	 * First we decide a left,bottom and right node that forms the
	 * boundaries of the basin. Then we do a reqursive fill.
	 *
	 * @param {!SweepContext} tcx - SweepContext object
	 * @param node - starting node, this or next node will be left node
	 */
	function fillBasin(tcx, node) {
	    if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
	        tcx.basin.left_node = node.next.next;
	    } else {
	        tcx.basin.left_node = node.next;
	    }

	    // Find the bottom and right node
	    tcx.basin.bottom_node = tcx.basin.left_node;
	    while (tcx.basin.bottom_node.next && tcx.basin.bottom_node.point.y >= tcx.basin.bottom_node.next.point.y) {
	        tcx.basin.bottom_node = tcx.basin.bottom_node.next;
	    }
	    if (tcx.basin.bottom_node === tcx.basin.left_node) {
	        // No valid basin
	        return;
	    }

	    tcx.basin.right_node = tcx.basin.bottom_node;
	    while (tcx.basin.right_node.next && tcx.basin.right_node.point.y < tcx.basin.right_node.next.point.y) {
	        tcx.basin.right_node = tcx.basin.right_node.next;
	    }
	    if (tcx.basin.right_node === tcx.basin.bottom_node) {
	        // No valid basins
	        return;
	    }

	    tcx.basin.width = tcx.basin.right_node.point.x - tcx.basin.left_node.point.x;
	    tcx.basin.left_highest = tcx.basin.left_node.point.y > tcx.basin.right_node.point.y;

	    fillBasinReq(tcx, tcx.basin.bottom_node);
	}

	/**
	 * Recursive algorithm to fill a Basin with triangles
	 *
	 * @param {!SweepContext} tcx - SweepContext object
	 * @param node - bottom_node
	 */
	function fillBasinReq(tcx, node) {
	    // if shallow stop filling
	    if (isShallow(tcx, node)) {
	        return;
	    }

	    fill(tcx, node);

	    var o;
	    if (node.prev === tcx.basin.left_node && node.next === tcx.basin.right_node) {
	        return;
	    } else if (node.prev === tcx.basin.left_node) {
	        o = orient2d(node.point, node.next.point, node.next.next.point);
	        if (o === Orientation.CW) {
	            return;
	        }
	        node = node.next;
	    } else if (node.next === tcx.basin.right_node) {
	        o = orient2d(node.point, node.prev.point, node.prev.prev.point);
	        if (o === Orientation.CCW) {
	            return;
	        }
	        node = node.prev;
	    } else {
	        // Continue with the neighbor node with lowest Y value
	        if (node.prev.point.y < node.next.point.y) {
	            node = node.prev;
	        } else {
	            node = node.next;
	        }
	    }

	    fillBasinReq(tcx, node);
	}

	function isShallow(tcx, node) {
	    var height;
	    if (tcx.basin.left_highest) {
	        height = tcx.basin.left_node.point.y - node.point.y;
	    } else {
	        height = tcx.basin.right_node.point.y - node.point.y;
	    }

	    // if shallow stop filling
	    if (tcx.basin.width > height) {
	        return true;
	    }
	    return false;
	}

	function fillEdgeEvent(tcx, edge, node) {
	    if (tcx.edge_event.right) {
	        fillRightAboveEdgeEvent(tcx, edge, node);
	    } else {
	        fillLeftAboveEdgeEvent(tcx, edge, node);
	    }
	}

	function fillRightAboveEdgeEvent(tcx, edge, node) {
	    while (node.next.point.x < edge.p.x) {
	        // Check if next node is below the edge
	        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
	            fillRightBelowEdgeEvent(tcx, edge, node);
	        } else {
	            node = node.next;
	        }
	    }
	}

	function fillRightBelowEdgeEvent(tcx, edge, node) {
	    if (node.point.x < edge.p.x) {
	        if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
	            // Concave
	            fillRightConcaveEdgeEvent(tcx, edge, node);
	        } else {
	            // Convex
	            fillRightConvexEdgeEvent(tcx, edge, node);
	            // Retry this one
	            fillRightBelowEdgeEvent(tcx, edge, node);
	        }
	    }
	}

	function fillRightConcaveEdgeEvent(tcx, edge, node) {
	    fill(tcx, node.next);
	    if (node.next.point !== edge.p) {
	        // Next above or below edge?
	        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
	            // Below
	            if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
	                // Next is concave
	                fillRightConcaveEdgeEvent(tcx, edge, node);
	            }
	        }
	    }
	}

	function fillRightConvexEdgeEvent(tcx, edge, node) {
	    // Next concave or convex?
	    if (orient2d(node.next.point, node.next.next.point, node.next.next.next.point) === Orientation.CCW) {
	        // Concave
	        fillRightConcaveEdgeEvent(tcx, edge, node.next);
	    } else {
	        // Convex
	        // Next above or below edge?
	        if (orient2d(edge.q, node.next.next.point, edge.p) === Orientation.CCW) {
	            // Below
	            fillRightConvexEdgeEvent(tcx, edge, node.next);
	        }
	    }
	}

	function fillLeftAboveEdgeEvent(tcx, edge, node) {
	    while (node.prev.point.x > edge.p.x) {
	        // Check if next node is below the edge
	        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
	            fillLeftBelowEdgeEvent(tcx, edge, node);
	        } else {
	            node = node.prev;
	        }
	    }
	}

	function fillLeftBelowEdgeEvent(tcx, edge, node) {
	    if (node.point.x > edge.p.x) {
	        if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
	            // Concave
	            fillLeftConcaveEdgeEvent(tcx, edge, node);
	        } else {
	            // Convex
	            fillLeftConvexEdgeEvent(tcx, edge, node);
	            // Retry this one
	            fillLeftBelowEdgeEvent(tcx, edge, node);
	        }
	    }
	}

	function fillLeftConvexEdgeEvent(tcx, edge, node) {
	    // Next concave or convex?
	    if (orient2d(node.prev.point, node.prev.prev.point, node.prev.prev.prev.point) === Orientation.CW) {
	        // Concave
	        fillLeftConcaveEdgeEvent(tcx, edge, node.prev);
	    } else {
	        // Convex
	        // Next above or below edge?
	        if (orient2d(edge.q, node.prev.prev.point, edge.p) === Orientation.CW) {
	            // Below
	            fillLeftConvexEdgeEvent(tcx, edge, node.prev);
	        }
	    }
	}

	function fillLeftConcaveEdgeEvent(tcx, edge, node) {
	    fill(tcx, node.prev);
	    if (node.prev.point !== edge.p) {
	        // Next above or below edge?
	        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
	            // Below
	            if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
	                // Next is concave
	                fillLeftConcaveEdgeEvent(tcx, edge, node);
	            }
	        }
	    }
	}

	function flipEdgeEvent(tcx, ep, eq, t, p) {
	    var ot = t.neighborAcross(p);
	    assert(ot, "FLIP failed due to missing triangle!");

	    var op = ot.oppositePoint(t, p);

	    // Additional check from Java version (see issue #88)
	    if (t.getConstrainedEdgeAcross(p)) {
	        var index = t.index(p);
	        throw new PointError$1("poly2tri Intersecting Constraints",
	                [p, op, t.getPoint((index + 1) % 3), t.getPoint((index + 2) % 3)]);
	    }

	    if (inScanArea(p, t.pointCCW(p), t.pointCW(p), op)) {
	        // Lets rotate shared edge one vertex CW
	        rotateTrianglePair(t, p, ot, op);
	        tcx.mapTriangleToNodes(t);
	        tcx.mapTriangleToNodes(ot);

	        // XXX: in the original C++ code for the next 2 lines, we are
	        // comparing point values (and not pointers). In this JavaScript
	        // code, we are comparing point references (pointers). This works
	        // because we can't have 2 different points with the same values.
	        // But to be really equivalent, we should use "Point.equals" here.
	        if (p === eq && op === ep) {
	            if (eq === tcx.edge_event.constrained_edge.q && ep === tcx.edge_event.constrained_edge.p) {
	                t.markConstrainedEdgeByPoints(ep, eq);
	                ot.markConstrainedEdgeByPoints(ep, eq);
	                legalize(tcx, t);
	                legalize(tcx, ot);
	            }
	        } else {
	            var o = orient2d(eq, op, ep);
	            t = nextFlipTriangle(tcx, o, t, ot, p, op);
	            flipEdgeEvent(tcx, ep, eq, t, p);
	        }
	    } else {
	        var newP = nextFlipPoint(ep, eq, ot, op);
	        flipScanEdgeEvent(tcx, ep, eq, t, ot, newP);
	        edgeEventByPoints(tcx, ep, eq, t, p);
	    }
	}

	/**
	 * After a flip we have two triangles and know that only one will still be
	 * intersecting the edge. So decide which to contiune with and legalize the other
	 *
	 * @param {!SweepContext} tcx - SweepContext object
	 * @param o - should be the result of an orient2d( eq, op, ep )
	 * @param t - triangle 1
	 * @param ot - triangle 2
	 * @param p - a point shared by both triangles
	 * @param op - another point shared by both triangles
	 * @return returns the triangle still intersecting the edge
	 */
	function nextFlipTriangle(tcx, o, t, ot, p, op) {
	    var edge_index;
	    if (o === Orientation.CCW) {
	        // ot is not crossing edge after flip
	        edge_index = ot.edgeIndex(p, op);
	        ot.delaunay_edge[edge_index] = true;
	        legalize(tcx, ot);
	        ot.clearDelaunayEdges();
	        return t;
	    }

	    // t is not crossing edge after flip
	    edge_index = t.edgeIndex(p, op);

	    t.delaunay_edge[edge_index] = true;
	    legalize(tcx, t);
	    t.clearDelaunayEdges();
	    return ot;
	}

	/**
	 * When we need to traverse from one triangle to the next we need
	 * the point in current triangle that is the opposite point to the next
	 * triangle.
	 */
	function nextFlipPoint(ep, eq, ot, op) {
	    var o2d = orient2d(eq, op, ep);
	    if (o2d === Orientation.CW) {
	        // Right
	        return ot.pointCCW(op);
	    } else if (o2d === Orientation.CCW) {
	        // Left
	        return ot.pointCW(op);
	    } else {
	        throw new PointError$1("poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!", [eq, op, ep]);
	    }
	}

	/**
	 * Scan part of the FlipScan algorithm<br>
	 * When a triangle pair isn't flippable we will scan for the next
	 * point that is inside the flip triangle scan area. When found
	 * we generate a new flipEdgeEvent
	 *
	 * @param {!SweepContext} tcx - SweepContext object
	 * @param ep - last point on the edge we are traversing
	 * @param eq - first point on the edge we are traversing
	 * @param {!Triangle} flip_triangle - the current triangle sharing the point eq with edge
	 * @param t
	 * @param p
	 */
	function flipScanEdgeEvent(tcx, ep, eq, flip_triangle, t, p) {
	    var ot = t.neighborAcross(p);
	    assert(ot, "FLIP failed due to missing triangle");

	    var op = ot.oppositePoint(t, p);

	    if (inScanArea(eq, flip_triangle.pointCCW(eq), flip_triangle.pointCW(eq), op)) {
	        // flip with new edge op.eq
	        flipEdgeEvent(tcx, eq, op, ot, op);
	    } else {
	        var newP = nextFlipPoint(ep, eq, ot, op);
	        flipScanEdgeEvent(tcx, ep, eq, flip_triangle, ot, newP);
	    }
	}


	// ----------------------------------------------------------------------Exports

	sweep$1.triangulate = triangulate$1;

	/*
	 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
	 * http://code.google.com/p/poly2tri/
	 * 
	 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
	 * https://github.com/r3mi/poly2tri.js
	 * 
	 * All rights reserved.
	 * 
	 * Distributed under the 3-clause BSD License, see LICENSE.txt
	 */


	/*
	 * Note
	 * ====
	 * the structure of this JavaScript version of poly2tri intentionally follows
	 * as closely as possible the structure of the reference C++ version, to make it 
	 * easier to keep the 2 versions in sync.
	 */

	var PointError = pointerror;
	var Point = point;
	var Triangle = triangle;
	var sweep = sweep$1;
	var AdvancingFront = advancingfront.exports;
	var Node = AdvancingFront.Node;


	// ------------------------------------------------------------------------utils

	/**
	 * Initial triangle factor, seed triangle will extend 30% of
	 * PointSet width to both left and right.
	 * @private
	 * @const
	 */
	var kAlpha = 0.3;


	// -------------------------------------------------------------------------Edge
	/**
	 * Represents a simple polygon's edge
	 * @constructor
	 * @struct
	 * @private
	 * @param {Point} p1
	 * @param {Point} p2
	 * @throw {PointError} if p1 is same as p2
	 */
	var Edge = function(p1, p2) {
	    this.p = p1;
	    this.q = p2;

	    if (p1.y > p2.y) {
	        this.q = p1;
	        this.p = p2;
	    } else if (p1.y === p2.y) {
	        if (p1.x > p2.x) {
	            this.q = p1;
	            this.p = p2;
	        } else if (p1.x === p2.x) {
	            throw new PointError('poly2tri Invalid Edge constructor: repeated points!', [p1]);
	        }
	    }

	    if (!this.q._p2t_edge_list) {
	        this.q._p2t_edge_list = [];
	    }
	    this.q._p2t_edge_list.push(this);
	};


	// ------------------------------------------------------------------------Basin
	/**
	 * @constructor
	 * @struct
	 * @private
	 */
	var Basin = function() {
	    /** @type {Node} */
	    this.left_node = null;
	    /** @type {Node} */
	    this.bottom_node = null;
	    /** @type {Node} */
	    this.right_node = null;
	    /** @type {number} */
	    this.width = 0.0;
	    /** @type {boolean} */
	    this.left_highest = false;
	};

	Basin.prototype.clear = function() {
	    this.left_node = null;
	    this.bottom_node = null;
	    this.right_node = null;
	    this.width = 0.0;
	    this.left_highest = false;
	};

	// --------------------------------------------------------------------EdgeEvent
	/**
	 * @constructor
	 * @struct
	 * @private
	 */
	var EdgeEvent = function() {
	    /** @type {Edge} */
	    this.constrained_edge = null;
	    /** @type {boolean} */
	    this.right = false;
	};

	// ----------------------------------------------------SweepContext (public API)
	/**
	 * SweepContext constructor option
	 * @typedef {Object} SweepContextOptions
	 * @property {boolean=} cloneArrays - if <code>true</code>, do a shallow copy of the Array parameters
	 *                  (contour, holes). Points inside arrays are never copied.
	 *                  Default is <code>false</code> : keep a reference to the array arguments,
	 *                  who will be modified in place.
	 */
	/**
	 * Constructor for the triangulation context.
	 * It accepts a simple polyline (with non repeating points), 
	 * which defines the constrained edges.
	 *
	 * @example
	 *          var contour = [
	 *              new poly2tri.Point(100, 100),
	 *              new poly2tri.Point(100, 300),
	 *              new poly2tri.Point(300, 300),
	 *              new poly2tri.Point(300, 100)
	 *          ];
	 *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});
	 * @example
	 *          var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];
	 *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});
	 * @constructor
	 * @public
	 * @struct
	 * @param {Array.<XY>} contour - array of point objects. The points can be either {@linkcode Point} instances,
	 *          or any "Point like" custom class with <code>&#123;x, y&#125;</code> attributes.
	 * @param {SweepContextOptions=} options - constructor options
	 */
	var SweepContext = function(contour, options) {
	    options = options || {};
	    this.triangles_ = [];
	    this.map_ = [];
	    this.points_ = (options.cloneArrays ? contour.slice(0) : contour);
	    this.edge_list = [];

	    // Bounding box of all points. Computed at the start of the triangulation, 
	    // it is stored in case it is needed by the caller.
	    this.pmin_ = this.pmax_ = null;

	    /**
	     * Advancing front
	     * @private
	     * @type {AdvancingFront}
	     */
	    this.front_ = null;

	    /**
	     * head point used with advancing front
	     * @private
	     * @type {Point}
	     */
	    this.head_ = null;

	    /**
	     * tail point used with advancing front
	     * @private
	     * @type {Point}
	     */
	    this.tail_ = null;

	    /**
	     * @private
	     * @type {Node}
	     */
	    this.af_head_ = null;
	    /**
	     * @private
	     * @type {Node}
	     */
	    this.af_middle_ = null;
	    /**
	     * @private
	     * @type {Node}
	     */
	    this.af_tail_ = null;

	    this.basin = new Basin();
	    this.edge_event = new EdgeEvent();

	    this.initEdges(this.points_);
	};


	/**
	 * Add a hole to the constraints
	 * @example
	 *      var swctx = new poly2tri.SweepContext(contour);
	 *      var hole = [
	 *          new poly2tri.Point(200, 200),
	 *          new poly2tri.Point(200, 250),
	 *          new poly2tri.Point(250, 250)
	 *      ];
	 *      swctx.addHole(hole);
	 * @example
	 *      var swctx = new poly2tri.SweepContext(contour);
	 *      swctx.addHole([{x:200, y:200}, {x:200, y:250}, {x:250, y:250}]);
	 * @public
	 * @param {Array.<XY>} polyline - array of "Point like" objects with {x,y}
	 */
	SweepContext.prototype.addHole = function(polyline) {
	    this.initEdges(polyline);
	    var i, len = polyline.length;
	    for (i = 0; i < len; i++) {
	        this.points_.push(polyline[i]);
	    }
	    return this; // for chaining
	};

	/**
	 * For backward compatibility
	 * @function
	 * @deprecated use {@linkcode SweepContext#addHole} instead
	 */
	SweepContext.prototype.AddHole = SweepContext.prototype.addHole;


	/**
	 * Add several holes to the constraints
	 * @example
	 *      var swctx = new poly2tri.SweepContext(contour);
	 *      var holes = [
	 *          [ new poly2tri.Point(200, 200), new poly2tri.Point(200, 250), new poly2tri.Point(250, 250) ],
	 *          [ new poly2tri.Point(300, 300), new poly2tri.Point(300, 350), new poly2tri.Point(350, 350) ]
	 *      ];
	 *      swctx.addHoles(holes);
	 * @example
	 *      var swctx = new poly2tri.SweepContext(contour);
	 *      var holes = [
	 *          [{x:200, y:200}, {x:200, y:250}, {x:250, y:250}],
	 *          [{x:300, y:300}, {x:300, y:350}, {x:350, y:350}]
	 *      ];
	 *      swctx.addHoles(holes);
	 * @public
	 * @param {Array.<Array.<XY>>} holes - array of array of "Point like" objects with {x,y}
	 */
	// Method added in the JavaScript version (was not present in the c++ version)
	SweepContext.prototype.addHoles = function(holes) {
	    var i, len = holes.length;
	    for (i = 0; i < len; i++) {
	        this.initEdges(holes[i]);
	    }
	    this.points_ = this.points_.concat.apply(this.points_, holes);
	    return this; // for chaining
	};


	/**
	 * Add a Steiner point to the constraints
	 * @example
	 *      var swctx = new poly2tri.SweepContext(contour);
	 *      var point = new poly2tri.Point(150, 150);
	 *      swctx.addPoint(point);
	 * @example
	 *      var swctx = new poly2tri.SweepContext(contour);
	 *      swctx.addPoint({x:150, y:150});
	 * @public
	 * @param {XY} point - any "Point like" object with {x,y}
	 */
	SweepContext.prototype.addPoint = function(point) {
	    this.points_.push(point);
	    return this; // for chaining
	};

	/**
	 * For backward compatibility
	 * @function
	 * @deprecated use {@linkcode SweepContext#addPoint} instead
	 */
	SweepContext.prototype.AddPoint = SweepContext.prototype.addPoint;


	/**
	 * Add several Steiner points to the constraints
	 * @example
	 *      var swctx = new poly2tri.SweepContext(contour);
	 *      var points = [
	 *          new poly2tri.Point(150, 150),
	 *          new poly2tri.Point(200, 250),
	 *          new poly2tri.Point(250, 250)
	 *      ];
	 *      swctx.addPoints(points);
	 * @example
	 *      var swctx = new poly2tri.SweepContext(contour);
	 *      swctx.addPoints([{x:150, y:150}, {x:200, y:250}, {x:250, y:250}]);
	 * @public
	 * @param {Array.<XY>} points - array of "Point like" object with {x,y}
	 */
	// Method added in the JavaScript version (was not present in the c++ version)
	SweepContext.prototype.addPoints = function(points) {
	    this.points_ = this.points_.concat(points);
	    return this; // for chaining
	};


	/**
	 * Triangulate the polygon with holes and Steiner points.
	 * Do this AFTER you've added the polyline, holes, and Steiner points
	 * @example
	 *      var swctx = new poly2tri.SweepContext(contour);
	 *      swctx.triangulate();
	 *      var triangles = swctx.getTriangles();
	 * @public
	 */
	// Shortcut method for sweep.triangulate(SweepContext).
	// Method added in the JavaScript version (was not present in the c++ version)
	SweepContext.prototype.triangulate = function() {
	    sweep.triangulate(this);
	    return this; // for chaining
	};


	/**
	 * Get the bounding box of the provided constraints (contour, holes and 
	 * Steinter points). Warning : these values are not available if the triangulation 
	 * has not been done yet.
	 * @public
	 * @returns {min:Point,max:Point} object with 'min' and 'max' Point
	 */
	// Method added in the JavaScript version (was not present in the c++ version)
	SweepContext.prototype.getBoundingBox = function() {
	    return {min: this.pmin_, max: this.pmax_};
	};

	/**
	 * Get result of triangulation.
	 * The output triangles have vertices which are references
	 * to the initial input points (not copies): any custom fields in the
	 * initial points can be retrieved in the output triangles.
	 * @example
	 *      var swctx = new poly2tri.SweepContext(contour);
	 *      swctx.triangulate();
	 *      var triangles = swctx.getTriangles();
	 * @example
	 *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];
	 *      var swctx = new poly2tri.SweepContext(contour);
	 *      swctx.triangulate();
	 *      var triangles = swctx.getTriangles();
	 *      typeof triangles[0].getPoint(0).id
	 *      // → "number"
	 * @public
	 * @returns {array<Triangle>}   array of triangles
	 */
	SweepContext.prototype.getTriangles = function() {
	    return this.triangles_;
	};

	/**
	 * For backward compatibility
	 * @function
	 * @deprecated use {@linkcode SweepContext#getTriangles} instead
	 */
	SweepContext.prototype.GetTriangles = SweepContext.prototype.getTriangles;


	// ---------------------------------------------------SweepContext (private API)

	/** @private */
	SweepContext.prototype.front = function() {
	    return this.front_;
	};

	/** @private */
	SweepContext.prototype.pointCount = function() {
	    return this.points_.length;
	};

	/** @private */
	SweepContext.prototype.head = function() {
	    return this.head_;
	};

	/** @private */
	SweepContext.prototype.setHead = function(p1) {
	    this.head_ = p1;
	};

	/** @private */
	SweepContext.prototype.tail = function() {
	    return this.tail_;
	};

	/** @private */
	SweepContext.prototype.setTail = function(p1) {
	    this.tail_ = p1;
	};

	/** @private */
	SweepContext.prototype.getMap = function() {
	    return this.map_;
	};

	/** @private */
	SweepContext.prototype.initTriangulation = function() {
	    var xmax = this.points_[0].x;
	    var xmin = this.points_[0].x;
	    var ymax = this.points_[0].y;
	    var ymin = this.points_[0].y;

	    // Calculate bounds
	    var i, len = this.points_.length;
	    for (i = 1; i < len; i++) {
	        var p = this.points_[i];
	        /* jshint expr:true */
	        (p.x > xmax) && (xmax = p.x);
	        (p.x < xmin) && (xmin = p.x);
	        (p.y > ymax) && (ymax = p.y);
	        (p.y < ymin) && (ymin = p.y);
	    }
	    this.pmin_ = new Point(xmin, ymin);
	    this.pmax_ = new Point(xmax, ymax);

	    var dx = kAlpha * (xmax - xmin);
	    var dy = kAlpha * (ymax - ymin);
	    this.head_ = new Point(xmax + dx, ymin - dy);
	    this.tail_ = new Point(xmin - dx, ymin - dy);

	    // Sort points along y-axis
	    this.points_.sort(Point.compare);
	};

	/** @private */
	SweepContext.prototype.initEdges = function(polyline) {
	    var i, len = polyline.length;
	    for (i = 0; i < len; ++i) {
	        this.edge_list.push(new Edge(polyline[i], polyline[(i + 1) % len]));
	    }
	};

	/** @private */
	SweepContext.prototype.getPoint = function(index) {
	    return this.points_[index];
	};

	/** @private */
	SweepContext.prototype.addToMap = function(triangle) {
	    this.map_.push(triangle);
	};

	/** @private */
	SweepContext.prototype.locateNode = function(point) {
	    return this.front_.locateNode(point.x);
	};

	/** @private */
	SweepContext.prototype.createAdvancingFront = function() {
	    var head;
	    var middle;
	    var tail;
	    // Initial triangle
	    var triangle = new Triangle(this.points_[0], this.tail_, this.head_);

	    this.map_.push(triangle);

	    head = new Node(triangle.getPoint(1), triangle);
	    middle = new Node(triangle.getPoint(0), triangle);
	    tail = new Node(triangle.getPoint(2));

	    this.front_ = new AdvancingFront(head, tail);

	    head.next = middle;
	    middle.next = tail;
	    middle.prev = head;
	    tail.prev = middle;
	};

	/** @private */
	SweepContext.prototype.removeNode = function(node) {
	    // do nothing
	    /* jshint unused:false */
	};

	/** @private */
	SweepContext.prototype.mapTriangleToNodes = function(t) {
	    for (var i = 0; i < 3; ++i) {
	        if (!t.getNeighbor(i)) {
	            var n = this.front_.locatePoint(t.pointCW(t.getPoint(i)));
	            if (n) {
	                n.triangle = t;
	            }
	        }
	    }
	};

	/** @private */
	SweepContext.prototype.removeFromMap = function(triangle) {
	    var i, map = this.map_, len = map.length;
	    for (i = 0; i < len; i++) {
	        if (map[i] === triangle) {
	            map.splice(i, 1);
	            break;
	        }
	    }
	};

	/**
	 * Do a depth first traversal to collect triangles
	 * @private
	 * @param {Triangle} triangle start
	 */
	SweepContext.prototype.meshClean = function(triangle) {
	    // New implementation avoids recursive calls and use a loop instead.
	    // Cf. issues # 57, 65 and 69.
	    var triangles = [triangle], t, i;
	    /* jshint boss:true */
	    while (t = triangles.pop()) {
	        if (!t.isInterior()) {
	            t.setInterior(true);
	            this.triangles_.push(t);
	            for (i = 0; i < 3; i++) {
	                if (!t.constrained_edge[i]) {
	                    triangles.push(t.getNeighbor(i));
	                }
	            }
	        }
	    }
	};

	// ----------------------------------------------------------------------Exports

	var sweepcontext = SweepContext;

	/*
	 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
	 * http://code.google.com/p/poly2tri/
	 * 
	 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
	 * https://github.com/r3mi/poly2tri.js
	 *
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without modification,
	 * are permitted provided that the following conditions are met:
	 *
	 * * Redistributions of source code must retain the above copyright notice,
	 *   this list of conditions and the following disclaimer.
	 * * Redistributions in binary form must reproduce the above copyright notice,
	 *   this list of conditions and the following disclaimer in the documentation
	 *   and/or other materials provided with the distribution.
	 * * Neither the name of Poly2Tri nor the names of its contributors may be
	 *   used to endorse or promote products derived from this software without specific
	 *   prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
	 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
	 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
	 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */

	(function (exports) {

	/**
	 * Public API for poly2tri.js
	 * @module poly2tri
	 */


	/**
	 * If you are not using a module system (e.g. CommonJS, RequireJS), you can access this library
	 * as a global variable <code>poly2tri</code> i.e. <code>window.poly2tri</code> in a browser.
	 * @name poly2tri
	 * @global
	 * @public
	 * @type {module:poly2tri}
	 */
	var previousPoly2tri = commonjsGlobal.poly2tri;
	/**
	 * For Browser + &lt;script&gt; :
	 * reverts the {@linkcode poly2tri} global object to its previous value,
	 * and returns a reference to the instance called.
	 *
	 * @example
	 *              var p = poly2tri.noConflict();
	 * @public
	 * @return {module:poly2tri} instance called
	 */
	// (this feature is not automatically provided by browserify).
	exports.noConflict = function() {
	    commonjsGlobal.poly2tri = previousPoly2tri;
	    return exports;
	};

	/**
	 * poly2tri library version
	 * @public
	 * @const {string}
	 */
	exports.VERSION = require$$0.version;

	/**
	 * Exports the {@linkcode PointError} class.
	 * @public
	 * @typedef {PointError} module:poly2tri.PointError
	 * @function
	 */
	exports.PointError = pointerror;
	/**
	 * Exports the {@linkcode Point} class.
	 * @public
	 * @typedef {Point} module:poly2tri.Point
	 * @function
	 */
	exports.Point = point;
	/**
	 * Exports the {@linkcode Triangle} class.
	 * @public
	 * @typedef {Triangle} module:poly2tri.Triangle
	 * @function
	 */
	exports.Triangle = triangle;
	/**
	 * Exports the {@linkcode SweepContext} class.
	 * @public
	 * @typedef {SweepContext} module:poly2tri.SweepContext
	 * @function
	 */
	exports.SweepContext = sweepcontext;


	// Backward compatibility
	var sweep = sweep$1;
	/**
	 * @function
	 * @deprecated use {@linkcode SweepContext#triangulate} instead
	 */
	exports.triangulate = sweep.triangulate;
	/**
	 * @deprecated use {@linkcode SweepContext#triangulate} instead
	 * @property {function} Triangulate - use {@linkcode SweepContext#triangulate} instead
	 */
	exports.sweep = {Triangulate: sweep.triangulate};
	}(poly2tri$1));

	var pointUtil = {};

	pointUtil.isClockwise = function(points) {
	    var sum = 0;
	    for (var i=0; i<points.length; i++) {
	        var o = i===points.length-1 ? points[0] : points[i+1];
	        sum += (o.x - points[i].x) * (o.y + points[i].y);
	    }
	    return sum > 0;
	};

	pointUtil.pointInPoly = function(points, test) {
	    //http://stackoverflow.com/a/2922778
	    var c = 0,
	        nvert = points.length, 
	        i=0, j=nvert-1, 
	        testx = test.x,
	        testy = test.y;

	    for ( ; i < nvert; j = i++) {
	        if ( ((points[i].y>testy) != (points[j].y>testy)) 
	                && (testx < (points[j].x-points[i].x) 
	                    * (testy-points[i].y) / (points[j].y-points[i].x) + points[i].x) )
	            c = !c;
	    }
	    return c;
	};

	pointUtil.indexOfPointInList = function(other, list) {
	    for (var i=0; i<list.length; i++) {
	        var p = list[i];
	        if (p.x == other.x && p.y == other.y)
	            return i;
	    }
	    return -1;
	};

	pointUtil.isCollinear = function(a, b, c) {
	    var r = (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y) ;
	    var eps = 0.0000001;

	    if (Math.abs(r) < eps)
	        return true;

	    //poly2tri also complains about this:
	    if ((a.x===b.x && b.x===c.x) || (a.y===b.y && b.y===c.y))
	        return true;

	    return false;
	};

	pointUtil.getBounds = function(contour) {
	    var minX = Number.MAX_VALUE,
	        minY = Number.MAX_VALUE,
	        maxX = -Number.MAX_VALUE,
	        maxY = -Number.MAX_VALUE;
	    for (var i=0; i<contour.length; i++) {
	        var v = contour[i];
	        minX = Math.min(minX, v.x);
	        minY = Math.min(minY, v.y);
	        maxX = Math.max(maxX, v.x);
	        maxY = Math.max(maxY, v.y);
	    }
	    return {
	        minX: minX,
	        maxX: maxX,
	        minY: minY,
	        maxY: maxY
	    };
	};

	var poly2tri = poly2tri$1;
	var util = pointUtil;

	function asPointSet(points) {
	    var contour = [];

	    for (var n=0; n<points.length; n++) {
	        var x = points[n].x;
	        var y = points[n].y;
	                
	        var np = new poly2tri.Point(x, y);
	        
	        if (util.indexOfPointInList(np, contour) === -1) {
	            if ( (n===0 || n===points.length-1) || !util.isCollinear(points[n-1], points[n], points[n+1]))
	                contour.push(np);
	        }
	    }
	    return contour;
	}

	function insideHole(poly, point) {
	    for (var i=0; i<poly.holes.length; i++) {
	        var hole = poly.holes[i];
	        if (util.pointInPoly(hole, point))
	            return true;
	    }
	    return false;
	}

	function addSteinerPoints(poly, points, sweep) {
	    var bounds = util.getBounds(poly.contour);

	    //ensure points are unique and not collinear 
	    points = asPointSet(points);

	    for (var i=0; i<points.length; i++) {
	        var p = points[i];

	        //fugly collinear fix ... gotta revisit this
	        p.x += 0.5;
	        p.y += 0.5;

	        if (p.x <= bounds.minX || p.y <= bounds.minY || p.x >= bounds.maxX || p.y >= bounds.maxY)
	            continue;

	        if (util.pointInPoly(poly.contour, p) && !insideHole(poly, p)) {
	            //We are in the polygon! Now make sure we're not in a hole..
	            sweep.addPoint(new poly2tri.Point(p.x, p.y));
	        }
	    }
	}

	/**
	 * Triangulates a list of Shape objects. 
	 */
	var shape2dTriangulate = function (shapes, steinerPoints) {
	    var windingClockwise = false;
	    var sweep = null;

	    var poly = {holes:[], contour:[]};
	    var allTris = [];

	    shapes = Array.isArray(shapes) ? shapes : [ shapes ];

	    steinerPoints = (steinerPoints && steinerPoints.length !== 0) ? steinerPoints : null;

	    for (var j=0; j<shapes.length; j++) {
	        var points = shapes[j].points;
	        
	        var set = asPointSet(points);

	        //OpenBaskerville-0.0.75 does some strange things
	        //with the moveTo command, causing the decomposition
	        //to give us an extra shape with only 1 point. This
	        //simply skips a path if it can't make up a triangle..
	        if (set.length < 3)
	            continue;

	        //check the winding order
	        if (j==0) {
	            windingClockwise = util.isClockwise(set);
	        }
	        
	        //if the sweep has already been created, maybe we're on a hole?
	        if (sweep !== null) {
	            var clock = util.isClockwise(set);

	            //we have a hole...
	            if (windingClockwise !== clock) {
	                sweep.addHole( set );
	                poly.holes.push(set);
	            } else {
	                //no hole, so it must be a new shape.
	                //add our last shape
	                if (steinerPoints!==null) {
	                    addSteinerPoints(poly, steinerPoints, sweep);
	                }

	                sweep.triangulate();
	                allTris = allTris.concat(sweep.getTriangles());

	                //reset the sweep for next shape
	                sweep = new poly2tri.SweepContext(set);
	                poly = {holes:[], contour:points};
	            }
	        } else {
	            sweep = new poly2tri.SweepContext(set);   
	            poly = {holes:[], contour:points};
	        }
	    }

	    //if the sweep is still setup, then triangulate it
	    if (sweep !== null) {
	        if (steinerPoints!==null) {
	            addSteinerPoints(poly, steinerPoints, sweep);
	        }

	        sweep.triangulate();
	        allTris = allTris.concat(sweep.getTriangles());
	    }
	    return allTris;
	};

	var decompose = fontpathShape2d;
	var triangulate = shape2dTriangulate;

	var triangulate_1 = function(glyph) {
	    var shapes = decompose(glyph);

	    for (var i=0; i<shapes.length; i++) 
	        shapes[i].simplify( this.font.units_per_EM*this.simplifyAmount, shapes[i] );

	    var triList = triangulate(shapes);

	    // unroll into a single array
	    var tris = [];
	    for (var i=0; i<triList.length; i++) {
	        var t = triList[i].getPoints();
	        tris.push(t[0].x, t[0].y);
	        tris.push(t[1].x, t[1].y);
	        tris.push(t[2].x, t[2].y);
	    }

	    return {
	        positions: new Float32Array(tris)
	    }
	};

	var Base = base;

	Base.prototype.triangulateGlyph = triangulate_1;

	var fontpathGl = Base;

	var clone_1 = clone;

	/**
	 * Creates a new mat4 initialized with values from an existing matrix
	 *
	 * @param {mat4} a matrix to clone
	 * @returns {mat4} a new 4x4 matrix
	 */
	function clone(a) {
	    var out = new Float32Array(16);
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[4] = a[4];
	    out[5] = a[5];
	    out[6] = a[6];
	    out[7] = a[7];
	    out[8] = a[8];
	    out[9] = a[9];
	    out[10] = a[10];
	    out[11] = a[11];
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	    return out;
	}

	var copy_1 = copy;

	/**
	 * Copy the values from one mat4 to another
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	function copy(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[4] = a[4];
	    out[5] = a[5];
	    out[6] = a[6];
	    out[7] = a[7];
	    out[8] = a[8];
	    out[9] = a[9];
	    out[10] = a[10];
	    out[11] = a[11];
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	    return out;
	}

	var transpose_1 = transpose;

	/**
	 * Transpose the values of a mat4
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	function transpose(out, a) {
	    // If we are transposing ourselves we can skip a few steps but have to cache some values
	    if (out === a) {
	        var a01 = a[1], a02 = a[2], a03 = a[3],
	            a12 = a[6], a13 = a[7],
	            a23 = a[11];

	        out[1] = a[4];
	        out[2] = a[8];
	        out[3] = a[12];
	        out[4] = a01;
	        out[6] = a[9];
	        out[7] = a[13];
	        out[8] = a02;
	        out[9] = a12;
	        out[11] = a[14];
	        out[12] = a03;
	        out[13] = a13;
	        out[14] = a23;
	    } else {
	        out[0] = a[0];
	        out[1] = a[4];
	        out[2] = a[8];
	        out[3] = a[12];
	        out[4] = a[1];
	        out[5] = a[5];
	        out[6] = a[9];
	        out[7] = a[13];
	        out[8] = a[2];
	        out[9] = a[6];
	        out[10] = a[10];
	        out[11] = a[14];
	        out[12] = a[3];
	        out[13] = a[7];
	        out[14] = a[11];
	        out[15] = a[15];
	    }
	    
	    return out;
	}

	var invert_1 = invert;

	/**
	 * Inverts a mat4
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	function invert(out, a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

	        b00 = a00 * a11 - a01 * a10,
	        b01 = a00 * a12 - a02 * a10,
	        b02 = a00 * a13 - a03 * a10,
	        b03 = a01 * a12 - a02 * a11,
	        b04 = a01 * a13 - a03 * a11,
	        b05 = a02 * a13 - a03 * a12,
	        b06 = a20 * a31 - a21 * a30,
	        b07 = a20 * a32 - a22 * a30,
	        b08 = a20 * a33 - a23 * a30,
	        b09 = a21 * a32 - a22 * a31,
	        b10 = a21 * a33 - a23 * a31,
	        b11 = a22 * a33 - a23 * a32,

	        // Calculate the determinant
	        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

	    if (!det) { 
	        return null; 
	    }
	    det = 1.0 / det;

	    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
	    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
	    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
	    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
	    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
	    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
	    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
	    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
	    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
	    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
	    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
	    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
	    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
	    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
	    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
	    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

	    return out;
	}

	var adjoint_1 = adjoint;

	/**
	 * Calculates the adjugate of a mat4
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	function adjoint(out, a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

	    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
	    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
	    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
	    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
	    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
	    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
	    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
	    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
	    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
	    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
	    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
	    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
	    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
	    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
	    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
	    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
	    return out;
	}

	var determinant_1 = determinant;

	/**
	 * Calculates the determinant of a mat4
	 *
	 * @param {mat4} a the source matrix
	 * @returns {Number} determinant of a
	 */
	function determinant(a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

	        b00 = a00 * a11 - a01 * a10,
	        b01 = a00 * a12 - a02 * a10,
	        b02 = a00 * a13 - a03 * a10,
	        b03 = a01 * a12 - a02 * a11,
	        b04 = a01 * a13 - a03 * a11,
	        b05 = a02 * a13 - a03 * a12,
	        b06 = a20 * a31 - a21 * a30,
	        b07 = a20 * a32 - a22 * a30,
	        b08 = a20 * a33 - a23 * a30,
	        b09 = a21 * a32 - a22 * a31,
	        b10 = a21 * a33 - a23 * a31,
	        b11 = a22 * a33 - a23 * a32;

	    // Calculate the determinant
	    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
	}

	var multiply_1 = multiply;

	/**
	 * Multiplies two mat4's
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the first operand
	 * @param {mat4} b the second operand
	 * @returns {mat4} out
	 */
	function multiply(out, a, b) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

	    // Cache only the current line of the second matrix
	    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
	    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
	    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
	    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
	    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

	    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
	    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
	    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
	    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
	    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

	    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
	    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
	    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
	    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
	    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

	    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
	    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
	    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
	    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
	    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
	    return out;
	}

	var rotate_1 = rotate;

	/**
	 * Rotates a mat4 by the given angle
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @param {vec3} axis the axis to rotate around
	 * @returns {mat4} out
	 */
	function rotate(out, a, rad, axis) {
	    var x = axis[0], y = axis[1], z = axis[2],
	        len = Math.sqrt(x * x + y * y + z * z),
	        s, c, t,
	        a00, a01, a02, a03,
	        a10, a11, a12, a13,
	        a20, a21, a22, a23,
	        b00, b01, b02,
	        b10, b11, b12,
	        b20, b21, b22;

	    if (Math.abs(len) < 0.000001) { return null; }
	    
	    len = 1 / len;
	    x *= len;
	    y *= len;
	    z *= len;

	    s = Math.sin(rad);
	    c = Math.cos(rad);
	    t = 1 - c;

	    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
	    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
	    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

	    // Construct the elements of the rotation matrix
	    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
	    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
	    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

	    // Perform rotation-specific matrix multiplication
	    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
	    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
	    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
	    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
	    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
	    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
	    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
	    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
	    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
	    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
	    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
	    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

	    if (a !== out) { // If the source and destination differ, copy the unchanged last row
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }
	    return out;
	}

	var rotateX_1 = rotateX;

	/**
	 * Rotates a matrix by the given angle around the X axis
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	function rotateX(out, a, rad) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad),
	        a10 = a[4],
	        a11 = a[5],
	        a12 = a[6],
	        a13 = a[7],
	        a20 = a[8],
	        a21 = a[9],
	        a22 = a[10],
	        a23 = a[11];

	    if (a !== out) { // If the source and destination differ, copy the unchanged rows
	        out[0]  = a[0];
	        out[1]  = a[1];
	        out[2]  = a[2];
	        out[3]  = a[3];
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }

	    // Perform axis-specific matrix multiplication
	    out[4] = a10 * c + a20 * s;
	    out[5] = a11 * c + a21 * s;
	    out[6] = a12 * c + a22 * s;
	    out[7] = a13 * c + a23 * s;
	    out[8] = a20 * c - a10 * s;
	    out[9] = a21 * c - a11 * s;
	    out[10] = a22 * c - a12 * s;
	    out[11] = a23 * c - a13 * s;
	    return out;
	}

	var rotateY_1 = rotateY;

	/**
	 * Rotates a matrix by the given angle around the Y axis
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	function rotateY(out, a, rad) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad),
	        a00 = a[0],
	        a01 = a[1],
	        a02 = a[2],
	        a03 = a[3],
	        a20 = a[8],
	        a21 = a[9],
	        a22 = a[10],
	        a23 = a[11];

	    if (a !== out) { // If the source and destination differ, copy the unchanged rows
	        out[4]  = a[4];
	        out[5]  = a[5];
	        out[6]  = a[6];
	        out[7]  = a[7];
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }

	    // Perform axis-specific matrix multiplication
	    out[0] = a00 * c - a20 * s;
	    out[1] = a01 * c - a21 * s;
	    out[2] = a02 * c - a22 * s;
	    out[3] = a03 * c - a23 * s;
	    out[8] = a00 * s + a20 * c;
	    out[9] = a01 * s + a21 * c;
	    out[10] = a02 * s + a22 * c;
	    out[11] = a03 * s + a23 * c;
	    return out;
	}

	var rotateZ_1 = rotateZ;

	/**
	 * Rotates a matrix by the given angle around the Z axis
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	function rotateZ(out, a, rad) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad),
	        a00 = a[0],
	        a01 = a[1],
	        a02 = a[2],
	        a03 = a[3],
	        a10 = a[4],
	        a11 = a[5],
	        a12 = a[6],
	        a13 = a[7];

	    if (a !== out) { // If the source and destination differ, copy the unchanged last row
	        out[8]  = a[8];
	        out[9]  = a[9];
	        out[10] = a[10];
	        out[11] = a[11];
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }

	    // Perform axis-specific matrix multiplication
	    out[0] = a00 * c + a10 * s;
	    out[1] = a01 * c + a11 * s;
	    out[2] = a02 * c + a12 * s;
	    out[3] = a03 * c + a13 * s;
	    out[4] = a10 * c - a00 * s;
	    out[5] = a11 * c - a01 * s;
	    out[6] = a12 * c - a02 * s;
	    out[7] = a13 * c - a03 * s;
	    return out;
	}

	var fromRotation_1 = fromRotation;

	/**
	 * Creates a matrix from a given angle around a given axis
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest)
	 *     mat4.rotate(dest, dest, rad, axis)
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {Number} rad the angle to rotate the matrix by
	 * @param {vec3} axis the axis to rotate around
	 * @returns {mat4} out
	 */
	function fromRotation(out, rad, axis) {
	  var s, c, t;
	  var x = axis[0];
	  var y = axis[1];
	  var z = axis[2];
	  var len = Math.sqrt(x * x + y * y + z * z);

	  if (Math.abs(len) < 0.000001) {
	    return null
	  }

	  len = 1 / len;
	  x *= len;
	  y *= len;
	  z *= len;

	  s = Math.sin(rad);
	  c = Math.cos(rad);
	  t = 1 - c;

	  // Perform rotation-specific matrix multiplication
	  out[0] = x * x * t + c;
	  out[1] = y * x * t + z * s;
	  out[2] = z * x * t - y * s;
	  out[3] = 0;
	  out[4] = x * y * t - z * s;
	  out[5] = y * y * t + c;
	  out[6] = z * y * t + x * s;
	  out[7] = 0;
	  out[8] = x * z * t + y * s;
	  out[9] = y * z * t - x * s;
	  out[10] = z * z * t + c;
	  out[11] = 0;
	  out[12] = 0;
	  out[13] = 0;
	  out[14] = 0;
	  out[15] = 1;
	  return out
	}

	var fromRotationTranslation_1 = fromRotationTranslation;

	/**
	 * Creates a matrix from a quaternion rotation and vector translation
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.translate(dest, vec);
	 *     var quatMat = mat4.create();
	 *     quat4.toMat4(quat, quatMat);
	 *     mat4.multiply(dest, quatMat);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {quat4} q Rotation quaternion
	 * @param {vec3} v Translation vector
	 * @returns {mat4} out
	 */
	function fromRotationTranslation(out, q, v) {
	    // Quaternion math
	    var x = q[0], y = q[1], z = q[2], w = q[3],
	        x2 = x + x,
	        y2 = y + y,
	        z2 = z + z,

	        xx = x * x2,
	        xy = x * y2,
	        xz = x * z2,
	        yy = y * y2,
	        yz = y * z2,
	        zz = z * z2,
	        wx = w * x2,
	        wy = w * y2,
	        wz = w * z2;

	    out[0] = 1 - (yy + zz);
	    out[1] = xy + wz;
	    out[2] = xz - wy;
	    out[3] = 0;
	    out[4] = xy - wz;
	    out[5] = 1 - (xx + zz);
	    out[6] = yz + wx;
	    out[7] = 0;
	    out[8] = xz + wy;
	    out[9] = yz - wx;
	    out[10] = 1 - (xx + yy);
	    out[11] = 0;
	    out[12] = v[0];
	    out[13] = v[1];
	    out[14] = v[2];
	    out[15] = 1;
	    
	    return out;
	}

	var fromScaling_1 = fromScaling;

	/**
	 * Creates a matrix from a vector scaling
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest)
	 *     mat4.scale(dest, dest, vec)
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {vec3} v Scaling vector
	 * @returns {mat4} out
	 */
	function fromScaling(out, v) {
	  out[0] = v[0];
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 0;
	  out[4] = 0;
	  out[5] = v[1];
	  out[6] = 0;
	  out[7] = 0;
	  out[8] = 0;
	  out[9] = 0;
	  out[10] = v[2];
	  out[11] = 0;
	  out[12] = 0;
	  out[13] = 0;
	  out[14] = 0;
	  out[15] = 1;
	  return out
	}

	var fromTranslation_1 = fromTranslation;

	/**
	 * Creates a matrix from a vector translation
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest)
	 *     mat4.translate(dest, dest, vec)
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {vec3} v Translation vector
	 * @returns {mat4} out
	 */
	function fromTranslation(out, v) {
	  out[0] = 1;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 0;
	  out[4] = 0;
	  out[5] = 1;
	  out[6] = 0;
	  out[7] = 0;
	  out[8] = 0;
	  out[9] = 0;
	  out[10] = 1;
	  out[11] = 0;
	  out[12] = v[0];
	  out[13] = v[1];
	  out[14] = v[2];
	  out[15] = 1;
	  return out
	}

	var fromXRotation_1 = fromXRotation;

	/**
	 * Creates a matrix from the given angle around the X axis
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest)
	 *     mat4.rotateX(dest, dest, rad)
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	function fromXRotation(out, rad) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad);

	    // Perform axis-specific matrix multiplication
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = c;
	    out[6] = s;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = -s;
	    out[10] = c;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out
	}

	var fromYRotation_1 = fromYRotation;

	/**
	 * Creates a matrix from the given angle around the Y axis
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest)
	 *     mat4.rotateY(dest, dest, rad)
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	function fromYRotation(out, rad) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad);

	    // Perform axis-specific matrix multiplication
	    out[0] = c;
	    out[1] = 0;
	    out[2] = -s;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = 1;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = s;
	    out[9] = 0;
	    out[10] = c;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out
	}

	var fromZRotation_1 = fromZRotation;

	/**
	 * Creates a matrix from the given angle around the Z axis
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest)
	 *     mat4.rotateZ(dest, dest, rad)
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	function fromZRotation(out, rad) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad);

	    // Perform axis-specific matrix multiplication
	    out[0] = c;
	    out[1] = s;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = -s;
	    out[5] = c;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = 1;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out
	}

	var fromQuat_1 = fromQuat;

	/**
	 * Creates a matrix from a quaternion rotation.
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {quat4} q Rotation quaternion
	 * @returns {mat4} out
	 */
	function fromQuat(out, q) {
	    var x = q[0], y = q[1], z = q[2], w = q[3],
	        x2 = x + x,
	        y2 = y + y,
	        z2 = z + z,

	        xx = x * x2,
	        yx = y * x2,
	        yy = y * y2,
	        zx = z * x2,
	        zy = z * y2,
	        zz = z * z2,
	        wx = w * x2,
	        wy = w * y2,
	        wz = w * z2;

	    out[0] = 1 - yy - zz;
	    out[1] = yx + wz;
	    out[2] = zx - wy;
	    out[3] = 0;

	    out[4] = yx - wz;
	    out[5] = 1 - xx - zz;
	    out[6] = zy + wx;
	    out[7] = 0;

	    out[8] = zx + wy;
	    out[9] = zy - wx;
	    out[10] = 1 - xx - yy;
	    out[11] = 0;

	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;

	    return out;
	}

	var frustum_1 = frustum;

	/**
	 * Generates a frustum matrix with the given bounds
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {Number} left Left bound of the frustum
	 * @param {Number} right Right bound of the frustum
	 * @param {Number} bottom Bottom bound of the frustum
	 * @param {Number} top Top bound of the frustum
	 * @param {Number} near Near bound of the frustum
	 * @param {Number} far Far bound of the frustum
	 * @returns {mat4} out
	 */
	function frustum(out, left, right, bottom, top, near, far) {
	    var rl = 1 / (right - left),
	        tb = 1 / (top - bottom),
	        nf = 1 / (near - far);
	    out[0] = (near * 2) * rl;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = (near * 2) * tb;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = (right + left) * rl;
	    out[9] = (top + bottom) * tb;
	    out[10] = (far + near) * nf;
	    out[11] = -1;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = (far * near * 2) * nf;
	    out[15] = 0;
	    return out;
	}

	var perspective_1 = perspective;

	/**
	 * Generates a perspective projection matrix with the given bounds
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {number} fovy Vertical field of view in radians
	 * @param {number} aspect Aspect ratio. typically viewport width/height
	 * @param {number} near Near bound of the frustum
	 * @param {number} far Far bound of the frustum
	 * @returns {mat4} out
	 */
	function perspective(out, fovy, aspect, near, far) {
	    var f = 1.0 / Math.tan(fovy / 2),
	        nf = 1 / (near - far);
	    out[0] = f / aspect;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = f;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = (far + near) * nf;
	    out[11] = -1;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = (2 * far * near) * nf;
	    out[15] = 0;
	    return out;
	}

	var perspectiveFromFieldOfView_1 = perspectiveFromFieldOfView;

	/**
	 * Generates a perspective projection matrix with the given field of view.
	 * This is primarily useful for generating projection matrices to be used
	 * with the still experiemental WebVR API.
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {number} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
	 * @param {number} near Near bound of the frustum
	 * @param {number} far Far bound of the frustum
	 * @returns {mat4} out
	 */
	function perspectiveFromFieldOfView(out, fov, near, far) {
	    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
	        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
	        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
	        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
	        xScale = 2.0 / (leftTan + rightTan),
	        yScale = 2.0 / (upTan + downTan);

	    out[0] = xScale;
	    out[1] = 0.0;
	    out[2] = 0.0;
	    out[3] = 0.0;
	    out[4] = 0.0;
	    out[5] = yScale;
	    out[6] = 0.0;
	    out[7] = 0.0;
	    out[8] = -((leftTan - rightTan) * xScale * 0.5);
	    out[9] = ((upTan - downTan) * yScale * 0.5);
	    out[10] = far / (near - far);
	    out[11] = -1.0;
	    out[12] = 0.0;
	    out[13] = 0.0;
	    out[14] = (far * near) / (near - far);
	    out[15] = 0.0;
	    return out;
	}

	var ortho_1 = ortho;

	/**
	 * Generates a orthogonal projection matrix with the given bounds
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {number} left Left bound of the frustum
	 * @param {number} right Right bound of the frustum
	 * @param {number} bottom Bottom bound of the frustum
	 * @param {number} top Top bound of the frustum
	 * @param {number} near Near bound of the frustum
	 * @param {number} far Far bound of the frustum
	 * @returns {mat4} out
	 */
	function ortho(out, left, right, bottom, top, near, far) {
	    var lr = 1 / (left - right),
	        bt = 1 / (bottom - top),
	        nf = 1 / (near - far);
	    out[0] = -2 * lr;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = -2 * bt;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = 2 * nf;
	    out[11] = 0;
	    out[12] = (left + right) * lr;
	    out[13] = (top + bottom) * bt;
	    out[14] = (far + near) * nf;
	    out[15] = 1;
	    return out;
	}

	var identity = identity_1;

	var lookAt_1 = lookAt;

	/**
	 * Generates a look-at matrix with the given eye position, focal point, and up axis
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {vec3} eye Position of the viewer
	 * @param {vec3} center Point the viewer is looking at
	 * @param {vec3} up vec3 pointing up
	 * @returns {mat4} out
	 */
	function lookAt(out, eye, center, up) {
	    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
	        eyex = eye[0],
	        eyey = eye[1],
	        eyez = eye[2],
	        upx = up[0],
	        upy = up[1],
	        upz = up[2],
	        centerx = center[0],
	        centery = center[1],
	        centerz = center[2];

	    if (Math.abs(eyex - centerx) < 0.000001 &&
	        Math.abs(eyey - centery) < 0.000001 &&
	        Math.abs(eyez - centerz) < 0.000001) {
	        return identity(out);
	    }

	    z0 = eyex - centerx;
	    z1 = eyey - centery;
	    z2 = eyez - centerz;

	    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
	    z0 *= len;
	    z1 *= len;
	    z2 *= len;

	    x0 = upy * z2 - upz * z1;
	    x1 = upz * z0 - upx * z2;
	    x2 = upx * z1 - upy * z0;
	    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
	    if (!len) {
	        x0 = 0;
	        x1 = 0;
	        x2 = 0;
	    } else {
	        len = 1 / len;
	        x0 *= len;
	        x1 *= len;
	        x2 *= len;
	    }

	    y0 = z1 * x2 - z2 * x1;
	    y1 = z2 * x0 - z0 * x2;
	    y2 = z0 * x1 - z1 * x0;

	    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
	    if (!len) {
	        y0 = 0;
	        y1 = 0;
	        y2 = 0;
	    } else {
	        len = 1 / len;
	        y0 *= len;
	        y1 *= len;
	        y2 *= len;
	    }

	    out[0] = x0;
	    out[1] = y0;
	    out[2] = z0;
	    out[3] = 0;
	    out[4] = x1;
	    out[5] = y1;
	    out[6] = z1;
	    out[7] = 0;
	    out[8] = x2;
	    out[9] = y2;
	    out[10] = z2;
	    out[11] = 0;
	    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
	    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
	    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
	    out[15] = 1;

	    return out;
	}

	var str_1 = str;

	/**
	 * Returns a string representation of a mat4
	 *
	 * @param {mat4} mat matrix to represent as a string
	 * @returns {String} string representation of the matrix
	 */
	function str(a) {
	    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
	                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
	                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
	                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
	}

	var glMat4 = {
	  create: create_1
	  , clone: clone_1
	  , copy: copy_1
	  , identity: identity_1
	  , transpose: transpose_1
	  , invert: invert_1
	  , adjoint: adjoint_1
	  , determinant: determinant_1
	  , multiply: multiply_1
	  , translate: translate_1
	  , scale: scale_1
	  , rotate: rotate_1
	  , rotateX: rotateX_1
	  , rotateY: rotateY_1
	  , rotateZ: rotateZ_1
	  , fromRotation: fromRotation_1
	  , fromRotationTranslation: fromRotationTranslation_1
	  , fromScaling: fromScaling_1
	  , fromTranslation: fromTranslation_1
	  , fromXRotation: fromXRotation_1
	  , fromYRotation: fromYRotation_1
	  , fromZRotation: fromZRotation_1
	  , fromQuat: fromQuat_1
	  , frustum: frustum_1
	  , perspective: perspective_1
	  , perspectiveFromFieldOfView: perspectiveFromFieldOfView_1
	  , ortho: ortho_1
	  , lookAt: lookAt_1
	  , str: str_1
	};

	// shim for using process in browser
	// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	var cachedSetTimeout = defaultSetTimout;
	var cachedClearTimeout = defaultClearTimeout;
	if (typeof global$1.setTimeout === 'function') {
	    cachedSetTimeout = setTimeout;
	}
	if (typeof global$1.clearTimeout === 'function') {
	    cachedClearTimeout = clearTimeout;
	}

	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue$1 = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue$1 = currentQueue.concat(queue$1);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue$1.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue$1.length;
	    while(len) {
	        currentQueue = queue$1;
	        queue$1 = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue$1.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	function nextTick$1(fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue$1.push(new Item(fun, args));
	    if (queue$1.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	}
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	var title = 'browser';
	var platform = 'browser';
	var browser = true;
	var env = {};
	var argv = [];
	var version = ''; // empty string to avoid regexp issues
	var versions = {};
	var release = {};
	var config = {};

	function noop() {}

	var on = noop;
	var addListener = noop;
	var once = noop;
	var off = noop;
	var removeListener = noop;
	var removeAllListeners = noop;
	var emit = noop;

	function binding(name) {
	    throw new Error('process.binding is not supported');
	}

	function cwd () { return '/' }
	function chdir (dir) {
	    throw new Error('process.chdir is not supported');
	}function umask() { return 0; }

	// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
	var performance = global$1.performance || {};
	var performanceNow =
	  performance.now        ||
	  performance.mozNow     ||
	  performance.msNow      ||
	  performance.oNow       ||
	  performance.webkitNow  ||
	  function(){ return (new Date()).getTime() };

	// generate timestamp or delta
	// see http://nodejs.org/api/process.html#process_process_hrtime
	function hrtime(previousTimestamp){
	  var clocktime = performanceNow.call(performance)*1e-3;
	  var seconds = Math.floor(clocktime);
	  var nanoseconds = Math.floor((clocktime%1)*1e9);
	  if (previousTimestamp) {
	    seconds = seconds - previousTimestamp[0];
	    nanoseconds = nanoseconds - previousTimestamp[1];
	    if (nanoseconds<0) {
	      seconds--;
	      nanoseconds += 1e9;
	    }
	  }
	  return [seconds,nanoseconds]
	}

	var startTime = new Date();
	function uptime() {
	  var currentTime = new Date();
	  var dif = currentTime - startTime;
	  return dif / 1000;
	}

	var process = {
	  nextTick: nextTick$1,
	  title: title,
	  browser: browser,
	  env: env,
	  argv: argv,
	  version: version,
	  versions: versions,
	  on: on,
	  addListener: addListener,
	  once: once,
	  off: off,
	  removeListener: removeListener,
	  removeAllListeners: removeAllListeners,
	  emit: emit,
	  binding: binding,
	  cwd: cwd,
	  chdir: chdir,
	  umask: umask,
	  hrtime: hrtime,
	  platform: platform,
	  release: release,
	  config: config,
	  uptime: uptime
	};

	/**
	 * Make a map and return a function for checking if a key
	 * is in that map.
	 * IMPORTANT: all calls of this function must be prefixed with
	 * \/\*#\_\_PURE\_\_\*\/
	 * So that rollup can tree-shake them if necessary.
	 */
	function makeMap(str, expectsLowerCase) {
	    const map = Object.create(null);
	    const list = str.split(',');
	    for (let i = 0; i < list.length; i++) {
	        map[list[i]] = true;
	    }
	    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];
	}

	const EMPTY_OBJ = Object.freeze({})
	    ;
	Object.freeze([]) ;
	const NOOP = () => { };
	const extend = Object.assign;
	const remove = (arr, el) => {
	    const i = arr.indexOf(el);
	    if (i > -1) {
	        arr.splice(i, 1);
	    }
	};
	const hasOwnProperty = Object.prototype.hasOwnProperty;
	const hasOwn = (val, key) => hasOwnProperty.call(val, key);
	const isArray = Array.isArray;
	const isMap = (val) => toTypeString(val) === '[object Map]';
	const isSet = (val) => toTypeString(val) === '[object Set]';
	const isFunction = (val) => typeof val === 'function';
	const isString = (val) => typeof val === 'string';
	const isSymbol = (val) => typeof val === 'symbol';
	const isObject = (val) => val !== null && typeof val === 'object';
	const isPromise = (val) => {
	    return isObject(val) && isFunction(val.then) && isFunction(val.catch);
	};
	const objectToString = Object.prototype.toString;
	const toTypeString = (value) => objectToString.call(value);
	const toRawType = (value) => {
	    // extract "RawType" from strings like "[object RawType]"
	    return toTypeString(value).slice(8, -1);
	};
	const isPlainObject = (val) => toTypeString(val) === '[object Object]';
	const isIntegerKey = (key) => isString(key) &&
	    key !== 'NaN' &&
	    key[0] !== '-' &&
	    '' + parseInt(key, 10) === key;
	const cacheStringFunction = (fn) => {
	    const cache = Object.create(null);
	    return ((str) => {
	        const hit = cache[str];
	        return hit || (cache[str] = fn(str));
	    });
	};
	/**
	 * @private
	 */
	const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
	// compare whether a value has changed, accounting for NaN.
	const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
	const def = (obj, key, value) => {
	    Object.defineProperty(obj, key, {
	        configurable: true,
	        enumerable: false,
	        value
	    });
	};
	let _globalThis;
	const getGlobalThis = () => {
	    return (_globalThis ||
	        (_globalThis =
	            typeof globalThis !== 'undefined'
	                ? globalThis
	                : typeof self !== 'undefined'
	                    ? self
	                    : typeof window !== 'undefined'
	                        ? window
	                        : typeof global$1 !== 'undefined'
	                            ? global$1
	                            : {}));
	};

	let activeEffectScope;
	function recordEffectScope(effect, scope) {
	    scope = scope || activeEffectScope;
	    if (scope && scope.active) {
	        scope.effects.push(effect);
	    }
	}

	const createDep = (effects) => {
	    const dep = new Set(effects);
	    dep.w = 0;
	    dep.n = 0;
	    return dep;
	};
	const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
	const newTracked = (dep) => (dep.n & trackOpBit) > 0;
	const initDepMarkers = ({ deps }) => {
	    if (deps.length) {
	        for (let i = 0; i < deps.length; i++) {
	            deps[i].w |= trackOpBit; // set was tracked
	        }
	    }
	};
	const finalizeDepMarkers = (effect) => {
	    const { deps } = effect;
	    if (deps.length) {
	        let ptr = 0;
	        for (let i = 0; i < deps.length; i++) {
	            const dep = deps[i];
	            if (wasTracked(dep) && !newTracked(dep)) {
	                dep.delete(effect);
	            }
	            else {
	                deps[ptr++] = dep;
	            }
	            // clear bits
	            dep.w &= ~trackOpBit;
	            dep.n &= ~trackOpBit;
	        }
	        deps.length = ptr;
	    }
	};

	const targetMap = new WeakMap();
	// The number of effects currently being tracked recursively.
	let effectTrackDepth = 0;
	let trackOpBit = 1;
	/**
	 * The bitwise track markers support at most 30 levels of recursion.
	 * This value is chosen to enable modern JS engines to use a SMI on all platforms.
	 * When recursion depth is greater, fall back to using a full cleanup.
	 */
	const maxMarkerBits = 30;
	const effectStack = [];
	let activeEffect;
	const ITERATE_KEY = Symbol('iterate' );
	const MAP_KEY_ITERATE_KEY = Symbol('Map key iterate' );
	class ReactiveEffect {
	    constructor(fn, scheduler = null, scope) {
	        this.fn = fn;
	        this.scheduler = scheduler;
	        this.active = true;
	        this.deps = [];
	        recordEffectScope(this, scope);
	    }
	    run() {
	        if (!this.active) {
	            return this.fn();
	        }
	        if (!effectStack.includes(this)) {
	            try {
	                effectStack.push((activeEffect = this));
	                enableTracking();
	                trackOpBit = 1 << ++effectTrackDepth;
	                if (effectTrackDepth <= maxMarkerBits) {
	                    initDepMarkers(this);
	                }
	                else {
	                    cleanupEffect(this);
	                }
	                return this.fn();
	            }
	            finally {
	                if (effectTrackDepth <= maxMarkerBits) {
	                    finalizeDepMarkers(this);
	                }
	                trackOpBit = 1 << --effectTrackDepth;
	                resetTracking();
	                effectStack.pop();
	                const n = effectStack.length;
	                activeEffect = n > 0 ? effectStack[n - 1] : undefined;
	            }
	        }
	    }
	    stop() {
	        if (this.active) {
	            cleanupEffect(this);
	            if (this.onStop) {
	                this.onStop();
	            }
	            this.active = false;
	        }
	    }
	}
	function cleanupEffect(effect) {
	    const { deps } = effect;
	    if (deps.length) {
	        for (let i = 0; i < deps.length; i++) {
	            deps[i].delete(effect);
	        }
	        deps.length = 0;
	    }
	}
	let shouldTrack = true;
	const trackStack = [];
	function pauseTracking() {
	    trackStack.push(shouldTrack);
	    shouldTrack = false;
	}
	function enableTracking() {
	    trackStack.push(shouldTrack);
	    shouldTrack = true;
	}
	function resetTracking() {
	    const last = trackStack.pop();
	    shouldTrack = last === undefined ? true : last;
	}
	function track(target, type, key) {
	    if (!isTracking()) {
	        return;
	    }
	    let depsMap = targetMap.get(target);
	    if (!depsMap) {
	        targetMap.set(target, (depsMap = new Map()));
	    }
	    let dep = depsMap.get(key);
	    if (!dep) {
	        depsMap.set(key, (dep = createDep()));
	    }
	    const eventInfo = { effect: activeEffect, target, type, key }
	        ;
	    trackEffects(dep, eventInfo);
	}
	function isTracking() {
	    return shouldTrack && activeEffect !== undefined;
	}
	function trackEffects(dep, debuggerEventExtraInfo) {
	    let shouldTrack = false;
	    if (effectTrackDepth <= maxMarkerBits) {
	        if (!newTracked(dep)) {
	            dep.n |= trackOpBit; // set newly tracked
	            shouldTrack = !wasTracked(dep);
	        }
	    }
	    else {
	        // Full cleanup mode.
	        shouldTrack = !dep.has(activeEffect);
	    }
	    if (shouldTrack) {
	        dep.add(activeEffect);
	        activeEffect.deps.push(dep);
	        if (activeEffect.onTrack) {
	            activeEffect.onTrack(Object.assign({
	                effect: activeEffect
	            }, debuggerEventExtraInfo));
	        }
	    }
	}
	function trigger(target, type, key, newValue, oldValue, oldTarget) {
	    const depsMap = targetMap.get(target);
	    if (!depsMap) {
	        // never been tracked
	        return;
	    }
	    let deps = [];
	    if (type === "clear" /* CLEAR */) {
	        // collection being cleared
	        // trigger all effects for target
	        deps = [...depsMap.values()];
	    }
	    else if (key === 'length' && isArray(target)) {
	        depsMap.forEach((dep, key) => {
	            if (key === 'length' || key >= newValue) {
	                deps.push(dep);
	            }
	        });
	    }
	    else {
	        // schedule runs for SET | ADD | DELETE
	        if (key !== void 0) {
	            deps.push(depsMap.get(key));
	        }
	        // also run for iteration key on ADD | DELETE | Map.SET
	        switch (type) {
	            case "add" /* ADD */:
	                if (!isArray(target)) {
	                    deps.push(depsMap.get(ITERATE_KEY));
	                    if (isMap(target)) {
	                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
	                    }
	                }
	                else if (isIntegerKey(key)) {
	                    // new index added to array -> length changes
	                    deps.push(depsMap.get('length'));
	                }
	                break;
	            case "delete" /* DELETE */:
	                if (!isArray(target)) {
	                    deps.push(depsMap.get(ITERATE_KEY));
	                    if (isMap(target)) {
	                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
	                    }
	                }
	                break;
	            case "set" /* SET */:
	                if (isMap(target)) {
	                    deps.push(depsMap.get(ITERATE_KEY));
	                }
	                break;
	        }
	    }
	    const eventInfo = { target, type, key, newValue, oldValue, oldTarget }
	        ;
	    if (deps.length === 1) {
	        if (deps[0]) {
	            {
	                triggerEffects(deps[0], eventInfo);
	            }
	        }
	    }
	    else {
	        const effects = [];
	        for (const dep of deps) {
	            if (dep) {
	                effects.push(...dep);
	            }
	        }
	        {
	            triggerEffects(createDep(effects), eventInfo);
	        }
	    }
	}
	function triggerEffects(dep, debuggerEventExtraInfo) {
	    // spread into array for stabilization
	    for (const effect of isArray(dep) ? dep : [...dep]) {
	        if (effect !== activeEffect || effect.allowRecurse) {
	            if (effect.onTrigger) {
	                effect.onTrigger(extend({ effect }, debuggerEventExtraInfo));
	            }
	            if (effect.scheduler) {
	                effect.scheduler();
	            }
	            else {
	                effect.run();
	            }
	        }
	    }
	}

	const isNonTrackableKeys = /*#__PURE__*/ makeMap(`__proto__,__v_isRef,__isVue`);
	const builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)
	    .map(key => Symbol[key])
	    .filter(isSymbol));
	const get = /*#__PURE__*/ createGetter();
	const readonlyGet = /*#__PURE__*/ createGetter(true);
	const shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);
	const arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations();
	function createArrayInstrumentations() {
	    const instrumentations = {};
	    ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {
	        instrumentations[key] = function (...args) {
	            const arr = toRaw(this);
	            for (let i = 0, l = this.length; i < l; i++) {
	                track(arr, "get" /* GET */, i + '');
	            }
	            // we run the method using the original args first (which may be reactive)
	            const res = arr[key](...args);
	            if (res === -1 || res === false) {
	                // if that didn't work, run it again using raw values.
	                return arr[key](...args.map(toRaw));
	            }
	            else {
	                return res;
	            }
	        };
	    });
	    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {
	        instrumentations[key] = function (...args) {
	            pauseTracking();
	            const res = toRaw(this)[key].apply(this, args);
	            resetTracking();
	            return res;
	        };
	    });
	    return instrumentations;
	}
	function createGetter(isReadonly = false, shallow = false) {
	    return function get(target, key, receiver) {
	        if (key === "__v_isReactive" /* IS_REACTIVE */) {
	            return !isReadonly;
	        }
	        else if (key === "__v_isReadonly" /* IS_READONLY */) {
	            return isReadonly;
	        }
	        else if (key === "__v_raw" /* RAW */ &&
	            receiver ===
	                (isReadonly
	                    ? shallow
	                        ? shallowReadonlyMap
	                        : readonlyMap
	                    : shallow
	                        ? shallowReactiveMap
	                        : reactiveMap).get(target)) {
	            return target;
	        }
	        const targetIsArray = isArray(target);
	        if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {
	            return Reflect.get(arrayInstrumentations, key, receiver);
	        }
	        const res = Reflect.get(target, key, receiver);
	        if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
	            return res;
	        }
	        if (!isReadonly) {
	            track(target, "get" /* GET */, key);
	        }
	        if (shallow) {
	            return res;
	        }
	        if (isRef(res)) {
	            // ref unwrapping - does not apply for Array + integer key.
	            const shouldUnwrap = !targetIsArray || !isIntegerKey(key);
	            return shouldUnwrap ? res.value : res;
	        }
	        if (isObject(res)) {
	            // Convert returned value into a proxy as well. we do the isObject check
	            // here to avoid invalid value warning. Also need to lazy access readonly
	            // and reactive here to avoid circular dependency.
	            return isReadonly ? readonly(res) : reactive(res);
	        }
	        return res;
	    };
	}
	const set = /*#__PURE__*/ createSetter();
	function createSetter(shallow = false) {
	    return function set(target, key, value, receiver) {
	        let oldValue = target[key];
	        if (!shallow && !isReadonly(value)) {
	            value = toRaw(value);
	            oldValue = toRaw(oldValue);
	            if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
	                oldValue.value = value;
	                return true;
	            }
	        }
	        const hadKey = isArray(target) && isIntegerKey(key)
	            ? Number(key) < target.length
	            : hasOwn(target, key);
	        const result = Reflect.set(target, key, value, receiver);
	        // don't trigger if target is something up in the prototype chain of original
	        if (target === toRaw(receiver)) {
	            if (!hadKey) {
	                trigger(target, "add" /* ADD */, key, value);
	            }
	            else if (hasChanged(value, oldValue)) {
	                trigger(target, "set" /* SET */, key, value, oldValue);
	            }
	        }
	        return result;
	    };
	}
	function deleteProperty(target, key) {
	    const hadKey = hasOwn(target, key);
	    const oldValue = target[key];
	    const result = Reflect.deleteProperty(target, key);
	    if (result && hadKey) {
	        trigger(target, "delete" /* DELETE */, key, undefined, oldValue);
	    }
	    return result;
	}
	function has(target, key) {
	    const result = Reflect.has(target, key);
	    if (!isSymbol(key) || !builtInSymbols.has(key)) {
	        track(target, "has" /* HAS */, key);
	    }
	    return result;
	}
	function ownKeys(target) {
	    track(target, "iterate" /* ITERATE */, isArray(target) ? 'length' : ITERATE_KEY);
	    return Reflect.ownKeys(target);
	}
	const mutableHandlers = {
	    get,
	    set,
	    deleteProperty,
	    has,
	    ownKeys
	};
	const readonlyHandlers = {
	    get: readonlyGet,
	    set(target, key) {
	        {
	            console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
	        }
	        return true;
	    },
	    deleteProperty(target, key) {
	        {
	            console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
	        }
	        return true;
	    }
	};
	// Props handlers are special in the sense that it should not unwrap top-level
	// refs (in order to allow refs to be explicitly passed down), but should
	// retain the reactivity of the normal readonly object.
	const shallowReadonlyHandlers = /*#__PURE__*/ extend({}, readonlyHandlers, {
	    get: shallowReadonlyGet
	});

	const toShallow = (value) => value;
	const getProto = (v) => Reflect.getPrototypeOf(v);
	function get$1(target, key, isReadonly = false, isShallow = false) {
	    // #1772: readonly(reactive(Map)) should return readonly + reactive version
	    // of the value
	    target = target["__v_raw" /* RAW */];
	    const rawTarget = toRaw(target);
	    const rawKey = toRaw(key);
	    if (key !== rawKey) {
	        !isReadonly && track(rawTarget, "get" /* GET */, key);
	    }
	    !isReadonly && track(rawTarget, "get" /* GET */, rawKey);
	    const { has } = getProto(rawTarget);
	    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
	    if (has.call(rawTarget, key)) {
	        return wrap(target.get(key));
	    }
	    else if (has.call(rawTarget, rawKey)) {
	        return wrap(target.get(rawKey));
	    }
	    else if (target !== rawTarget) {
	        // #3602 readonly(reactive(Map))
	        // ensure that the nested reactive `Map` can do tracking for itself
	        target.get(key);
	    }
	}
	function has$1(key, isReadonly = false) {
	    const target = this["__v_raw" /* RAW */];
	    const rawTarget = toRaw(target);
	    const rawKey = toRaw(key);
	    if (key !== rawKey) {
	        !isReadonly && track(rawTarget, "has" /* HAS */, key);
	    }
	    !isReadonly && track(rawTarget, "has" /* HAS */, rawKey);
	    return key === rawKey
	        ? target.has(key)
	        : target.has(key) || target.has(rawKey);
	}
	function size(target, isReadonly = false) {
	    target = target["__v_raw" /* RAW */];
	    !isReadonly && track(toRaw(target), "iterate" /* ITERATE */, ITERATE_KEY);
	    return Reflect.get(target, 'size', target);
	}
	function add(value) {
	    value = toRaw(value);
	    const target = toRaw(this);
	    const proto = getProto(target);
	    const hadKey = proto.has.call(target, value);
	    if (!hadKey) {
	        target.add(value);
	        trigger(target, "add" /* ADD */, value, value);
	    }
	    return this;
	}
	function set$1(key, value) {
	    value = toRaw(value);
	    const target = toRaw(this);
	    const { has, get } = getProto(target);
	    let hadKey = has.call(target, key);
	    if (!hadKey) {
	        key = toRaw(key);
	        hadKey = has.call(target, key);
	    }
	    else {
	        checkIdentityKeys(target, has, key);
	    }
	    const oldValue = get.call(target, key);
	    target.set(key, value);
	    if (!hadKey) {
	        trigger(target, "add" /* ADD */, key, value);
	    }
	    else if (hasChanged(value, oldValue)) {
	        trigger(target, "set" /* SET */, key, value, oldValue);
	    }
	    return this;
	}
	function deleteEntry(key) {
	    const target = toRaw(this);
	    const { has, get } = getProto(target);
	    let hadKey = has.call(target, key);
	    if (!hadKey) {
	        key = toRaw(key);
	        hadKey = has.call(target, key);
	    }
	    else {
	        checkIdentityKeys(target, has, key);
	    }
	    const oldValue = get ? get.call(target, key) : undefined;
	    // forward the operation before queueing reactions
	    const result = target.delete(key);
	    if (hadKey) {
	        trigger(target, "delete" /* DELETE */, key, undefined, oldValue);
	    }
	    return result;
	}
	function clear() {
	    const target = toRaw(this);
	    const hadItems = target.size !== 0;
	    const oldTarget = isMap(target)
	            ? new Map(target)
	            : new Set(target)
	        ;
	    // forward the operation before queueing reactions
	    const result = target.clear();
	    if (hadItems) {
	        trigger(target, "clear" /* CLEAR */, undefined, undefined, oldTarget);
	    }
	    return result;
	}
	function createForEach(isReadonly, isShallow) {
	    return function forEach(callback, thisArg) {
	        const observed = this;
	        const target = observed["__v_raw" /* RAW */];
	        const rawTarget = toRaw(target);
	        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
	        !isReadonly && track(rawTarget, "iterate" /* ITERATE */, ITERATE_KEY);
	        return target.forEach((value, key) => {
	            // important: make sure the callback is
	            // 1. invoked with the reactive map as `this` and 3rd arg
	            // 2. the value received should be a corresponding reactive/readonly.
	            return callback.call(thisArg, wrap(value), wrap(key), observed);
	        });
	    };
	}
	function createIterableMethod(method, isReadonly, isShallow) {
	    return function (...args) {
	        const target = this["__v_raw" /* RAW */];
	        const rawTarget = toRaw(target);
	        const targetIsMap = isMap(rawTarget);
	        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);
	        const isKeyOnly = method === 'keys' && targetIsMap;
	        const innerIterator = target[method](...args);
	        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
	        !isReadonly &&
	            track(rawTarget, "iterate" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
	        // return a wrapped iterator which returns observed versions of the
	        // values emitted from the real iterator
	        return {
	            // iterator protocol
	            next() {
	                const { value, done } = innerIterator.next();
	                return done
	                    ? { value, done }
	                    : {
	                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
	                        done
	                    };
	            },
	            // iterable protocol
	            [Symbol.iterator]() {
	                return this;
	            }
	        };
	    };
	}
	function createReadonlyMethod(type) {
	    return function (...args) {
	        {
	            const key = args[0] ? `on key "${args[0]}" ` : ``;
	            console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
	        }
	        return type === "delete" /* DELETE */ ? false : this;
	    };
	}
	function createInstrumentations() {
	    const mutableInstrumentations = {
	        get(key) {
	            return get$1(this, key);
	        },
	        get size() {
	            return size(this);
	        },
	        has: has$1,
	        add,
	        set: set$1,
	        delete: deleteEntry,
	        clear,
	        forEach: createForEach(false, false)
	    };
	    const shallowInstrumentations = {
	        get(key) {
	            return get$1(this, key, false, true);
	        },
	        get size() {
	            return size(this);
	        },
	        has: has$1,
	        add,
	        set: set$1,
	        delete: deleteEntry,
	        clear,
	        forEach: createForEach(false, true)
	    };
	    const readonlyInstrumentations = {
	        get(key) {
	            return get$1(this, key, true);
	        },
	        get size() {
	            return size(this, true);
	        },
	        has(key) {
	            return has$1.call(this, key, true);
	        },
	        add: createReadonlyMethod("add" /* ADD */),
	        set: createReadonlyMethod("set" /* SET */),
	        delete: createReadonlyMethod("delete" /* DELETE */),
	        clear: createReadonlyMethod("clear" /* CLEAR */),
	        forEach: createForEach(true, false)
	    };
	    const shallowReadonlyInstrumentations = {
	        get(key) {
	            return get$1(this, key, true, true);
	        },
	        get size() {
	            return size(this, true);
	        },
	        has(key) {
	            return has$1.call(this, key, true);
	        },
	        add: createReadonlyMethod("add" /* ADD */),
	        set: createReadonlyMethod("set" /* SET */),
	        delete: createReadonlyMethod("delete" /* DELETE */),
	        clear: createReadonlyMethod("clear" /* CLEAR */),
	        forEach: createForEach(true, true)
	    };
	    const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];
	    iteratorMethods.forEach(method => {
	        mutableInstrumentations[method] = createIterableMethod(method, false, false);
	        readonlyInstrumentations[method] = createIterableMethod(method, true, false);
	        shallowInstrumentations[method] = createIterableMethod(method, false, true);
	        shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);
	    });
	    return [
	        mutableInstrumentations,
	        readonlyInstrumentations,
	        shallowInstrumentations,
	        shallowReadonlyInstrumentations
	    ];
	}
	const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/ createInstrumentations();
	function createInstrumentationGetter(isReadonly, shallow) {
	    const instrumentations = shallow
	        ? isReadonly
	            ? shallowReadonlyInstrumentations
	            : shallowInstrumentations
	        : isReadonly
	            ? readonlyInstrumentations
	            : mutableInstrumentations;
	    return (target, key, receiver) => {
	        if (key === "__v_isReactive" /* IS_REACTIVE */) {
	            return !isReadonly;
	        }
	        else if (key === "__v_isReadonly" /* IS_READONLY */) {
	            return isReadonly;
	        }
	        else if (key === "__v_raw" /* RAW */) {
	            return target;
	        }
	        return Reflect.get(hasOwn(instrumentations, key) && key in target
	            ? instrumentations
	            : target, key, receiver);
	    };
	}
	const mutableCollectionHandlers = {
	    get: /*#__PURE__*/ createInstrumentationGetter(false, false)
	};
	const readonlyCollectionHandlers = {
	    get: /*#__PURE__*/ createInstrumentationGetter(true, false)
	};
	const shallowReadonlyCollectionHandlers = {
	    get: /*#__PURE__*/ createInstrumentationGetter(true, true)
	};
	function checkIdentityKeys(target, has, key) {
	    const rawKey = toRaw(key);
	    if (rawKey !== key && has.call(target, rawKey)) {
	        const type = toRawType(target);
	        console.warn(`Reactive ${type} contains both the raw and reactive ` +
	            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +
	            `which can lead to inconsistencies. ` +
	            `Avoid differentiating between the raw and reactive versions ` +
	            `of an object and only use the reactive version if possible.`);
	    }
	}

	const reactiveMap = new WeakMap();
	const shallowReactiveMap = new WeakMap();
	const readonlyMap = new WeakMap();
	const shallowReadonlyMap = new WeakMap();
	function targetTypeMap(rawType) {
	    switch (rawType) {
	        case 'Object':
	        case 'Array':
	            return 1 /* COMMON */;
	        case 'Map':
	        case 'Set':
	        case 'WeakMap':
	        case 'WeakSet':
	            return 2 /* COLLECTION */;
	        default:
	            return 0 /* INVALID */;
	    }
	}
	function getTargetType(value) {
	    return value["__v_skip" /* SKIP */] || !Object.isExtensible(value)
	        ? 0 /* INVALID */
	        : targetTypeMap(toRawType(value));
	}
	function reactive(target) {
	    // if trying to observe a readonly proxy, return the readonly version.
	    if (target && target["__v_isReadonly" /* IS_READONLY */]) {
	        return target;
	    }
	    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
	}
	/**
	 * Creates a readonly copy of the original object. Note the returned copy is not
	 * made reactive, but `readonly` can be called on an already reactive object.
	 */
	function readonly(target) {
	    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
	}
	/**
	 * Returns a reactive-copy of the original object, where only the root level
	 * properties are readonly, and does NOT unwrap refs nor recursively convert
	 * returned properties.
	 * This is used for creating the props proxy object for stateful components.
	 */
	function shallowReadonly(target) {
	    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
	}
	function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
	    if (!isObject(target)) {
	        {
	            console.warn(`value cannot be made reactive: ${String(target)}`);
	        }
	        return target;
	    }
	    // target is already a Proxy, return it.
	    // exception: calling readonly() on a reactive object
	    if (target["__v_raw" /* RAW */] &&
	        !(isReadonly && target["__v_isReactive" /* IS_REACTIVE */])) {
	        return target;
	    }
	    // target already has corresponding Proxy
	    const existingProxy = proxyMap.get(target);
	    if (existingProxy) {
	        return existingProxy;
	    }
	    // only a whitelist of value types can be observed.
	    const targetType = getTargetType(target);
	    if (targetType === 0 /* INVALID */) {
	        return target;
	    }
	    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);
	    proxyMap.set(target, proxy);
	    return proxy;
	}
	function isReactive(value) {
	    if (isReadonly(value)) {
	        return isReactive(value["__v_raw" /* RAW */]);
	    }
	    return !!(value && value["__v_isReactive" /* IS_REACTIVE */]);
	}
	function isReadonly(value) {
	    return !!(value && value["__v_isReadonly" /* IS_READONLY */]);
	}
	function toRaw(observed) {
	    const raw = observed && observed["__v_raw" /* RAW */];
	    return raw ? toRaw(raw) : observed;
	}
	function markRaw(value) {
	    def(value, "__v_skip" /* SKIP */, true);
	    return value;
	}
	const toReactive = (value) => isObject(value) ? reactive(value) : value;
	const toReadonly = (value) => isObject(value) ? readonly(value) : value;

	function trackRefValue(ref) {
	    if (isTracking()) {
	        ref = toRaw(ref);
	        if (!ref.dep) {
	            ref.dep = createDep();
	        }
	        {
	            trackEffects(ref.dep, {
	                target: ref,
	                type: "get" /* GET */,
	                key: 'value'
	            });
	        }
	    }
	}
	function triggerRefValue(ref, newVal) {
	    ref = toRaw(ref);
	    if (ref.dep) {
	        {
	            triggerEffects(ref.dep, {
	                target: ref,
	                type: "set" /* SET */,
	                key: 'value',
	                newValue: newVal
	            });
	        }
	    }
	}
	function isRef(r) {
	    return Boolean(r && r.__v_isRef === true);
	}
	function ref(value) {
	    return createRef(value, false);
	}
	function createRef(rawValue, shallow) {
	    if (isRef(rawValue)) {
	        return rawValue;
	    }
	    return new RefImpl(rawValue, shallow);
	}
	class RefImpl {
	    constructor(value, _shallow) {
	        this._shallow = _shallow;
	        this.dep = undefined;
	        this.__v_isRef = true;
	        this._rawValue = _shallow ? value : toRaw(value);
	        this._value = _shallow ? value : toReactive(value);
	    }
	    get value() {
	        trackRefValue(this);
	        return this._value;
	    }
	    set value(newVal) {
	        newVal = this._shallow ? newVal : toRaw(newVal);
	        if (hasChanged(newVal, this._rawValue)) {
	            this._rawValue = newVal;
	            this._value = this._shallow ? newVal : toReactive(newVal);
	            triggerRefValue(this, newVal);
	        }
	    }
	}
	function unref(ref) {
	    return isRef(ref) ? ref.value : ref;
	}
	const shallowUnwrapHandlers = {
	    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
	    set: (target, key, value, receiver) => {
	        const oldValue = target[key];
	        if (isRef(oldValue) && !isRef(value)) {
	            oldValue.value = value;
	            return true;
	        }
	        else {
	            return Reflect.set(target, key, value, receiver);
	        }
	    }
	};
	function proxyRefs(objectWithRefs) {
	    return isReactive(objectWithRefs)
	        ? objectWithRefs
	        : new Proxy(objectWithRefs, shallowUnwrapHandlers);
	}
	Promise.resolve();

	const hmrDirtyComponents = new Set();
	// Expose the HMR runtime on the global object
	// This makes it entirely tree-shakable without polluting the exports and makes
	// it easier to be used in toolings like vue-loader
	// Note: for a component to be eligible for HMR it also needs the __hmrId option
	// to be set so that its instances can be registered / removed.
	{
	    getGlobalThis().__VUE_HMR_RUNTIME__ = {
	        createRecord: tryWrap(createRecord),
	        rerender: tryWrap(rerender),
	        reload: tryWrap(reload)
	    };
	}
	const map = new Map();
	function createRecord(id, initialDef) {
	    if (map.has(id)) {
	        return false;
	    }
	    map.set(id, {
	        initialDef: normalizeClassComponent(initialDef),
	        instances: new Set()
	    });
	    return true;
	}
	function normalizeClassComponent(component) {
	    return isClassComponent(component) ? component.__vccOpts : component;
	}
	function rerender(id, newRender) {
	    const record = map.get(id);
	    if (!record) {
	        return;
	    }
	    // update initial record (for not-yet-rendered component)
	    record.initialDef.render = newRender;
	    [...record.instances].forEach(instance => {
	        if (newRender) {
	            instance.render = newRender;
	            normalizeClassComponent(instance.type).render = newRender;
	        }
	        instance.renderCache = [];
	        instance.update();
	    });
	}
	function reload(id, newComp) {
	    const record = map.get(id);
	    if (!record)
	        return;
	    newComp = normalizeClassComponent(newComp);
	    // update initial def (for not-yet-rendered components)
	    updateComponentDef(record.initialDef, newComp);
	    // create a snapshot which avoids the set being mutated during updates
	    const instances = [...record.instances];
	    for (const instance of instances) {
	        const oldComp = normalizeClassComponent(instance.type);
	        if (!hmrDirtyComponents.has(oldComp)) {
	            // 1. Update existing comp definition to match new one
	            if (oldComp !== record.initialDef) {
	                updateComponentDef(oldComp, newComp);
	            }
	            // 2. mark definition dirty. This forces the renderer to replace the
	            // component on patch.
	            hmrDirtyComponents.add(oldComp);
	        }
	        // 3. invalidate options resolution cache
	        instance.appContext.optionsCache.delete(instance.type);
	        // 4. actually update
	        if (instance.ceReload) {
	            // custom element
	            hmrDirtyComponents.add(oldComp);
	            instance.ceReload(newComp.styles);
	            hmrDirtyComponents.delete(oldComp);
	        }
	        else if (instance.parent) {
	            // 4. Force the parent instance to re-render. This will cause all updated
	            // components to be unmounted and re-mounted. Queue the update so that we
	            // don't end up forcing the same parent to re-render multiple times.
	            queueJob(instance.parent.update);
	            // instance is the inner component of an async custom element
	            // invoke to reset styles
	            if (instance.parent.type.__asyncLoader &&
	                instance.parent.ceReload) {
	                instance.parent.ceReload(newComp.styles);
	            }
	        }
	        else if (instance.appContext.reload) {
	            // root instance mounted via createApp() has a reload method
	            instance.appContext.reload();
	        }
	        else if (typeof window !== 'undefined') {
	            // root instance inside tree created via raw render(). Force reload.
	            window.location.reload();
	        }
	        else {
	            console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');
	        }
	    }
	    // 5. make sure to cleanup dirty hmr components after update
	    queuePostFlushCb(() => {
	        for (const instance of instances) {
	            hmrDirtyComponents.delete(normalizeClassComponent(instance.type));
	        }
	    });
	}
	function updateComponentDef(oldComp, newComp) {
	    extend(oldComp, newComp);
	    for (const key in oldComp) {
	        if (key !== '__file' && !(key in newComp)) {
	            delete oldComp[key];
	        }
	    }
	}
	function tryWrap(fn) {
	    return (id, arg) => {
	        try {
	            return fn(id, arg);
	        }
	        catch (e) {
	            console.error(e);
	            console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` +
	                `Full reload required.`);
	        }
	    };
	}
	function queueEffectWithSuspense(fn, suspense) {
	    if (suspense && suspense.pendingBranch) {
	        if (isArray(fn)) {
	            suspense.effects.push(...fn);
	        }
	        else {
	            suspense.effects.push(fn);
	        }
	    }
	    else {
	        queuePostFlushCb(fn);
	    }
	}
	let shouldCacheAccess = true;
	/**
	 * Resolve merged options and cache it on the component.
	 * This is done only once per-component since the merging does not involve
	 * instances.
	 */
	function resolveMergedOptions(instance) {
	    const base = instance.type;
	    const { mixins, extends: extendsOptions } = base;
	    const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
	    const cached = cache.get(base);
	    let resolved;
	    if (cached) {
	        resolved = cached;
	    }
	    else if (!globalMixins.length && !mixins && !extendsOptions) {
	        {
	            resolved = base;
	        }
	    }
	    else {
	        resolved = {};
	        if (globalMixins.length) {
	            globalMixins.forEach(m => mergeOptions(resolved, m, optionMergeStrategies, true));
	        }
	        mergeOptions(resolved, base, optionMergeStrategies);
	    }
	    cache.set(base, resolved);
	    return resolved;
	}
	function mergeOptions(to, from, strats, asMixin = false) {
	    const { mixins, extends: extendsOptions } = from;
	    if (extendsOptions) {
	        mergeOptions(to, extendsOptions, strats, true);
	    }
	    if (mixins) {
	        mixins.forEach((m) => mergeOptions(to, m, strats, true));
	    }
	    for (const key in from) {
	        if (asMixin && key === 'expose') {
	            warn(`"expose" option is ignored when declared in mixins or extends. ` +
	                    `It should only be declared in the base component itself.`);
	        }
	        else {
	            const strat = internalOptionMergeStrats[key] || (strats && strats[key]);
	            to[key] = strat ? strat(to[key], from[key]) : from[key];
	        }
	    }
	    return to;
	}
	const internalOptionMergeStrats = {
	    data: mergeDataFn,
	    props: mergeObjectOptions,
	    emits: mergeObjectOptions,
	    // objects
	    methods: mergeObjectOptions,
	    computed: mergeObjectOptions,
	    // lifecycle
	    beforeCreate: mergeAsArray,
	    created: mergeAsArray,
	    beforeMount: mergeAsArray,
	    mounted: mergeAsArray,
	    beforeUpdate: mergeAsArray,
	    updated: mergeAsArray,
	    beforeDestroy: mergeAsArray,
	    beforeUnmount: mergeAsArray,
	    destroyed: mergeAsArray,
	    unmounted: mergeAsArray,
	    activated: mergeAsArray,
	    deactivated: mergeAsArray,
	    errorCaptured: mergeAsArray,
	    serverPrefetch: mergeAsArray,
	    // assets
	    components: mergeObjectOptions,
	    directives: mergeObjectOptions,
	    // watch
	    watch: mergeWatchOptions,
	    // provide / inject
	    provide: mergeDataFn,
	    inject: mergeInject
	};
	function mergeDataFn(to, from) {
	    if (!from) {
	        return to;
	    }
	    if (!to) {
	        return from;
	    }
	    return function mergedDataFn() {
	        return (extend)(isFunction(to) ? to.call(this, this) : to, isFunction(from) ? from.call(this, this) : from);
	    };
	}
	function mergeInject(to, from) {
	    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
	}
	function normalizeInject(raw) {
	    if (isArray(raw)) {
	        const res = {};
	        for (let i = 0; i < raw.length; i++) {
	            res[raw[i]] = raw[i];
	        }
	        return res;
	    }
	    return raw;
	}
	function mergeAsArray(to, from) {
	    return to ? [...new Set([].concat(to, from))] : from;
	}
	function mergeObjectOptions(to, from) {
	    return to ? extend(extend(Object.create(null), to), from) : from;
	}
	function mergeWatchOptions(to, from) {
	    if (!to)
	        return from;
	    if (!from)
	        return to;
	    const merged = extend(Object.create(null), to);
	    for (const key in from) {
	        merged[key] = mergeAsArray(to[key], from[key]);
	    }
	    return merged;
	}

	const queuePostRenderEffect = queueEffectWithSuspense
	    ;

	/**
	 * #2437 In Vue 3, functional components do not have a public instance proxy but
	 * they exist in the internal parent chain. For code that relies on traversing
	 * public $parent chains, skip functional ones and go to the parent instead.
	 */
	const getPublicInstance = (i) => {
	    if (!i)
	        return null;
	    if (isStatefulComponent(i))
	        return getExposeProxy(i) || i.proxy;
	    return getPublicInstance(i.parent);
	};
	const publicPropertiesMap = extend(Object.create(null), {
	    $: i => i,
	    $el: i => i.vnode.el,
	    $data: i => i.data,
	    $props: i => (shallowReadonly(i.props) ),
	    $attrs: i => (shallowReadonly(i.attrs) ),
	    $slots: i => (shallowReadonly(i.slots) ),
	    $refs: i => (shallowReadonly(i.refs) ),
	    $parent: i => getPublicInstance(i.parent),
	    $root: i => getPublicInstance(i.root),
	    $emit: i => i.emit,
	    $options: i => (__VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type),
	    $forceUpdate: i => () => queueJob(i.update),
	    $nextTick: i => nextTick.bind(i.proxy),
	    $watch: i => (__VUE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP)
	});
	const PublicInstanceProxyHandlers = {
	    get({ _: instance }, key) {
	        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
	        // for internal formatters to know that this is a Vue instance
	        if (key === '__isVue') {
	            return true;
	        }
	        // prioritize <script setup> bindings during dev.
	        // this allows even properties that start with _ or $ to be used - so that
	        // it aligns with the production behavior where the render fn is inlined and
	        // indeed has access to all declared variables.
	        if (setupState !== EMPTY_OBJ &&
	            setupState.__isScriptSetup &&
	            hasOwn(setupState, key)) {
	            return setupState[key];
	        }
	        // data / props / ctx
	        // This getter gets called for every property access on the render context
	        // during render and is a major hotspot. The most expensive part of this
	        // is the multiple hasOwn() calls. It's much faster to do a simple property
	        // access on a plain object, so we use an accessCache object (with null
	        // prototype) to memoize what access type a key corresponds to.
	        let normalizedProps;
	        if (key[0] !== '$') {
	            const n = accessCache[key];
	            if (n !== undefined) {
	                switch (n) {
	                    case 1 /* SETUP */:
	                        return setupState[key];
	                    case 2 /* DATA */:
	                        return data[key];
	                    case 4 /* CONTEXT */:
	                        return ctx[key];
	                    case 3 /* PROPS */:
	                        return props[key];
	                    // default: just fallthrough
	                }
	            }
	            else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
	                accessCache[key] = 1 /* SETUP */;
	                return setupState[key];
	            }
	            else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
	                accessCache[key] = 2 /* DATA */;
	                return data[key];
	            }
	            else if (
	            // only cache other properties when instance has declared (thus stable)
	            // props
	            (normalizedProps = instance.propsOptions[0]) &&
	                hasOwn(normalizedProps, key)) {
	                accessCache[key] = 3 /* PROPS */;
	                return props[key];
	            }
	            else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
	                accessCache[key] = 4 /* CONTEXT */;
	                return ctx[key];
	            }
	            else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) {
	                accessCache[key] = 0 /* OTHER */;
	            }
	        }
	        const publicGetter = publicPropertiesMap[key];
	        let cssModule, globalProperties;
	        // public $xxx properties
	        if (publicGetter) {
	            if (key === '$attrs') {
	                track(instance, "get" /* GET */, key);
	            }
	            return publicGetter(instance);
	        }
	        else if (
	        // css module (injected by vue-loader)
	        (cssModule = type.__cssModules) &&
	            (cssModule = cssModule[key])) {
	            return cssModule;
	        }
	        else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
	            // user may set custom properties to `this` that start with `$`
	            accessCache[key] = 4 /* CONTEXT */;
	            return ctx[key];
	        }
	        else if (
	        // global properties
	        ((globalProperties = appContext.config.globalProperties),
	            hasOwn(globalProperties, key))) {
	            {
	                return globalProperties[key];
	            }
	        }
	        else ;
	    },
	    set({ _: instance }, key, value) {
	        const { data, setupState, ctx } = instance;
	        if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
	            setupState[key] = value;
	        }
	        else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
	            data[key] = value;
	        }
	        else if (hasOwn(instance.props, key)) {
	            warn(`Attempting to mutate prop "${key}". Props are readonly.`, instance);
	            return false;
	        }
	        if (key[0] === '$' && key.slice(1) in instance) {
	            warn(`Attempting to mutate public property "${key}". ` +
	                    `Properties starting with $ are reserved and readonly.`, instance);
	            return false;
	        }
	        else {
	            if (key in instance.appContext.config.globalProperties) {
	                Object.defineProperty(ctx, key, {
	                    enumerable: true,
	                    configurable: true,
	                    value
	                });
	            }
	            else {
	                ctx[key] = value;
	            }
	        }
	        return true;
	    },
	    has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
	        let normalizedProps;
	        return (!!accessCache[key] ||
	            (data !== EMPTY_OBJ && hasOwn(data, key)) ||
	            (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) ||
	            ((normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key)) ||
	            hasOwn(ctx, key) ||
	            hasOwn(publicPropertiesMap, key) ||
	            hasOwn(appContext.config.globalProperties, key));
	    }
	};
	{
	    PublicInstanceProxyHandlers.ownKeys = (target) => {
	        warn(`Avoid app logic that relies on enumerating keys on a component instance. ` +
	            `The keys will be empty in production mode to avoid performance overhead.`);
	        return Reflect.ownKeys(target);
	    };
	}
	let currentInstance = null;
	const setCurrentInstance = (instance) => {
	    currentInstance = instance;
	    instance.scope.on();
	};
	const unsetCurrentInstance = () => {
	    currentInstance && currentInstance.scope.off();
	    currentInstance = null;
	};
	function isStatefulComponent(instance) {
	    return instance.vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */;
	}
	function getExposeProxy(instance) {
	    if (instance.exposed) {
	        return (instance.exposeProxy ||
	            (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
	                get(target, key) {
	                    if (key in target) {
	                        return target[key];
	                    }
	                    else if (key in publicPropertiesMap) {
	                        return publicPropertiesMap[key](instance);
	                    }
	                }
	            })));
	    }
	}
	const classifyRE = /(?:^|[-_])(\w)/g;
	const classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');
	function getComponentName(Component) {
	    return isFunction(Component)
	        ? Component.displayName || Component.name
	        : Component.name;
	}
	/* istanbul ignore next */
	function formatComponentName(instance, Component, isRoot = false) {
	    let name = getComponentName(Component);
	    if (!name && Component.__file) {
	        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
	        if (match) {
	            name = match[1];
	        }
	    }
	    if (!name && instance && instance.parent) {
	        // try to infer the name based on reverse resolution
	        const inferFromRegistry = (registry) => {
	            for (const key in registry) {
	                if (registry[key] === Component) {
	                    return key;
	                }
	            }
	        };
	        name =
	            inferFromRegistry(instance.components ||
	                instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
	    }
	    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
	}
	function isClassComponent(value) {
	    return isFunction(value) && '__vccOpts' in value;
	}

	const stack = [];
	function pushWarningContext(vnode) {
	    stack.push(vnode);
	}
	function popWarningContext() {
	    stack.pop();
	}
	function warn(msg, ...args) {
	    // avoid props formatting or warn handler tracking deps that might be mutated
	    // during patch, leading to infinite recursion.
	    pauseTracking();
	    const instance = stack.length ? stack[stack.length - 1].component : null;
	    const appWarnHandler = instance && instance.appContext.config.warnHandler;
	    const trace = getComponentTrace();
	    if (appWarnHandler) {
	        callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [
	            msg + args.join(''),
	            instance && instance.proxy,
	            trace
	                .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)
	                .join('\n'),
	            trace
	        ]);
	    }
	    else {
	        const warnArgs = [`[Vue warn]: ${msg}`, ...args];
	        /* istanbul ignore if */
	        if (trace.length &&
	            // avoid spamming console during tests
	            !false) {
	            warnArgs.push(`\n`, ...formatTrace(trace));
	        }
	        console.warn(...warnArgs);
	    }
	    resetTracking();
	}
	function getComponentTrace() {
	    let currentVNode = stack[stack.length - 1];
	    if (!currentVNode) {
	        return [];
	    }
	    // we can't just use the stack because it will be incomplete during updates
	    // that did not start from the root. Re-construct the parent chain using
	    // instance parent pointers.
	    const normalizedStack = [];
	    while (currentVNode) {
	        const last = normalizedStack[0];
	        if (last && last.vnode === currentVNode) {
	            last.recurseCount++;
	        }
	        else {
	            normalizedStack.push({
	                vnode: currentVNode,
	                recurseCount: 0
	            });
	        }
	        const parentInstance = currentVNode.component && currentVNode.component.parent;
	        currentVNode = parentInstance && parentInstance.vnode;
	    }
	    return normalizedStack;
	}
	/* istanbul ignore next */
	function formatTrace(trace) {
	    const logs = [];
	    trace.forEach((entry, i) => {
	        logs.push(...(i === 0 ? [] : [`\n`]), ...formatTraceEntry(entry));
	    });
	    return logs;
	}
	function formatTraceEntry({ vnode, recurseCount }) {
	    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
	    const isRoot = vnode.component ? vnode.component.parent == null : false;
	    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
	    const close = `>` + postfix;
	    return vnode.props
	        ? [open, ...formatProps(vnode.props), close]
	        : [open + close];
	}
	/* istanbul ignore next */
	function formatProps(props) {
	    const res = [];
	    const keys = Object.keys(props);
	    keys.slice(0, 3).forEach(key => {
	        res.push(...formatProp(key, props[key]));
	    });
	    if (keys.length > 3) {
	        res.push(` ...`);
	    }
	    return res;
	}
	/* istanbul ignore next */
	function formatProp(key, value, raw) {
	    if (isString(value)) {
	        value = JSON.stringify(value);
	        return raw ? value : [`${key}=${value}`];
	    }
	    else if (typeof value === 'number' ||
	        typeof value === 'boolean' ||
	        value == null) {
	        return raw ? value : [`${key}=${value}`];
	    }
	    else if (isRef(value)) {
	        value = formatProp(key, toRaw(value.value), true);
	        return raw ? value : [`${key}=Ref<`, value, `>`];
	    }
	    else if (isFunction(value)) {
	        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
	    }
	    else {
	        value = toRaw(value);
	        return raw ? value : [`${key}=`, value];
	    }
	}

	const ErrorTypeStrings = {
	    ["sp" /* SERVER_PREFETCH */]: 'serverPrefetch hook',
	    ["bc" /* BEFORE_CREATE */]: 'beforeCreate hook',
	    ["c" /* CREATED */]: 'created hook',
	    ["bm" /* BEFORE_MOUNT */]: 'beforeMount hook',
	    ["m" /* MOUNTED */]: 'mounted hook',
	    ["bu" /* BEFORE_UPDATE */]: 'beforeUpdate hook',
	    ["u" /* UPDATED */]: 'updated',
	    ["bum" /* BEFORE_UNMOUNT */]: 'beforeUnmount hook',
	    ["um" /* UNMOUNTED */]: 'unmounted hook',
	    ["a" /* ACTIVATED */]: 'activated hook',
	    ["da" /* DEACTIVATED */]: 'deactivated hook',
	    ["ec" /* ERROR_CAPTURED */]: 'errorCaptured hook',
	    ["rtc" /* RENDER_TRACKED */]: 'renderTracked hook',
	    ["rtg" /* RENDER_TRIGGERED */]: 'renderTriggered hook',
	    [0 /* SETUP_FUNCTION */]: 'setup function',
	    [1 /* RENDER_FUNCTION */]: 'render function',
	    [2 /* WATCH_GETTER */]: 'watcher getter',
	    [3 /* WATCH_CALLBACK */]: 'watcher callback',
	    [4 /* WATCH_CLEANUP */]: 'watcher cleanup function',
	    [5 /* NATIVE_EVENT_HANDLER */]: 'native event handler',
	    [6 /* COMPONENT_EVENT_HANDLER */]: 'component event handler',
	    [7 /* VNODE_HOOK */]: 'vnode hook',
	    [8 /* DIRECTIVE_HOOK */]: 'directive hook',
	    [9 /* TRANSITION_HOOK */]: 'transition hook',
	    [10 /* APP_ERROR_HANDLER */]: 'app errorHandler',
	    [11 /* APP_WARN_HANDLER */]: 'app warnHandler',
	    [12 /* FUNCTION_REF */]: 'ref function',
	    [13 /* ASYNC_COMPONENT_LOADER */]: 'async component loader',
	    [14 /* SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +
	        'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next'
	};
	function callWithErrorHandling(fn, instance, type, args) {
	    let res;
	    try {
	        res = args ? fn(...args) : fn();
	    }
	    catch (err) {
	        handleError(err, instance, type);
	    }
	    return res;
	}
	function callWithAsyncErrorHandling(fn, instance, type, args) {
	    if (isFunction(fn)) {
	        const res = callWithErrorHandling(fn, instance, type, args);
	        if (res && isPromise(res)) {
	            res.catch(err => {
	                handleError(err, instance, type);
	            });
	        }
	        return res;
	    }
	    const values = [];
	    for (let i = 0; i < fn.length; i++) {
	        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
	    }
	    return values;
	}
	function handleError(err, instance, type, throwInDev = true) {
	    const contextVNode = instance ? instance.vnode : null;
	    if (instance) {
	        let cur = instance.parent;
	        // the exposed instance is the render proxy to keep it consistent with 2.x
	        const exposedInstance = instance.proxy;
	        // in production the hook receives only the error code
	        const errorInfo = ErrorTypeStrings[type] ;
	        while (cur) {
	            const errorCapturedHooks = cur.ec;
	            if (errorCapturedHooks) {
	                for (let i = 0; i < errorCapturedHooks.length; i++) {
	                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
	                        return;
	                    }
	                }
	            }
	            cur = cur.parent;
	        }
	        // app-level handling
	        const appErrorHandler = instance.appContext.config.errorHandler;
	        if (appErrorHandler) {
	            callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);
	            return;
	        }
	    }
	    logError(err, type, contextVNode, throwInDev);
	}
	function logError(err, type, contextVNode, throwInDev = true) {
	    {
	        const info = ErrorTypeStrings[type];
	        if (contextVNode) {
	            pushWarningContext(contextVNode);
	        }
	        warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
	        if (contextVNode) {
	            popWarningContext();
	        }
	        // crash in dev by default so it's more noticeable
	        if (throwInDev) {
	            throw err;
	        }
	        else {
	            console.error(err);
	        }
	    }
	}

	let isFlushing = false;
	let isFlushPending = false;
	const queue = [];
	let flushIndex = 0;
	const pendingPreFlushCbs = [];
	let activePreFlushCbs = null;
	let preFlushIndex = 0;
	const pendingPostFlushCbs = [];
	let activePostFlushCbs = null;
	let postFlushIndex = 0;
	const resolvedPromise = Promise.resolve();
	let currentFlushPromise = null;
	let currentPreFlushParentJob = null;
	const RECURSION_LIMIT = 100;
	function nextTick(fn) {
	    const p = currentFlushPromise || resolvedPromise;
	    return fn ? p.then(this ? fn.bind(this) : fn) : p;
	}
	// #2768
	// Use binary-search to find a suitable position in the queue,
	// so that the queue maintains the increasing order of job's id,
	// which can prevent the job from being skipped and also can avoid repeated patching.
	function findInsertionIndex(id) {
	    // the start index should be `flushIndex + 1`
	    let start = flushIndex + 1;
	    let end = queue.length;
	    while (start < end) {
	        const middle = (start + end) >>> 1;
	        const middleJobId = getId(queue[middle]);
	        middleJobId < id ? (start = middle + 1) : (end = middle);
	    }
	    return start;
	}
	function queueJob(job) {
	    // the dedupe search uses the startIndex argument of Array.includes()
	    // by default the search index includes the current job that is being run
	    // so it cannot recursively trigger itself again.
	    // if the job is a watch() callback, the search will start with a +1 index to
	    // allow it recursively trigger itself - it is the user's responsibility to
	    // ensure it doesn't end up in an infinite loop.
	    if ((!queue.length ||
	        !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) &&
	        job !== currentPreFlushParentJob) {
	        if (job.id == null) {
	            queue.push(job);
	        }
	        else {
	            queue.splice(findInsertionIndex(job.id), 0, job);
	        }
	        queueFlush();
	    }
	}
	function queueFlush() {
	    if (!isFlushing && !isFlushPending) {
	        isFlushPending = true;
	        currentFlushPromise = resolvedPromise.then(flushJobs);
	    }
	}
	function queueCb(cb, activeQueue, pendingQueue, index) {
	    if (!isArray(cb)) {
	        if (!activeQueue ||
	            !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {
	            pendingQueue.push(cb);
	        }
	    }
	    else {
	        // if cb is an array, it is a component lifecycle hook which can only be
	        // triggered by a job, which is already deduped in the main queue, so
	        // we can skip duplicate check here to improve perf
	        pendingQueue.push(...cb);
	    }
	    queueFlush();
	}
	function queuePreFlushCb(cb) {
	    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
	}
	function queuePostFlushCb(cb) {
	    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
	}
	function flushPreFlushCbs(seen, parentJob = null) {
	    if (pendingPreFlushCbs.length) {
	        currentPreFlushParentJob = parentJob;
	        activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
	        pendingPreFlushCbs.length = 0;
	        {
	            seen = seen || new Map();
	        }
	        for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
	            if (checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex])) {
	                continue;
	            }
	            activePreFlushCbs[preFlushIndex]();
	        }
	        activePreFlushCbs = null;
	        preFlushIndex = 0;
	        currentPreFlushParentJob = null;
	        // recursively flush until it drains
	        flushPreFlushCbs(seen, parentJob);
	    }
	}
	function flushPostFlushCbs(seen) {
	    if (pendingPostFlushCbs.length) {
	        const deduped = [...new Set(pendingPostFlushCbs)];
	        pendingPostFlushCbs.length = 0;
	        // #1947 already has active queue, nested flushPostFlushCbs call
	        if (activePostFlushCbs) {
	            activePostFlushCbs.push(...deduped);
	            return;
	        }
	        activePostFlushCbs = deduped;
	        {
	            seen = seen || new Map();
	        }
	        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
	        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
	            if (checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
	                continue;
	            }
	            activePostFlushCbs[postFlushIndex]();
	        }
	        activePostFlushCbs = null;
	        postFlushIndex = 0;
	    }
	}
	const getId = (job) => job.id == null ? Infinity : job.id;
	function flushJobs(seen) {
	    isFlushPending = false;
	    isFlushing = true;
	    {
	        seen = seen || new Map();
	    }
	    flushPreFlushCbs(seen);
	    // Sort queue before flush.
	    // This ensures that:
	    // 1. Components are updated from parent to child. (because parent is always
	    //    created before the child so its render effect will have smaller
	    //    priority number)
	    // 2. If a component is unmounted during a parent component's update,
	    //    its update can be skipped.
	    queue.sort((a, b) => getId(a) - getId(b));
	    // conditional usage of checkRecursiveUpdate must be determined out of
	    // try ... catch block since Rollup by default de-optimizes treeshaking
	    // inside try-catch. This can leave all warning code unshaked. Although
	    // they would get eventually shaken by a minifier like terser, some minifiers
	    // would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)
	    const check = (job) => checkRecursiveUpdates(seen, job)
	        ;
	    try {
	        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
	            const job = queue[flushIndex];
	            if (job && job.active !== false) {
	                if ((process.env.NODE_ENV !== 'production') && check(job)) {
	                    continue;
	                }
	                // console.log(`running:`, job.id)
	                callWithErrorHandling(job, null, 14 /* SCHEDULER */);
	            }
	        }
	    }
	    finally {
	        flushIndex = 0;
	        queue.length = 0;
	        flushPostFlushCbs(seen);
	        isFlushing = false;
	        currentFlushPromise = null;
	        // some postFlushCb queued jobs!
	        // keep flushing until it drains.
	        if (queue.length ||
	            pendingPreFlushCbs.length ||
	            pendingPostFlushCbs.length) {
	            flushJobs(seen);
	        }
	    }
	}
	function checkRecursiveUpdates(seen, fn) {
	    if (!seen.has(fn)) {
	        seen.set(fn, 1);
	    }
	    else {
	        const count = seen.get(fn);
	        if (count > RECURSION_LIMIT) {
	            const instance = fn.ownerInstance;
	            const componentName = instance && getComponentName(instance.type);
	            warn(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. ` +
	                `This means you have a reactive effect that is mutating its own ` +
	                `dependencies and thus recursively triggering itself. Possible sources ` +
	                `include component template, render function, updated hook or ` +
	                `watcher source function.`);
	            return true;
	        }
	        else {
	            seen.set(fn, count + 1);
	        }
	    }
	}
	// initial value for watchers to trigger on undefined initial values
	const INITIAL_WATCHER_VALUE = {};
	function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
	    if (!cb) {
	        if (immediate !== undefined) {
	            warn(`watch() "immediate" option is only respected when using the ` +
	                `watch(source, callback, options?) signature.`);
	        }
	        if (deep !== undefined) {
	            warn(`watch() "deep" option is only respected when using the ` +
	                `watch(source, callback, options?) signature.`);
	        }
	    }
	    const warnInvalidSource = (s) => {
	        warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +
	            `a reactive object, or an array of these types.`);
	    };
	    const instance = currentInstance;
	    let getter;
	    let forceTrigger = false;
	    let isMultiSource = false;
	    if (isRef(source)) {
	        getter = () => source.value;
	        forceTrigger = !!source._shallow;
	    }
	    else if (isReactive(source)) {
	        getter = () => source;
	        deep = true;
	    }
	    else if (isArray(source)) {
	        isMultiSource = true;
	        forceTrigger = source.some(isReactive);
	        getter = () => source.map(s => {
	            if (isRef(s)) {
	                return s.value;
	            }
	            else if (isReactive(s)) {
	                return traverse(s);
	            }
	            else if (isFunction(s)) {
	                return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */);
	            }
	            else {
	                warnInvalidSource(s);
	            }
	        });
	    }
	    else if (isFunction(source)) {
	        if (cb) {
	            // getter with cb
	            getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */);
	        }
	        else {
	            // no cb -> simple effect
	            getter = () => {
	                if (instance && instance.isUnmounted) {
	                    return;
	                }
	                if (cleanup) {
	                    cleanup();
	                }
	                return callWithAsyncErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onInvalidate]);
	            };
	        }
	    }
	    else {
	        getter = NOOP;
	        warnInvalidSource(source);
	    }
	    if (cb && deep) {
	        const baseGetter = getter;
	        getter = () => traverse(baseGetter());
	    }
	    let cleanup;
	    let onInvalidate = (fn) => {
	        cleanup = effect.onStop = () => {
	            callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);
	        };
	    };
	    let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
	    const job = () => {
	        if (!effect.active) {
	            return;
	        }
	        if (cb) {
	            // watch(source, cb)
	            const newValue = effect.run();
	            if (deep ||
	                forceTrigger ||
	                (isMultiSource
	                    ? newValue.some((v, i) => hasChanged(v, oldValue[i]))
	                    : hasChanged(newValue, oldValue)) ||
	                (false  )) {
	                // cleanup before running cb again
	                if (cleanup) {
	                    cleanup();
	                }
	                callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [
	                    newValue,
	                    // pass undefined as the old value when it's changed for the first time
	                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
	                    onInvalidate
	                ]);
	                oldValue = newValue;
	            }
	        }
	        else {
	            // watchEffect
	            effect.run();
	        }
	    };
	    // important: mark the job as a watcher callback so that scheduler knows
	    // it is allowed to self-trigger (#1727)
	    job.allowRecurse = !!cb;
	    let scheduler;
	    if (flush === 'sync') {
	        scheduler = job; // the scheduler function gets called directly
	    }
	    else if (flush === 'post') {
	        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
	    }
	    else {
	        // default: 'pre'
	        scheduler = () => {
	            if (!instance || instance.isMounted) {
	                queuePreFlushCb(job);
	            }
	            else {
	                // with 'pre' option, the first call must happen before
	                // the component is mounted so it is called synchronously.
	                job();
	            }
	        };
	    }
	    const effect = new ReactiveEffect(getter, scheduler);
	    {
	        effect.onTrack = onTrack;
	        effect.onTrigger = onTrigger;
	    }
	    // initial run
	    if (cb) {
	        if (immediate) {
	            job();
	        }
	        else {
	            oldValue = effect.run();
	        }
	    }
	    else if (flush === 'post') {
	        queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
	    }
	    else {
	        effect.run();
	    }
	    return () => {
	        effect.stop();
	        if (instance && instance.scope) {
	            remove(instance.scope.effects, effect);
	        }
	    };
	}
	// this.$watch
	function instanceWatch(source, value, options) {
	    const publicThis = this.proxy;
	    const getter = isString(source)
	        ? source.includes('.')
	            ? createPathGetter(publicThis, source)
	            : () => publicThis[source]
	        : source.bind(publicThis, publicThis);
	    let cb;
	    if (isFunction(value)) {
	        cb = value;
	    }
	    else {
	        cb = value.handler;
	        options = value;
	    }
	    const cur = currentInstance;
	    setCurrentInstance(this);
	    const res = doWatch(getter, cb.bind(publicThis), options);
	    if (cur) {
	        setCurrentInstance(cur);
	    }
	    else {
	        unsetCurrentInstance();
	    }
	    return res;
	}
	function createPathGetter(ctx, path) {
	    const segments = path.split('.');
	    return () => {
	        let cur = ctx;
	        for (let i = 0; i < segments.length && cur; i++) {
	            cur = cur[segments[i]];
	        }
	        return cur;
	    };
	}
	function traverse(value, seen) {
	    if (!isObject(value) || value["__v_skip" /* SKIP */]) {
	        return value;
	    }
	    seen = seen || new Set();
	    if (seen.has(value)) {
	        return value;
	    }
	    seen.add(value);
	    if (isRef(value)) {
	        traverse(value.value, seen);
	    }
	    else if (isArray(value)) {
	        for (let i = 0; i < value.length; i++) {
	            traverse(value[i], seen);
	        }
	    }
	    else if (isSet(value) || isMap(value)) {
	        value.forEach((v) => {
	            traverse(v, seen);
	        });
	    }
	    else if (isPlainObject(value)) {
	        for (const key in value) {
	            traverse(value[key], seen);
	        }
	    }
	    return value;
	}

	function initCustomFormatter() {
	    /* eslint-disable no-restricted-globals */
	    if (typeof window === 'undefined') {
	        return;
	    }
	    const vueStyle = { style: 'color:#3ba776' };
	    const numberStyle = { style: 'color:#0b1bc9' };
	    const stringStyle = { style: 'color:#b62e24' };
	    const keywordStyle = { style: 'color:#9d288c' };
	    // custom formatter for Chrome
	    // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html
	    const formatter = {
	        header(obj) {
	            // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup
	            if (!isObject(obj)) {
	                return null;
	            }
	            if (obj.__isVue) {
	                return ['div', vueStyle, `VueInstance`];
	            }
	            else if (isRef(obj)) {
	                return [
	                    'div',
	                    {},
	                    ['span', vueStyle, genRefFlag(obj)],
	                    '<',
	                    formatValue(obj.value),
	                    `>`
	                ];
	            }
	            else if (isReactive(obj)) {
	                return [
	                    'div',
	                    {},
	                    ['span', vueStyle, 'Reactive'],
	                    '<',
	                    formatValue(obj),
	                    `>${isReadonly(obj) ? ` (readonly)` : ``}`
	                ];
	            }
	            else if (isReadonly(obj)) {
	                return [
	                    'div',
	                    {},
	                    ['span', vueStyle, 'Readonly'],
	                    '<',
	                    formatValue(obj),
	                    '>'
	                ];
	            }
	            return null;
	        },
	        hasBody(obj) {
	            return obj && obj.__isVue;
	        },
	        body(obj) {
	            if (obj && obj.__isVue) {
	                return [
	                    'div',
	                    {},
	                    ...formatInstance(obj.$)
	                ];
	            }
	        }
	    };
	    function formatInstance(instance) {
	        const blocks = [];
	        if (instance.type.props && instance.props) {
	            blocks.push(createInstanceBlock('props', toRaw(instance.props)));
	        }
	        if (instance.setupState !== EMPTY_OBJ) {
	            blocks.push(createInstanceBlock('setup', instance.setupState));
	        }
	        if (instance.data !== EMPTY_OBJ) {
	            blocks.push(createInstanceBlock('data', toRaw(instance.data)));
	        }
	        const computed = extractKeys(instance, 'computed');
	        if (computed) {
	            blocks.push(createInstanceBlock('computed', computed));
	        }
	        const injected = extractKeys(instance, 'inject');
	        if (injected) {
	            blocks.push(createInstanceBlock('injected', injected));
	        }
	        blocks.push([
	            'div',
	            {},
	            [
	                'span',
	                {
	                    style: keywordStyle.style + ';opacity:0.66'
	                },
	                '$ (internal): '
	            ],
	            ['object', { object: instance }]
	        ]);
	        return blocks;
	    }
	    function createInstanceBlock(type, target) {
	        target = extend({}, target);
	        if (!Object.keys(target).length) {
	            return ['span', {}];
	        }
	        return [
	            'div',
	            { style: 'line-height:1.25em;margin-bottom:0.6em' },
	            [
	                'div',
	                {
	                    style: 'color:#476582'
	                },
	                type
	            ],
	            [
	                'div',
	                {
	                    style: 'padding-left:1.25em'
	                },
	                ...Object.keys(target).map(key => {
	                    return [
	                        'div',
	                        {},
	                        ['span', keywordStyle, key + ': '],
	                        formatValue(target[key], false)
	                    ];
	                })
	            ]
	        ];
	    }
	    function formatValue(v, asRaw = true) {
	        if (typeof v === 'number') {
	            return ['span', numberStyle, v];
	        }
	        else if (typeof v === 'string') {
	            return ['span', stringStyle, JSON.stringify(v)];
	        }
	        else if (typeof v === 'boolean') {
	            return ['span', keywordStyle, v];
	        }
	        else if (isObject(v)) {
	            return ['object', { object: asRaw ? toRaw(v) : v }];
	        }
	        else {
	            return ['span', stringStyle, String(v)];
	        }
	    }
	    function extractKeys(instance, type) {
	        const Comp = instance.type;
	        if (isFunction(Comp)) {
	            return;
	        }
	        const extracted = {};
	        for (const key in instance.ctx) {
	            if (isKeyOfType(Comp, key, type)) {
	                extracted[key] = instance.ctx[key];
	            }
	        }
	        return extracted;
	    }
	    function isKeyOfType(Comp, key, type) {
	        const opts = Comp[type];
	        if ((isArray(opts) && opts.includes(key)) ||
	            (isObject(opts) && key in opts)) {
	            return true;
	        }
	        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
	            return true;
	        }
	        if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {
	            return true;
	        }
	    }
	    function genRefFlag(v) {
	        if (v._shallow) {
	            return `ShallowRef`;
	        }
	        if (v.effect) {
	            return `ComputedRef`;
	        }
	        return `Ref`;
	    }
	    if (window.devtoolsFormatters) {
	        window.devtoolsFormatters.push(formatter);
	    }
	    else {
	        window.devtoolsFormatters = [formatter];
	    }
	}

	function initDev() {
	    {
	        initCustomFormatter();
	    }
	}

	// This entry exports the runtime only, and is built as
	{
	    initDev();
	}

	const canvas = document.createElement('canvas');
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
	const bannerWrapper = document.querySelector('#banner');
	bannerWrapper.appendChild(canvas);
	let gl$1 = canvas.getContext('webgl');
	const simplifyAmount = ref(0);
	const colors = ref([1, 1, 1, 1]);
	const preSets = ["hello world", "el psy kongroo", `${new Date().toLocaleDateString()}`,
	    `let angle = 0\n\r
    let value\n\r
    const step = () =\> {\n\r
        angle++\n\r
        value = Math.abs(Math.sin(angle))\n\r
        requestAnimationFrame(() =\> step())\n\r
    }\n\r
    `
	];
	const text = ref(preSets[Math.floor(Math.random() * 4)]);
	const cursor = ref("_");
	const calculate = () => {
	    const ret = parseFloat((Math.random() * 0.14).toFixed(2));
	    simplifyAmount.value = ret;
	    // const r = parseFloat((Math.random() * 0.1 + 0.8).toFixed(2))
	    // const g = parseFloat((Math.random() * 0.1 + 0.6).toFixed(2))
	    // const b = parseFloat((Math.random() * 0.1 + 0.4).toFixed(2))
	    // colors.value = [r, g, b, 1]
	};
	const createRenderer = () => {
	    calculate();
	    return fontpathGl(gl$1, {
	        fill: true,
	        simplifyAmount: simplifyAmount.value,
	        font: OpenSansRegular_ttf,
	        fontSize: Math.max(32, 150 / Math.ceil(text.value.length / 30)),
	        color: colors.value,
	        //the triangulation function, use the default poly2tri
	        triangulate: triangulate_1,
	        text: text.value + cursor.value,
	        align: 'left',
	        mode: gl$1.LINE_STRIP
	    });
	};
	const projection = glMat4.create();
	let renderer = createRenderer();
	const render = (gl) => {
	    const width = canvas.width;
	    const height = canvas.height;
	    gl.clearColor(1, .3, 0, 0);
	    gl.clear(gl.COLOR_BUFFER_BIT);
	    let pad = 20;
	    renderer.layout(window.innerWidth - pad * 2);
	    //renderer expects upper-left origin 
	    // const p = mat4.perspective(projection,fieldOfView,aspect,zNear,zFar)
	    glMat4.ortho(projection, 0, width, height, 0, 0, 1);
	    renderer.projection = projection;
	    let b = renderer.getBounds();
	    let x = width / 2 - b.width / 2, y = height / 2 - b.height / 2 - b.y;
	    renderer.draw(x, y);
	};
	const cursorShow = ref(false);
	const blinkCursor = () => {
	    if (!cursorShow.value) {
	        cursor.value = '_';
	        cursorShow.value = true;
	    }
	    else {
	        cursor.value = '';
	        cursorShow.value = false;
	    }
	};
	render(gl$1);
	// 15帧运行的动画
	const timestamp_15 = ref(0);
	// 2帧运行的动画
	const timestamp_2 = ref(0);
	const ani = (ts) => {
	    if (!!ts) {
	        if (!timestamp_15.value || ts - timestamp_15.value > 67.6) {
	            timestamp_15.value = ts;
	            renderer = createRenderer();
	        }
	        if (!timestamp_2.value || ts - timestamp_2.value > 500) {
	            timestamp_2.value = ts;
	            blinkCursor();
	        }
	    }
	    render(gl$1);
	    requestAnimationFrame((ts) => ani(ts));
	};
	ani();
	document.body.addEventListener('keypress', e => {
	    e.preventDefault();
	    text.value += e.key.length === 1 ? e.key : '\n\r';
	});
	let lastDown = '';
	document.body.addEventListener('keydown', e => {
	    if (lastDown + e.key === 'ControlBackspace' || lastDown + e.key === 'MetaBackspace') {
	        console.log('删除一行');
	        deleteLine();
	    }
	    else {
	        lastDown = e.key;
	    }
	});
	document.body.addEventListener('keyup', e => {
	    if (e.key === 'Backspace' && text.value) {
	        while (text.value.endsWith('\n\r')) {
	            text.value = text.value.slice(0, -2);
	        }
	        text.value = text.value.slice(0, -1);
	    }
	    if (e.key === 'Control' || e.key === 'Meta') {
	        lastDown = '';
	    }
	});
	const deleteLine = () => {
	    while (text.value && !text.value.endsWith('\n\r')) {
	        text.value = text.value.slice(0, -1);
	    }
	    while (text.value.endsWith('\n\r')) {
	        text.value = text.value.slice(0, -2);
	    }
	};

}));
